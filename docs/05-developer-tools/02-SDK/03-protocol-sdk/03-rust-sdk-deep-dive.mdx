---
id: rust-sdk-deep-dive
title: Rust SDK Deep Dive
---

# Rust SDK Deep Dive

This comprehensive guide covers advanced usage of the Calimero Rust SDK,
including collections, events, macros, and best practices for building
production applications.

## Table of Contents

- [Collections](#collections)
- [Events and Event Handling](#events-and-event-handling)
- [Advanced Macros](#advanced-macros)
- [State Management Patterns](#state-management-patterns)
- [Performance Optimization](#performance-optimization)
- [Testing and Debugging](#testing-and-debugging)
- [Common Patterns and Anti-patterns](#common-patterns-and-anti-patterns)

## Collections

Calimero provides a rich set of collections optimized for WebAssembly and
decentralized applications. These collections are designed to work efficiently
with the Calimero storage system.

### Core Collections

#### UnorderedMap

A hash map implementation optimized for Wasm:

```rust
use calimero_storage::collections::UnorderedMap;

#[app::state]
#[derive(Default, BorshSerialize, BorshDeserialize)]
#[borsh(crate = "calimero_sdk::borsh")]
struct MyApp {
    users: UnorderedMap<String, UserProfile>,
    settings: UnorderedMap<String, String>,
}

#[app::logic]
impl MyApp {
    pub fn add_user(&mut self, username: String, profile: UserProfile) -> Result<(), String> {
        if self.users.contains_key(&username) {
            return Err("User already exists".to_string());
        }

        self.users.insert(username, profile);
        Ok(())
    }

    pub fn get_user(&self, username: &str) -> Option<&UserProfile> {
        self.users.get(username)
    }

    pub fn remove_user(&mut self, username: &str) -> Option<UserProfile> {
        self.users.remove(username)
    }
}
```

#### UnorderedSet

A hash set for unique elements:

```rust
use calimero_storage::collections::UnorderedSet;

#[app::state]
#[derive(Default, BorshSerialize, BorshDeserialize)]
#[borsh(crate = "calimero_sdk::borsh")]
struct AccessControl {
    admins: UnorderedSet<String>,
    moderators: UnorderedSet<String>,
}

#[app::logic]
impl AccessControl {
    pub fn add_admin(&mut self, username: String) {
        self.admins.insert(username);
    }

    pub fn is_admin(&self, username: &str) -> bool {
        self.admins.contains(username)
    }

    pub fn remove_admin(&mut self, username: &str) -> bool {
        self.admins.remove(username)
    }
}
```

#### Vector

A dynamic array implementation:

```rust
use calimero_storage::collections::Vector;

#[app::state]
#[derive(Default, BorshSerialize, BorshDeserialize)]
#[borsh(crate = "calimero_sdk::borsh")]
struct TaskManager {
    tasks: Vector<Task>,
    completed_tasks: Vector<Task>,
}

#[app::logic]
impl TaskManager {
    pub fn add_task(&mut self, task: Task) {
        self.tasks.push(task);
    }

    pub fn complete_task(&mut self, index: u32) -> Result<(), String> {
        if index >= self.tasks.len() {
            return Err("Invalid task index".to_string());
        }

        let task = self.tasks.remove(index as usize);
        self.completed_tasks.push(task);
        Ok(())
    }

    pub fn get_task(&self, index: u32) -> Option<&Task> {
        self.tasks.get(index as usize)
    }
}
```

### Advanced Collection Patterns

#### Nested Collections

```rust
#[app::state]
#[derive(Default, BorshSerialize, BorshDeserialize)]
#[borsh(crate = "calimero_sdk::borsh")]
struct SocialNetwork {
    // User -> List of friends
    friendships: UnorderedMap<String, UnorderedSet<String>>,
    // User -> List of posts
    user_posts: UnorderedMap<String, Vector<Post>>,
    // Post -> List of likes
    post_likes: UnorderedMap<u64, UnorderedSet<String>>,
}

#[app::logic]
impl SocialNetwork {
    pub fn add_friend(&mut self, user: String, friend: String) {
        // Add bidirectional friendship
        self.friendships
            .entry(user.clone())
            .or_insert_with(UnorderedSet::new)
            .insert(friend.clone());

        self.friendships
            .entry(friend)
            .or_insert_with(UnorderedSet::new)
            .insert(user);
    }

    pub fn get_friends(&self, user: &str) -> Vec<&String> {
        self.friendships
            .get(user)
            .map(|friends| friends.iter().collect())
            .unwrap_or_default()
    }
}
```

#### Collection Iterators

```rust
#[app::logic]
impl MyApp {
    pub fn get_all_users(&self) -> Vec<&UserProfile> {
        self.users.values().collect()
    }

    pub fn search_users(&self, query: &str) -> Vec<&UserProfile> {
        self.users
            .iter()
            .filter(|(username, _)| username.contains(query))
            .map(|(_, profile)| profile)
            .collect()
    }

    pub fn get_active_users(&self) -> Vec<&UserProfile> {
        self.users
            .iter()
            .filter(|(_, profile)| profile.is_active)
            .map(|(_, profile)| profile)
            .collect()
    }
}
```

## Events and Event Handling

Events are a powerful way to communicate state changes and enable reactive
applications.

### Event Definition

```rust
#[app::event]
pub enum UserEvent<'a> {
    UserCreated {
        username: &'a str,
        timestamp: u64,
    },
    UserUpdated {
        username: &'a str,
        field: &'a str,
        old_value: &'a str,
        new_value: &'a str,
    },
    UserDeleted {
        username: &'a str,
        reason: &'a str,
    },
    FriendshipRequested {
        from: &'a str,
        to: &'a str,
    },
    FriendshipAccepted {
        user1: &'a str,
        user2: &'a str,
    },
}

#[app::event]
pub enum SystemEvent<'a> {
    MaintenanceMode { enabled: bool, reason: &'a str },
    PerformanceAlert { metric: &'a str, value: f64 },
    ErrorOccurred { error: &'a str, context: &'a str },
}
```

### Event Emission

```rust
#[app::logic]
impl MyApp {
    pub fn create_user(&mut self, username: String, profile: UserProfile) -> Result<(), String> {
        if self.users.contains_key(&username) {
            return Err("User already exists".to_string());
        }

        self.users.insert(username.clone(), profile);

        // Emit event
        app::emit!(UserEvent::UserCreated {
            username: &username,
            timestamp: env::block_timestamp(),
        });

        Ok(())
    }

    pub fn update_user_profile(&mut self, username: String, new_profile: UserProfile) -> Result<(), String> {
        let old_profile = self.users.get(&username)
            .ok_or("User not found")?;

        // Emit event before update
        app::emit!(UserEvent::UserUpdated {
            username: &username,
            field: "profile",
            old_value: &old_profile.to_string(),
            new_value: &new_profile.to_string(),
        });

        self.users.insert(username, new_profile);
        Ok(())
    }
}
```

### Event Handling Patterns

#### Conditional Event Emission

```rust
#[app::logic]
impl MyApp {
    pub fn process_friendship_request(&mut self, from: String, to: String) -> Result<(), String> {
        // Check if users exist
        if !self.users.contains_key(&from) || !self.users.contains_key(&to) {
            return Err("One or both users do not exist".to_string());
        }

        // Check if already friends
        if self.are_friends(&from, &to) {
            return Err("Users are already friends".to_string());
        }

        // Emit event
        app::emit!(UserEvent::FriendshipRequested {
            from: &from,
            to: &to,
        });

        // Add to pending requests
        self.pending_requests.insert((from, to));
        Ok(())
    }
}
```

#### Batch Event Emission

```rust
#[app::logic]
impl MyApp {
    pub fn bulk_update_users(&mut self, updates: Vec<(String, UserProfile)>) -> Result<(), String> {
        for (username, new_profile) in updates {
            let old_profile = self.users.get(&username)
                .ok_or(format!("User {} not found", username))?;

            // Emit individual update events
            app::emit!(UserEvent::UserUpdated {
                username: &username,
                field: "profile",
                old_value: &old_profile.to_string(),
                new_value: &new_profile.to_string(),
            });

            self.users.insert(username, new_profile);
        }

        Ok(())
    }
}
```

## Advanced Macros

### Custom State Configuration

```rust
#[app::state(
    emits = for<'a> UserEvent<'a>,
    version = "1.0.0",
    name = "UserManagementApp"
)]
#[derive(Default, BorshSerialize, BorshDeserialize)]
#[borsh(crate = "calimero_sdk::borsh")]
struct UserManagementApp {
    users: UnorderedMap<String, UserProfile>,
    settings: AppSettings,
}

#[derive(BorshSerialize, BorshDeserialize, Default)]
struct AppSettings {
    max_users: u32,
    allow_public_profiles: bool,
    maintenance_mode: bool,
}
```

### Conditional Logic

```rust
#[app::logic]
impl UserManagementApp {
    pub fn create_user(&mut self, username: String, profile: UserProfile) -> Result<(), String> {
        // Check maintenance mode
        if self.settings.maintenance_mode {
            return Err("Application is in maintenance mode".to_string());
        }

        // Check user limit
        if self.users.len() >= self.settings.max_users {
            return Err("Maximum user limit reached".to_string());
        }

        if self.users.contains_key(&username) {
            return Err("User already exists".to_string());
        }

        self.users.insert(username.clone(), profile);

        app::emit!(UserEvent::UserCreated {
            username: &username,
            timestamp: env::block_timestamp(),
        });

        Ok(())
    }
}
```

### Access Control Macros

```rust
#[app::logic]
impl UserManagementApp {
    #[app::admin_only]
    pub fn update_settings(&mut self, new_settings: AppSettings) {
        self.settings = new_settings;
    }

    #[app::moderator_or_admin]
    pub fn suspend_user(&mut self, username: String, reason: String) -> Result<(), String> {
        // Implementation
        Ok(())
    }

    pub fn get_public_profile(&self, username: &str) -> Option<&UserProfile> {
        if !self.settings.allow_public_profiles {
            return None;
        }

        self.users.get(username).filter(|profile| profile.is_public)
    }
}
```

## State Management Patterns

### Immutable State Access

```rust
#[app::logic]
impl UserManagementApp {
    pub fn get_user_stats(&self) -> UserStats {
        let total_users = self.users.len();
        let active_users = self.users.values()
            .filter(|profile| profile.is_active)
            .count();
        let premium_users = self.users.values()
            .filter(|profile| profile.is_premium)
            .count();

        UserStats {
            total: total_users as u32,
            active: active_users as u32,
            premium: premium_users as u32,
        }
    }
}
```

### Mutable State with Validation

```rust
#[app::logic]
impl UserManagementApp {
    pub fn update_user_role(&mut self, username: String, new_role: UserRole) -> Result<(), String> {
        let user = self.users.get_mut(&username)
            .ok_or("User not found")?;

        // Validate role transition
        if !self.is_valid_role_transition(&user.role, &new_role) {
            return Err("Invalid role transition".to_string());
        }

        let old_role = user.role.clone();
        user.role = new_role;

        app::emit!(UserEvent::UserUpdated {
            username: &username,
            field: "role",
            old_value: &old_role.to_string(),
            new_value: &user.role.to_string(),
        });

        Ok(())
    }

    fn is_valid_role_transition(&self, from: &UserRole, to: &UserRole) -> bool {
        match (from, to) {
            (UserRole::User, UserRole::Moderator) => true,
            (UserRole::Moderator, UserRole::Admin) => true,
            (UserRole::User, UserRole::Admin) => false, // Must go through moderator
            _ => false,
        }
    }
}
```

## Performance Optimization

### Efficient Collection Usage

```rust
#[app::logic]
impl UserManagementApp {
    // Use references to avoid cloning
    pub fn get_users_by_role(&self, role: &UserRole) -> Vec<&UserProfile> {
        self.users
            .iter()
            .filter(|(_, profile)| &profile.role == role)
            .map(|(_, profile)| profile)
            .collect()
    }

    // Batch operations for better performance
    pub fn bulk_delete_users(&mut self, usernames: Vec<String>) -> Result<(), String> {
        for username in usernames {
            if let Some(profile) = self.users.remove(&username) {
                app::emit!(UserEvent::UserDeleted {
                    username: &username,
                    reason: "Bulk deletion",
                });
            }
        }
        Ok(())
    }
}
```

### Memory Management

```rust
#[app::logic]
impl UserManagementApp {
    // Clean up old data periodically
    pub fn cleanup_old_data(&mut self, cutoff_timestamp: u64) {
        let mut to_remove = Vec::new();

        for (username, profile) in self.users.iter() {
            if profile.last_seen < cutoff_timestamp {
                to_remove.push(username.clone());
            }
        }

        for username in to_remove {
            self.users.remove(&username);
        }
    }
}
```

## Testing and Debugging

### Unit Testing

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_user_creation() {
        let mut app = UserManagementApp::default();
        let profile = UserProfile::default();

        let result = app.create_user("test_user".to_string(), profile);
        assert!(result.is_ok());
        assert!(app.users.contains_key("test_user"));
    }

    #[test]
    fn test_duplicate_user_creation() {
        let mut app = UserManagementApp::default();
        let profile = UserProfile::default();

        app.create_user("test_user".to_string(), profile.clone()).unwrap();
        let result = app.create_user("test_user".to_string(), profile);
        assert!(result.is_err());
    }
}
```

### Debug Logging

```rust
#[app::logic]
impl UserManagementApp {
    pub fn debug_state(&self) -> String {
        format!(
            "Users: {}, Settings: {:?}, Maintenance: {}",
            self.users.len(),
            self.settings,
            self.settings.maintenance_mode
        )
    }
}
```

## Common Patterns and Anti-patterns

### Good Patterns

```rust
// ✅ Use events for important state changes
pub fn promote_user(&mut self, username: String) -> Result<(), String> {
    let user = self.users.get_mut(&username)
        .ok_or("User not found")?;

    let old_role = user.role.clone();
    user.role = UserRole::Moderator;

    app::emit!(UserEvent::UserUpdated {
        username: &username,
        field: "role",
        old_value: &old_role.to_string(),
        new_value: &user.role.to_string(),
    });

    Ok(())
}

// ✅ Validate input before processing
pub fn update_user_email(&mut self, username: String, email: String) -> Result<(), String> {
    if !self.is_valid_email(&email) {
        return Err("Invalid email format".to_string());
    }

    // Process update...
    Ok(())
}
```

### Anti-patterns to Avoid

```rust
// ❌ Don't emit events for every small change
pub fn update_user_last_seen(&mut self, username: String, timestamp: u64) {
    if let Some(user) = self.users.get_mut(&username) {
        user.last_seen = timestamp;
        // Don't emit event for frequent updates like this
    }
}

// ❌ Don't ignore errors
pub fn unsafe_user_creation(&mut self, username: String, profile: UserProfile) {
    self.users.insert(username, profile); // What if username is empty?
}
```
