---
id: calimero-collections
title: Calimero Collections Reference
---

# Calimero Collections Reference

This comprehensive reference covers all available collections in the Calimero
SDK, their performance characteristics, and best practices for using them
effectively.

## Table of Contents

- [Overview](#overview)
- [Core Collections](#core-collections)
- [Specialized Collections](#specialized-collections)
- [Performance Characteristics](#performance-characteristics)
- [Collection Patterns](#collection-patterns)
- [Best Practices](#best-practices)
- [Migration from Standard Collections](#migration-from-standard-collections)

## Overview

Calimero collections are specifically designed for WebAssembly and decentralized
applications. They provide:

- **Wasm Optimization**: Designed for efficient serialization and memory usage
- **Persistent Storage**: Automatic integration with Calimero's storage system
- **Type Safety**: Full Rust type safety with compile-time guarantees
- **Performance**: Optimized for common operations in decentralized apps

## Core Collections

### UnorderedMap

A hash map implementation optimized for Wasm with O(1) average case operations.

#### Basic Usage

```rust
use calimero_storage::collections::UnorderedMap;

#[app::state]
#[derive(Default, BorshSerialize, BorshDeserialize)]
#[borsh(crate = "calimero_sdk::borsh")]
struct UserRegistry {
    users: UnorderedMap<String, UserProfile>,
    user_count: u32,
}

#[app::logic]
impl UserRegistry {
    pub fn add_user(&mut self, username: String, profile: UserProfile) -> Result<(), String> {
        if self.users.contains_key(&username) {
            return Err("User already exists".to_string());
        }

        self.users.insert(username, profile);
        self.user_count += 1;
        Ok(())
    }

    pub fn get_user(&self, username: &str) -> Option<&UserProfile> {
        self.users.get(username)
    }

    pub fn update_user(&mut self, username: String, profile: UserProfile) -> Result<(), String> {
        if !self.users.contains_key(&username) {
            return Err("User not found".to_string());
        }

        self.users.insert(username, profile);
        Ok(())
    }

    pub fn remove_user(&mut self, username: &str) -> Option<UserProfile> {
        let user = self.users.remove(username);
        if user.is_some() {
            self.user_count -= 1;
        }
        user
    }
}
```

#### Advanced Operations

```rust
#[app::logic]
impl UserRegistry {
    // Batch operations
    pub fn add_multiple_users(&mut self, users: Vec<(String, UserProfile)>) -> Result<(), String> {
        for (username, profile) in users {
            if self.users.contains_key(&username) {
                return Err(format!("User {} already exists", username));
            }
            self.users.insert(username, profile);
            self.user_count += 1;
        }
        Ok(())
    }

    // Filtering and searching
    pub fn get_users_by_role(&self, role: UserRole) -> Vec<&UserProfile> {
        self.users
            .iter()
            .filter(|(_, profile)| profile.role == role)
            .map(|(_, profile)| profile)
            .collect()
    }

    // Aggregation
    pub fn get_user_stats(&self) -> UserStats {
        let mut stats = UserStats::default();

        for (_, profile) in self.users.iter() {
            stats.total_users += 1;
            if profile.is_active {
                stats.active_users += 1;
            }
            if profile.is_premium {
                stats.premium_users += 1;
            }
        }

        stats
    }

    // Conditional updates
    pub fn update_user_if_exists(&mut self, username: String, profile: UserProfile) -> bool {
        if self.users.contains_key(&username) {
            self.users.insert(username, profile);
            true
        } else {
            false
        }
    }
}
```

### UnorderedSet

A hash set for unique elements with O(1) average case operations.

#### Basic Usage

```rust
use calimero_storage::collections::UnorderedSet;

#[app::state]
#[derive(Default, BorshSerialize, BorshDeserialize)]
#[borsh(crate = "calimero_sdk::borsh")]
struct AccessControl {
    admins: UnorderedSet<String>,
    moderators: UnorderedSet<String>,
    banned_users: UnorderedSet<String>,
}

#[app::logic]
impl AccessControl {
    pub fn add_admin(&mut self, username: String) -> bool {
        self.admins.insert(username)
    }

    pub fn remove_admin(&mut self, username: &str) -> bool {
        self.admins.remove(username)
    }

    pub fn is_admin(&self, username: &str) -> bool {
        self.admins.contains(username)
    }

    pub fn promote_to_moderator(&mut self, username: String) -> Result<(), String> {
        if !self.admins.contains(&username) {
            return Err("Only admins can be promoted to moderator".to_string());
        }

        self.moderators.insert(username);
        Ok(())
    }

    pub fn ban_user(&mut self, username: String) {
        // Remove from all access levels
        self.admins.remove(&username);
        self.moderators.remove(&username);
        self.banned_users.insert(username);
    }
}
```

#### Set Operations

```rust
#[app::logic]
impl AccessControl {
    // Union of two sets
    pub fn get_all_staff(&self) -> Vec<&String> {
        let mut all_staff: Vec<&String> = self.admins.iter().collect();
        all_staff.extend(self.moderators.iter());
        all_staff
    }

    // Check if user has any elevated privileges
    pub fn has_privileges(&self, username: &str) -> bool {
        self.admins.contains(username) || self.moderators.contains(username)
    }

    // Get users with specific role
    pub fn get_users_by_role(&self, role: UserRole) -> Vec<&String> {
        match role {
            UserRole::Admin => self.admins.iter().collect(),
            UserRole::Moderator => self.moderators.iter().collect(),
            UserRole::User => vec![], // Regular users not stored in sets
        }
    }
}
```

### Vector

A dynamic array implementation with O(1) amortized push and O(n) insert/remove
operations.

#### Basic Usage

```rust
use calimero_storage::collections::Vector;

#[app::state]
#[derive(Default, BorshSerialize, BorshDeserialize)]
#[borsh(crate = "calimero_sdk::borsh")]
struct TaskManager {
    pending_tasks: Vector<Task>,
    completed_tasks: Vector<Task>,
    task_counter: u64,
}

#[derive(BorshSerialize, BorshDeserialize, Clone)]
struct Task {
    id: u64,
    title: String,
    description: String,
    priority: TaskPriority,
    created_at: u64,
}

#[app::logic]
impl TaskManager {
    pub fn create_task(&mut self, title: String, description: String, priority: TaskPriority) -> u64 {
        let task = Task {
            id: self.task_counter,
            title,
            description,
            priority,
            created_at: env::block_timestamp(),
        };

        self.pending_tasks.push(task);
        self.task_counter += 1;
        self.task_counter - 1
    }

    pub fn get_task(&self, id: u64) -> Option<&Task> {
        self.pending_tasks
            .iter()
            .chain(self.completed_tasks.iter())
            .find(|task| task.id == id)
    }

    pub fn complete_task(&mut self, id: u64) -> Result<(), String> {
        let index = self.pending_tasks
            .iter()
            .position(|task| task.id == id)
            .ok_or("Task not found")?;

        let task = self.pending_tasks.remove(index);
        self.completed_tasks.push(task);
        Ok(())
    }

    pub fn get_tasks_by_priority(&self, priority: TaskPriority) -> Vec<&Task> {
        self.pending_tasks
            .iter()
            .filter(|task| task.priority == priority)
            .collect()
    }
}
```

#### Advanced Vector Operations

```rust
#[app::logic]
impl TaskManager {
    // Batch operations
    pub fn create_multiple_tasks(&mut self, tasks: Vec<(String, String, TaskPriority)>) -> Vec<u64> {
        let mut ids = Vec::new();

        for (title, description, priority) in tasks {
            let id = self.create_task(title, description, priority);
            ids.push(id);
        }

        ids
    }

    // Sorting and filtering
    pub fn get_high_priority_tasks(&self) -> Vec<&Task> {
        let mut high_priority: Vec<&Task> = self.pending_tasks
            .iter()
            .filter(|task| task.priority == TaskPriority::High)
            .collect();

        // Sort by creation time (oldest first)
        high_priority.sort_by(|a, b| a.created_at.cmp(&b.created_at));
        high_priority
    }

    // Pagination
    pub fn get_tasks_page(&self, page: u32, page_size: u32) -> Vec<&Task> {
        let start = (page * page_size) as usize;
        let end = start + page_size as usize;

        self.pending_tasks
            .iter()
            .skip(start)
            .take(page_size as usize)
            .collect()
    }

    // Search functionality
    pub fn search_tasks(&self, query: &str) -> Vec<&Task> {
        self.pending_tasks
            .iter()
            .filter(|task| {
                task.title.to_lowercase().contains(&query.to_lowercase()) ||
                task.description.to_lowercase().contains(&query.to_lowercase())
            })
            .collect()
    }
}
```

## Specialized Collections

### LookupMap

A map optimized for cases where you need to iterate over keys or values
frequently.

```rust
use calimero_storage::collections::LookupMap;

#[app::state]
#[derive(Default, BorshSerialize, BorshDeserialize)]
#[borsh(crate = "calimero_sdk::borsh")]
struct Analytics {
    // User -> Page views
    page_views: LookupMap<String, u32>,
    // Page -> Total views
    total_views: LookupMap<String, u64>,
}

#[app::logic]
impl Analytics {
    pub fn record_page_view(&mut self, user: String, page: String) {
        // Increment user's page views
        let user_views = self.page_views.get(&user).unwrap_or(0);
        self.page_views.insert(user, user_views + 1);

        // Increment total page views
        let total = self.total_views.get(&page).unwrap_or(0);
        self.total_views.insert(page, total + 1);
    }

    pub fn get_user_stats(&self, user: &str) -> u32 {
        self.page_views.get(user).unwrap_or(0)
    }

    pub fn get_page_stats(&self, page: &str) -> u64 {
        self.total_views.get(page).unwrap_or(0)
    }

    pub fn get_top_pages(&self, limit: usize) -> Vec<(String, u64)> {
        let mut pages: Vec<(String, u64)> = self.total_views
            .iter()
            .map(|(page, views)| (page.clone(), *views))
            .collect();

        pages.sort_by(|a, b| b.1.cmp(&a.1));
        pages.truncate(limit);
        pages
    }
}
```

### TreeMap

A sorted map implementation for cases where you need ordered keys.

```rust
use calimero_storage::collections::TreeMap;

#[app::state]
#[derive(Default, BorshSerialize, BorshDeserialize)]
#[borsh(crate = "calimero_sdk::borsh")]
struct Leaderboard {
    // Score -> List of users with that score
    score_rankings: TreeMap<u32, UnorderedSet<String>>,
    // User -> Current score
    user_scores: UnorderedMap<String, u32>,
}

#[app::logic]
impl Leaderboard {
    pub fn update_score(&mut self, user: String, new_score: u32) {
        // Remove user from old score ranking
        if let Some(old_score) = self.user_scores.get(&user) {
            if let Some(users_at_score) = self.score_rankings.get_mut(old_score) {
                users_at_score.remove(&user);

                // Remove empty score entry
                if users_at_score.is_empty() {
                    self.score_rankings.remove(old_score);
                }
            }
        }

        // Add user to new score ranking
        self.score_rankings
            .entry(new_score)
            .or_insert_with(UnorderedSet::new)
            .insert(user.clone());

        // Update user's score
        self.user_scores.insert(user, new_score);
    }

    pub fn get_top_players(&self, limit: usize) -> Vec<(String, u32)> {
        let mut top_players = Vec::new();

        // Iterate in reverse order (highest scores first)
        for (score, users) in self.score_rankings.iter().rev() {
            for user in users.iter() {
                top_players.push((user.clone(), *score));
                if top_players.len() >= limit {
                    break;
                }
            }
            if top_players.len() >= limit {
                break;
            }
        }

        top_players
    }

    pub fn get_user_rank(&self, user: &str) -> Option<u32> {
        let user_score = self.user_scores.get(user)?;
        let mut rank = 1;

        // Count users with higher scores
        for (score, users) in self.score_rankings.iter().rev() {
            if score > user_score {
                rank += users.len() as u32;
            } else {
                break;
            }
        }

        Some(rank)
    }
}
```

## Performance Characteristics

### Operation Complexity

| Collection   | Insert         | Remove   | Lookup   | Iteration |
| ------------ | -------------- | -------- | -------- | --------- |
| UnorderedMap | O(1) avg       | O(1) avg | O(1) avg | O(n)      |
| UnorderedSet | O(1) avg       | O(1) avg | O(1) avg | O(n)      |
| Vector       | O(1) amortized | O(n)     | O(1)     | O(n)      |
| LookupMap    | O(1) avg       | O(1) avg | O(1) avg | O(n)      |
| TreeMap      | O(log n)       | O(log n) | O(log n) | O(n)      |

### Memory Usage

- **UnorderedMap/Set**: Most memory efficient for large datasets
- **Vector**: Good for sequential access, moderate memory overhead
- **LookupMap**: Optimized for iteration, slightly more memory than UnorderedMap
- **TreeMap**: Highest memory overhead due to tree structure

### When to Use Each Collection

#### Use UnorderedMap when:

- You need fast key-value lookups
- Order doesn't matter
- Memory efficiency is important

#### Use UnorderedSet when:

- You need to track unique elements
- Fast membership testing is required
- Order doesn't matter

#### Use Vector when:

- You need ordered elements
- Sequential access is common
- You frequently add/remove from the end

#### Use LookupMap when:

- You frequently iterate over keys or values
- Memory overhead is acceptable
- You need both map and iteration performance

#### Use TreeMap when:

- You need sorted keys
- Range queries are common
- Order matters for your use case

## Collection Patterns

### Composite Collections

```rust
#[app::state]
#[derive(Default, BorshSerialize, BorshDeserialize)]
#[borsh(crate = "calimero_sdk::borsh")]
struct SocialNetwork {
    // User -> Friends
    friendships: UnorderedMap<String, UnorderedSet<String>>,
    // User -> Posts
    user_posts: UnorderedMap<String, Vector<Post>>,
    // Post -> Reactions
    post_reactions: UnorderedMap<u64, UnorderedMap<String, ReactionType>>,
    // User -> Followers
    followers: UnorderedMap<String, UnorderedSet<String>>,
    // User -> Following
    following: UnorderedMap<String, UnorderedSet<String>>,
}

#[app::logic]
impl SocialNetwork {
    pub fn add_friend(&mut self, user: String, friend: String) {
        // Add bidirectional friendship
        self.friendships
            .entry(user.clone())
            .or_insert_with(UnorderedSet::new)
            .insert(friend.clone());

        self.friendships
            .entry(friend)
            .or_insert_with(UnorderedSet::new)
            .insert(user);
    }

    pub fn create_post(&mut self, user: String, content: String) -> u64 {
        let post = Post {
            id: self.generate_post_id(),
            content,
            author: user.clone(),
            created_at: env::block_timestamp(),
        };

        self.user_posts
            .entry(user)
            .or_insert_with(Vector::new)
            .push(post.clone());

        post.id
    }

    pub fn follow_user(&mut self, follower: String, following: String) {
        if follower == following {
            return; // Can't follow yourself
        }

        self.followers
            .entry(following.clone())
            .or_insert_with(UnorderedSet::new)
            .insert(follower.clone());

        self.following
            .entry(follower)
            .or_insert_with(UnorderedSet::new)
            .insert(following);
    }

    pub fn get_feed(&self, user: &str) -> Vec<&Post> {
        let mut feed = Vec::new();

        // Get posts from followed users
        if let Some(following) = self.following.get(user) {
            for followed_user in following.iter() {
                if let Some(posts) = self.user_posts.get(followed_user) {
                    feed.extend(posts.iter());
                }
            }
        }

        // Sort by creation time (newest first)
        feed.sort_by(|a, b| b.created_at.cmp(&a.created_at));
        feed
    }
}
```

### Indexed Collections

```rust
#[app::state]
#[derive(Default, BorshSerialize, BorshDeserialize)]
#[borsh(crate = "calimero_sdk::borsh")]
struct ProductCatalog {
    // Product ID -> Product details
    products: UnorderedMap<u64, Product>,
    // Category -> Product IDs
    products_by_category: UnorderedMap<String, UnorderedSet<u64>>,
    // Price range -> Product IDs
    products_by_price: TreeMap<u32, UnorderedSet<u64>>,
    // Search index: word -> Product IDs
    search_index: UnorderedMap<String, UnorderedSet<u64>>,
}

#[app::logic]
impl ProductCatalog {
    pub fn add_product(&mut self, product: Product) {
        let product_id = product.id;

        // Add to main products map
        self.products.insert(product_id, product.clone());

        // Add to category index
        self.products_by_category
            .entry(product.category.clone())
            .or_insert_with(UnorderedSet::new)
            .insert(product_id);

        // Add to price index
        self.products_by_price
            .entry(product.price)
            .or_insert_with(UnorderedSet::new)
            .insert(product_id);

        // Add to search index
        for word in product.name.split_whitespace() {
            let word = word.to_lowercase();
            self.search_index
                .entry(word)
                .or_insert_with(UnorderedSet::new)
                .insert(product_id);
        }
    }

    pub fn search_products(&self, query: &str) -> Vec<&Product> {
        let query_words: Vec<&str> = query.split_whitespace().collect();
        let mut product_ids = UnorderedSet::new();

        // Find products matching all query words
        for word in query_words {
            let word = word.to_lowercase();
            if let Some(ids) = self.search_index.get(&word) {
                if product_ids.is_empty() {
                    product_ids = ids.clone();
                } else {
                    // Intersection of all word matches
                    product_ids = product_ids.intersection(ids).cloned().collect();
                }
            }
        }

        // Convert IDs to products
        product_ids
            .iter()
            .filter_map(|id| self.products.get(id))
            .collect()
    }

    pub fn get_products_by_category(&self, category: &str) -> Vec<&Product> {
        self.products_by_category
            .get(category)
            .map(|ids| {
                ids.iter()
                    .filter_map(|id| self.products.get(id))
                    .collect()
            })
            .unwrap_or_default()
    }

    pub fn get_products_in_price_range(&self, min_price: u32, max_price: u32) -> Vec<&Product> {
        let mut products = Vec::new();

        for (price, ids) in self.products_by_price.range(min_price..=max_price) {
            for id in ids.iter() {
                if let Some(product) = self.products.get(id) {
                    products.push(product);
                }
            }
        }

        products
    }
}
```

## Best Practices

### Memory Management

```rust
// ✅ Good: Clean up old data
pub fn cleanup_old_sessions(&mut self, cutoff_time: u64) {
    let mut to_remove = Vec::new();

    for (session_id, session) in self.active_sessions.iter() {
        if session.last_activity < cutoff_time {
            to_remove.push(session_id.clone());
        }
    }

    for session_id in to_remove {
        self.active_sessions.remove(&session_id);
    }
}

// ❌ Bad: Never cleaning up
pub fn add_session(&mut self, session: Session) {
    self.active_sessions.insert(session.id.clone(), session);
    // No cleanup - memory will grow indefinitely
}
```

### Efficient Iteration

```rust
// ✅ Good: Use references to avoid cloning
pub fn get_active_users(&self) -> Vec<&UserProfile> {
    self.users
        .iter()
        .filter(|(_, profile)| profile.is_active)
        .map(|(_, profile)| profile)
        .collect()
}

// ❌ Bad: Unnecessary cloning
pub fn get_active_users_bad(&self) -> Vec<UserProfile> {
    self.users
        .iter()
        .filter(|(_, profile)| profile.is_active)
        .map(|(_, profile)| profile.clone()) // Unnecessary clone
        .collect()
}
```

### Batch Operations

```rust
// ✅ Good: Batch operations for better performance
pub fn bulk_update_users(&mut self, updates: Vec<(String, UserProfile)>) -> Result<(), String> {
    for (username, profile) in updates {
        if !self.users.contains_key(&username) {
            return Err(format!("User {} not found", username));
        }
        self.users.insert(username, profile);
    }
    Ok(())
}

// ❌ Bad: Multiple individual operations
pub fn bulk_update_users_bad(&mut self, updates: Vec<(String, UserProfile)>) -> Result<(), String> {
    for (username, profile) in updates {
        self.update_user(username, profile)?; // Multiple function calls
    }
    Ok(())
}
```

## Migration from Standard Collections

### From std::collections::HashMap

```rust
// Before (standard collections)
use std::collections::HashMap;

struct OldApp {
    users: HashMap<String, UserProfile>,
}

// After (Calimero collections)
use calimero_storage::collections::UnorderedMap;

#[app::state]
#[derive(Default, BorshSerialize, BorshDeserialize)]
#[borsh(crate = "calimero_sdk::borsh")]
struct NewApp {
    users: UnorderedMap<String, UserProfile>,
}
```

### From std::collections::HashSet

```rust
// Before
use std::collections::HashSet;

struct OldApp {
    admins: HashSet<String>,
}

// After
use calimero_storage::collections::UnorderedSet;

#[app::state]
#[derive(Default, BorshSerialize, BorshDeserialize)]
#[borsh(crate = "calimero_sdk::borsh")]
struct NewApp {
    admins: UnorderedSet<String>,
}
```

### From Vec

```rust
// Before
struct OldApp {
    tasks: Vec<Task>,
}

// After
use calimero_storage::collections::Vector;

#[app::state]
#[derive(Default, BorshSerialize, BorshDeserialize)]
#[borsh(crate = "calimero_sdk::borsh")]
struct NewApp {
    tasks: Vector<Task>,
}
```
