---
id: calimero-collections
title: Calimero Collections Reference
---

# Calimero Collections Reference

This comprehensive reference covers all available collections in the Calimero
SDK, their performance characteristics, and best practices for using them
effectively.

## Table of Contents

- [Overview](#overview)
- [Core Collections](#core-collections)
- [Specialized Collections](#specialized-collections)
- [Performance Characteristics](#performance-characteristics)
- [Collection Patterns](#collection-patterns)
- [Best Practices](#best-practices)
- [Migration from Standard Collections](#migration-from-standard-collections)

## Overview

Calimero collections are specifically designed for WebAssembly and decentralized
applications. They provide:

- **Wasm Optimization**: Designed for efficient serialization and memory usage
- **Persistent Storage**: Automatic integration with Calimero's storage system
- **Type Safety**: Full Rust type safety with compile-time guarantees
- **Performance**: Optimized for common operations in decentralized apps
- **Error Handling**: All operations return `Result<T, StoreError>` for robust
  error handling

## Core Collections

### UnorderedMap

A hash map implementation optimized for Wasm with O(1) average case operations.
All operations return `Result<T, StoreError>`.

#### Basic Usage

```rust
use calimero_storage::collections::UnorderedMap;

#[app::state]
#[derive(Default, BorshSerialize, BorshDeserialize)]
#[borsh(crate = "calimero_sdk::borsh")]
struct UserRegistry {
    users: UnorderedMap<String, UserProfile>,
    user_count: u32,
}

#[app::logic]
impl UserRegistry {
    pub fn add_user(&mut self, username: String, profile: UserProfile) -> app::Result<()> {
        if self.users.contains_key(&username)? {
            return app::bail!("User already exists");
        }

        self.users.insert(username, profile)?;
        self.user_count += 1;
        Ok(())
    }

    pub fn get_user(&self, username: &str) -> app::Result<Option<UserProfile>> {
        self.users.get(username).map_err(Into::into)
    }

    pub fn update_user(&mut self, username: String, profile: UserProfile) -> app::Result<()> {
        if !self.users.contains_key(&username)? {
            return app::bail!("User not found");
        }

        self.users.insert(username, profile)?;
        Ok(())
    }

    pub fn remove_user(&mut self, username: &str) -> app::Result<Option<UserProfile>> {
        let user = self.users.remove(username)?;
        if user.is_some() {
            self.user_count -= 1;
        }
        Ok(user)
    }
}
```

#### Advanced Operations

```rust
#[app::logic]
impl UserRegistry {
    // Batch operations
    pub fn add_multiple_users(&mut self, users: Vec<(String, UserProfile)>) -> app::Result<()> {
        for (username, profile) in users {
            if self.users.contains_key(&username)? {
                return app::bail!("User {} already exists", username);
            }
            self.users.insert(username, profile)?;
            self.user_count += 1;
        }
        Ok(())
    }

    // Iteration
    pub fn get_all_users(&self) -> app::Result<Vec<UserProfile>> {
        self.users.entries()?.collect()
    }

    // Search
    pub fn search_users(&self, query: &str) -> app::Result<Vec<UserProfile>> {
        Ok(self.users
            .entries()?
            .filter(|(username, _)| username.contains(query))
            .map(|(_, profile)| profile)
            .collect())
    }

    // Statistics
    pub fn get_user_count(&self) -> app::Result<usize> {
        self.users.len()
    }
}
```

### UnorderedSet

A hash set for unique elements with similar performance characteristics to
UnorderedMap.

```rust
use calimero_storage::collections::UnorderedSet;

#[app::state]
#[derive(Default, BorshSerialize, BorshDeserialize)]
#[borsh(crate = "calimero_sdk::borsh")]
struct AccessControl {
    admins: UnorderedSet<String>,
    moderators: UnorderedSet<String>,
}

#[app::logic]
impl AccessControl {
    pub fn add_admin(&mut self, username: String) -> app::Result<()> {
        self.admins.insert(username)?;
        Ok(())
    }

    pub fn is_admin(&self, username: &str) -> app::Result<bool> {
        self.admins.contains(username)
    }

    pub fn remove_admin(&mut self, username: &str) -> app::Result<bool> {
        self.admins.remove(username)
    }

    pub fn get_admin_count(&self) -> app::Result<usize> {
        self.admins.len()
    }

    pub fn get_all_admins(&self) -> app::Result<Vec<String>> {
        self.admins.entries()?.collect()
    }
}
```

### Vector

A dynamic array implementation optimized for sequential access.

```rust
use calimero_storage::collections::Vector;

#[app::state]
#[derive(Default, BorshSerialize, BorshDeserialize)]
#[borsh(crate = "calimero_sdk::borsh")]
struct TaskManager {
    tasks: Vector<Task>,
    completed_tasks: Vector<Task>,
}

#[app::logic]
impl TaskManager {
    pub fn add_task(&mut self, task: Task) -> app::Result<()> {
        self.tasks.insert(None, task)?;
        Ok(())
    }

    pub fn complete_task(&mut self, index: u32) -> app::Result<()> {
        if index >= self.tasks.len()? {
            return app::bail!("Invalid task index");
        }

        let task = self.tasks.remove(index as usize)?;
        self.completed_tasks.insert(None, task)?;
        Ok(())
    }

    pub fn get_task(&self, index: u32) -> app::Result<Option<Task>> {
        if index >= self.tasks.len()? {
            return Ok(None);
        }
        self.tasks.get(index as usize)
    }

    pub fn get_all_tasks(&self) -> app::Result<Vec<Task>> {
        self.tasks.entries()?.collect()
    }
}
```

## Specialized Collections

### Nested Collections

Complex data structures can be built by nesting collections:

```rust
#[app::state]
#[derive(Default, BorshSerialize, BorshDeserialize)]
#[borsh(crate = "calimero_sdk::borsh")]
struct SocialNetwork {
    // User -> List of friends
    friendships: UnorderedMap<String, UnorderedSet<String>>,
    // User -> List of posts
    user_posts: UnorderedMap<String, Vector<Post>>,
    // Post -> List of likes
    post_likes: UnorderedMap<u64, UnorderedSet<String>>,
}

#[app::logic]
impl SocialNetwork {
    pub fn add_friend(&mut self, user: String, friend: String) -> app::Result<()> {
        // Add bidirectional friendship
        self.friendships
            .entry(user.clone())
            .or_insert_with(|| UnorderedSet::new())
            .insert(friend.clone())?;

        self.friendships
            .entry(friend)
            .or_insert_with(|| UnorderedSet::new())
            .insert(user)?;

        Ok(())
    }

    pub fn get_friends(&self, user: &str) -> app::Result<Vec<String>> {
        Ok(self.friendships
            .get(user)?
            .map(|friends| friends.entries()?.collect())
            .unwrap_or_default())
    }

    pub fn add_post(&mut self, user: String, post: Post) -> app::Result<()> {
        self.user_posts
            .entry(user.clone())
            .or_insert_with(|| Vector::new())
            .insert(None, post)?;
        Ok(())
    }
}
```

## Performance Characteristics

### Operation Complexity

| Operation | UnorderedMap | UnorderedSet | Vector |
| --------- | ------------ | ------------ | ------ |
| Insert    | O(1) avg     | O(1) avg     | O(1)   |
| Get       | O(1) avg     | O(1) avg     | O(1)   |
| Remove    | O(1) avg     | O(1) avg     | O(n)   |
| Iterate   | O(n)         | O(n)         | O(n)   |
| Contains  | O(1) avg     | O(1) avg     | O(n)   |

### Memory Usage

- **UnorderedMap/UnorderedSet**: Hash table overhead + key-value storage
- **Vector**: Dynamic array with growth factor
- All collections automatically handle serialization/deserialization

## Collection Patterns

### Entry API for Conditional Operations

```rust
#[app::logic]
impl UserRegistry {
    pub fn get_or_create_user(&mut self, username: String) -> app::Result<&mut UserProfile> {
        // This pattern doesn't work with current API - collections return Result
        // Use conditional logic instead
        if !self.users.contains_key(&username)? {
            let default_profile = UserProfile::default();
            self.users.insert(username.clone(), default_profile)?;
        }

        // Note: We can't return &mut due to Result wrapper
        // Consider returning the value or using a different pattern
        Ok(())
    }
}
```

### Batch Operations

```rust
#[app::logic]
impl UserRegistry {
    pub fn bulk_update_users(&mut self, updates: Vec<(String, UserProfile)>) -> app::Result<()> {
        for (username, profile) in updates {
            self.users.insert(username, profile)?;
        }
        Ok(())
    }

    pub fn bulk_remove_users(&mut self, usernames: Vec<String>) -> app::Result<usize> {
        let mut removed_count = 0;
        for username in usernames {
            if self.users.remove(&username)?.is_some() {
                removed_count += 1;
            }
        }
        Ok(removed_count)
    }
}
```

## Best Practices

### Error Handling

Always handle the `Result` returned by collection operations:

```rust
// ❌ Bad - ignoring errors
let value = self.users.get(&key).unwrap();

// ✅ Good - proper error handling
let value = match self.users.get(&key)? {
    Some(v) => v,
    None => return app::bail!("User not found"),
};
```

### Memory Management

```rust
// ❌ Bad - creating unnecessary clones
let all_users: Vec<String> = self.users.entries()?
    .map(|(k, _)| k.clone())
    .collect();

// ✅ Good - avoid unnecessary cloning
let all_users: Vec<&String> = self.users.entries()?
    .map(|(k, _)| k)
    .collect();
```

### Transaction Safety

```rust
#[app::logic]
impl UserRegistry {
    pub fn transfer_user(&mut self, from: String, to: String) -> app::Result<()> {
        // All operations are atomic - if any fail, all changes are rolled back
        let profile = self.users.remove(&from)?
            .ok_or_else(|| app::err!("Source user not found"))?;

        self.users.insert(to, profile)?;
        Ok(())
    }
}
```

## Migration from Standard Collections

### Key Differences

| Standard Collection | Calimero Collection  | Key Changes                     |
| ------------------- | -------------------- | ------------------------------- |
| `HashMap<K, V>`     | `UnorderedMap<K, V>` | Returns `Result<T, StoreError>` |
| `HashSet<T>`        | `UnorderedSet<T>`    | Returns `Result<T, StoreError>` |
| `Vec<T>`            | `Vector<T>`          | Returns `Result<T, StoreError>` |

### Migration Example

```rust
// Before (standard collections)
use std::collections::HashMap;

struct OldApp {
    users: HashMap<String, UserProfile>,
}

impl OldApp {
    pub fn add_user(&mut self, username: String, profile: UserProfile) {
        self.users.insert(username, profile);
    }
}

// After (Calimero collections)
use calimero_storage::collections::UnorderedMap;

#[app::state]
#[derive(Default, BorshSerialize, BorshDeserialize)]
#[borsh(crate = "calimero_sdk::borsh")]
struct NewApp {
    users: UnorderedMap<String, UserProfile>,
}

#[app::logic]
impl NewApp {
    pub fn add_user(&mut self, username: String, profile: UserProfile) -> app::Result<()> {
        self.users.insert(username, profile)?;
        Ok(())
    }
}
```

## Common Pitfalls

### Forgetting Error Handling

```rust
// ❌ This will not compile
let user = self.users.get(&username).unwrap();

// ✅ Handle the Result
let user = self.users.get(&username)?;
```

### Assuming Standard Collection Methods

```rust
// ❌ Standard collections don't have these methods
let count = self.users.len(); // Standard collections return usize directly

// ✅ Calimero collections return Result
let count = self.users.len()?; // Returns Result<usize, StoreError>
```

### Ignoring Storage Errors

```rust
// ❌ Bad - storage errors can indicate serious issues
if let Ok(user) = self.users.get(&username) {
    // Handle user
}

// ✅ Good - propagate errors up
let user = self.users.get(&username)?;
```

## Next Steps

- Learn about [Rust SDK Macros](./protocol-rs-sdk) for application structure
- See [Rust SDK Deep Dive](./rust-sdk-deep-dive) for advanced patterns
