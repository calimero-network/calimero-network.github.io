# Calimero Network

> Calimero Network is a framework which enables building fully decentralized applications, ensuring everyone's data privacy.

This file contains all documentation content in a single document following the llmstxt.org standard.

## What is Calimero

## What is Calimero Network

Calimero is a development framework that enables building and running
peer-to-peer Self-Sovereign applications focusing on data ownership and
harnessing the power of verified off-chain computing.

### Framework Architecture

The Calimero framework is built around several key components that work together
to create a seamless development experience:

**Client Nodes**: These are the core participants in the network - any device or
computer that runs Calimero applications. Each node acts as a gateway that runs
applications and connects with other peers, encapsulating the complexities of
decentralized networking.

**WebAssembly (WASM) Applications**: Applications in Calimero are compiled to
WebAssembly format, ensuring secure, isolated execution. Each application runs
in its own sandboxed environment within the WASM virtual machine, preventing
interference between different applications while maintaining high performance.

**Contexts**: The heart of the Calimero ecosystem, contexts are
application-specific networks that enable direct communication between users.
Each context consolidates all necessary components into a secure, isolated
environment where participants only synchronize with each other, not the entire
network.

**Runtime Environment**: The framework provides a robust runtime that manages
multiple applications concurrently, handles state synchronization, ensures
atomic transactions, and provides scoped storage for each context. This runtime
abstracts away the complexity of distributed systems from developers.

**Development SDKs**: Calimero provides comprehensive development tools:

- **Protocol SDK**: For building the core application logic in Rust, defining
  how applications behave and communicate
- **Client SDK**: For creating user interfaces in TypeScript, handling
  authentication and data interactions

**Specialized Nodes**: For applications requiring additional capabilities,
specialized nodes provide services like encrypted storage, delegated execution,
and administrative functions while maintaining the decentralized nature of the
network.

## Core Principles

Calimero is built on the principle of **local-first execution with eventual
consistency**. This means that each actor can independently drive their own
local state, and the network will eventually reconcile to the same state. This
approach pegs scalability to the number of actors in the network, making
executions practically instantaneous.

### Context-Aware State Reconciliation

All activity in Calimero revolves around an instance of an app, called a
context. Participants of a context only synchronize with each other, not the
entire network. This eliminates the need for global consensus and gas fees, with
execution costs borne directly by the actor.

### Inherent Privacy

Calimero leverages direct-actor relationships to encrypt all network traffic
between participants, making the network inherently private. Unlike blockchains
that achieve integrity through transparency, Calimero enables private
environments while maintaining data integrity.

### Embeddable Architecture

Calimero is designed to be embeddable, meaning that client apps themselves
become the network actors, and the network is the app itself. This creates a
seamless integration where the framework becomes part of your application rather
than a separate entity.

## Open Web tech stack

Calimero is designed to complement and enhance existing technologies rather than
replace them:

### Blockchain Integration

While Calimero offers an alternative to traditional blockchain approaches, it
can also integrate with blockchains for specific use cases. The framework can
leverage blockchain for settlement, identity verification, or as a source of
truth when needed, while handling the majority of application logic locally.

### Storage Solutions

Calimero includes built-in encrypted data storage capabilities, but can also
integrate with existing storage solutions like IPFS when additional storage
requirements arise. The framework focuses on compute while providing flexible
storage options.

### Zero-Knowledge (ZK) Enhancements

ZK solutions can complement Calimero by providing enhanced privacy features
within its framework. This combination offers the best of both worlds -
Calimero's local-first execution with ZK's privacy guarantees - without
inheriting the synchronization complexities of traditional ZK implementations.

The rest of this documentation explores how to use Calimero with these and other
technologies to build powerful self-sovereign applications.

---

## Use Cases

There are a lot of use cases where Calimero can be used and here are some of
them:

## Private DAOs Management

Migrate sensitive on-chain and off-chain data into a DAO-owned private Calimero
application, enabling you to interact with the base chain of the DAO. DAO
members keep the core contract logic on-chain, while shielding all the sensitive
data.

## Decentralized Voting Systems

Enhance trust in voting by creating a secure and tamper-proof voting process
application, ensuring each vote is counted accurately and cannot be altered.
This technology enhances trust in voting by providing verifiable and immutable
records while protecting voter privacy. It empowers voters, reduces the risk of
fraud, and promotes democratic participation through a transparent and secure
voting platform.

## Decentralized Social Platforms

Build social experiences which need scalable but private data like social
groups, direct messages and others, while eliminating high transaction costs
(gas fees associated with blockchains). This can include exclusive groups and
gated communities based on ownership of NFTs or token payments which would allow
participation and decryption of the community data content.

## Decentralized Productivity (DeProd) SaaS

Create a decentralized productivity tools suite by self hosting your data on
Calimero’s private applications and move away from the control of centralized
entities. The new platform would mitigate the burden of lifetime deals and hard
migration processes for the current users of Productivity SaaS solutions.

## Decentralized Gig Economy

Disrupt the current gig economy players and compose a fully decentralized ride
sharing, freelancing, temporary work, mechanical turk platform, or any other
shared economy model where each network participant gets their fair share of the
profits.

## Trustless Gaming

Resolve the transparency and verification problems in games with turn mechanics
(i.e. Battleship), and in those where private data holds significant importance
(i.e. poker).

## Decentralized Edge Compute

Most of the general compute today happens on cloud service because that is where
most of the data lives. With Calimero, all the applications data is stored
locally, whereas Calimero enables edge compute on that data. Combined with the
use of decentralized AI and Edge Inference LLMs, there are numerous use cases
how Calimero can enhance user experience: Edge AI on users data for social spam
filtering, e-commerce shopping recommendations across channels, to name a few.
This would allow users to finally maximize the endless possibilities from their
data, on their own rules.

For example, when you used to purchase from a certain merchant, the data was
fully controlled by that merchant or the platform where the data was hosted,
which would yield to your recommendations being exclusively tied to that
merchant. But if the data would have lived on your device, your data
recommendations would have been across various market channels, and not
exclusively tied to that specific merchant.

## Decentralized Identity Verification

Create a private Calimero application network which provides transparent and
trusted identity verification for service providers. With Calimero, sensitive
procedures such as opening a bank account or applying for Visas would not
require service providers to host the data of their users at centralized
entities any more.

## Decentralized Intellectual Property Management

The traditional platforms for managing and enforcing intellectual property
rights are not fully transparent, resulting in creators not being able to
maximize the utility of their work. Developing a decentralized IP management
platform would result in a fairer compensation system for all creators.

---

## Key Features

### No Central Authority

The networks deployed on Calimero are fully decentralized and managed by the
network participants. You own your data!

### Client Side Verified

All actions inside the Self-Sovereign Apps are verified using identity off-chain
signatures on the client device to ensure validity.

### Strong Encryption

The peer interactions inside the Self-Sovereign Apps are encrypted and protected
from any unauthorized third parties.

### Local Data Vault

The data is stored on the user's device and all state transitions are applied
locally ensuring data ownership.

### Developer Friendly

Build privacy preserving applications in any language without the knowledge of
cryptography and networking.

### Cross Platform Support

Calimero is built using a WASM runtime allowing it to be run on different
platforms including servers, desktops, browsers and mobile.

### Sovereign Digital Identity

Unique digital identity for every application, guarded by your wallet of choice
or a on-device private key.

---

## Setup

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Setup

This guide will help you set up Calimero in your device.

1. If you want to build on Calimero, or just want to use Calimero apps,
   [**choose one of these recommended options**](./packaged).

2. If you want to contribute to Calimero framework, or do some of our paid
   [bounties](https://calimero.network/bounties) -
   [**build it from Source**](./build-from-source).

### Supported Platforms

Calimero currently supports the following operating systems and architectures:

- **Operating Systems**: macOS, Linux
- **Architectures**: x86_64, arm64 (Apple Silicon)

:::note

If your platform is not supported, please
[create an issue on GitHub](https://github.com/calimero-network/core/issues).
:::

---

## Packaged installation

import MerodInstallation from '../shared/install-merod.mdx';

### Installation {#installation}

### Next Steps

Initialize and run node

If this is your first time initializing the node, the process may take a little
bit more time until all dependencies are downloaded. It will take around 7
minutes but can vary depending on your internet connection.

#### 1. Initialize node

```bash title="Terminal"
merod --node-name node1 init --server-port 2428 --swarm-port 2528
```

Node configuration file contains protocol defined metada and is located at
`~/.calimero/your_node_name/config.toml`.

#### 2. Run node

```bash title="Terminal"
merod --node-name node1 run
```

Wait for a few moments and node logs should appear.

---

## Build From Source

import InitNode from '../shared/node-init-source.mdx';
import RunNode from '../shared/node-run-source.mdx';

## Setup For Contributors

If you want to contribute to the Calimero framework or customize its
functionality, you can build it from source.

### Prerequisites

- Ensure Rust is installed. If not, follow the instructions on the
  [Rust website](https://www.rust-lang.org/tools/install).

### Troubleshooting

- If Rust dependencies fail, ensure your Rust installation is up-to-date:

  ```bash
  rustup update
  ```

- Verify that you have all required permissions to run the node.

For further support, open an issue on
[GitHub](https://github.com/calimero-network/core/issues).

### Setup steps

Setup consists of few steps and is around 9 minutes long. (mostly waiting for
project dependencies to download)

1. Clone repository from GitHub (1min)
2. Position in the root of the project (

```bash title="Clone using HTTPS"
git clone https://github.com/calimero-network/core.git
```

```bash title="Clone using SSH"
git clone git@github.com:calimero-network/core.git
```

### 2. Position in the root of the project

```bash title="Terminal"
cd core
```

### 3. Initialize and run node

You can do it in two ways.

- Using CLI
- Using Docker compose

If this is your first time initializing the node, the process may take a little
bit more time until all dependencies are downloaded. It will take around 7
minutes but can vary depending on your internet connection.

#### 1. Initialize node

#### 2. Run node

#### 1. First build the image

```bash title="Terminal"
docker buildx build -t 'merod' .
```

#### 2. Then setup and run the nodes defined in `docker-compose.yml` file

```bash title="Terminal"
docker compose up
```

#### 3. Connect to the available node by listing running containers

```bash title="Terminal"
docker ps
```

and then attach to the selected container

```bash title="Node Terminal"
docker attach core-app_node_run-1
```

Wait for a few moments and node logs should appear.

---

## Run as a systemd service

# Run as a systemd service

When you want your Calimero node to run continuously on a server or system, you
can set it up as a systemd service. This ensures automatic startup, restart on
failure, and proper logging.

:::note

This guide assumes you're using the packaged Calimero installation. For systemd
services, packaged binaries are recommended over building from source.

:::

## Create systemd service file

Create a new systemd service file:

```bash title="Terminal"
sudo nano /etc/systemd/system/calimero-node.service
```

Add the following content (adjust paths and node name as needed):

```ini title="/etc/systemd/system/calimero-node.service"
[Unit]
Description=Calimero Node Service
After=network.target
Wants=network.target

[Service]
Type=simple
User=calimero
Group=calimero
WorkingDirectory=/home/calimero
ExecStart=/usr/local/bin/merod --node-name node1 run
Restart=always
RestartSec=10
StandardOutput=journal
StandardError=journal
SyslogIdentifier=calimero-node

# Security settings
NoNewPrivileges=true
PrivateTmp=true
ProtectSystem=strict
ProtectHome=true
ReadWritePaths=/home/calimero/.calimero

# Resource limits
LimitNOFILE=65536
LimitNPROC=4096

[Install]
WantedBy=multi-user.target
```

:::tip

The default path `/usr/local/bin/merod` assumes a standard packaged
installation. If you installed Calimero to a different location, adjust the
`ExecStart` path accordingly.

:::

## Create dedicated user (recommended)

For security, create a dedicated user to run the Calimero service:

```bash title="Terminal"
sudo useradd -r -s /bin/false -d /home/calimero calimero
sudo mkdir -p /home/calimero/.calimero
sudo chown -R calimero:calimero /home/calimero/.calimero
```

## Set up the service

1. **Reload systemd configuration:**

```bash title="Terminal"
sudo systemctl daemon-reload
```

2. **Enable the service to start on boot:**

```bash title="Terminal"
sudo systemctl enable calimero-node.service
```

3. **Start the service:**

```bash title="Terminal"
sudo systemctl start calimero-node.service
```

4. **Check service status:**

```bash title="Terminal"
sudo systemctl status calimero-node.service
```

## Service management commands

```bash title="Terminal"
# Stop the service
sudo systemctl stop calimero-node.service

# Restart the service
sudo systemctl restart calimero-node.service

# View logs
sudo journalctl -u calimero-node.service -f

# View recent logs
sudo journalctl -u calimero-node.service --since "1 hour ago"
```

## Configuration considerations

- **Ports**: Ensure the ports specified in your node configuration (default:
  2428 for server, 2528 for swarm) are open in your firewall
- **Storage**: The service will store data in `/home/calimero/.calimero/` by
  default
- **Logs**: All logs are captured by systemd journald and can be viewed with
  `journalctl`
- **Updates**: When updating Calimero, restart the service with
  `sudo systemctl restart calimero-node.service`

## Troubleshooting

If the service fails to start, check:

1. **Service status:**

```bash title="Terminal"
sudo systemctl status calimero-node.service
```

2. **Detailed logs:**

```bash title="Terminal"
sudo journalctl -u calimero-node.service -n 50
```

3. **Common issues:**
   - Permission errors: Ensure the `calimero` user owns the `.calimero`
     directory
   - Port conflicts: Check if ports are already in use with
     `netstat -tulpn | grep :2428`
   - Configuration errors: Verify your `config.toml` file is valid
   - Binary path: Ensure the path in `ExecStart` points to your `merod` binary
     (usually `/usr/local/bin/merod` for packaged installations)

:::tip

For server environments, consider using a reverse proxy (like nginx) in front of
your Calimero node and implementing proper SSL/TLS termination.

:::

:::note

The systemd service configuration above is optimized for security and
reliability. Adjust the paths, user, and resource limits according to your
specific environment and requirements.

:::

---

## Terminology

As projects grow, it's important to have a shared vocabulary to help communicate
effectively. This page provides a list of terms used in the documentation and
throughout the codebase.

- **Node** is any individual device or computer that participates in the
  network. To avoid confusion with network layer used in the protocol, instead
  of network we are using term **Context**.
- **Peer** is a specific instance of a node within a P2P network that interacts
  with other peers. Peer represents user.
- **Peer Id** is a unique identifier assigned to each peer in the network. It is
  used to distinguish between different peers and ensure that messages are
  delivered to the correct recipient.
- **Context** is the core of the Calimero ecosystem. It is an application
  specific network designed to enable direct communication between users,
  eliminating the need for intermediaries
- **Application** is a software program designed to perform specific tasks or
  solve particular problems. To ensure compatibility and functionality, it
  should be developed according to the protocol SDK instructions provided. Once
  developed, the application should be published in a format that others can use
  during runtime, specifically in WebAssembly (WASM) format. Developer can also
  build frontend for an application, deployed separately, allowing users to
  interact with an app directly. This user interface facilitates interaction
  with the underlying software, making the application accessible and
  user-friendly.
- **Root key** is the public part of a wallet cryptographic key pair used to
  verify the signature of sensitive actions. This public key is used to ensure
  that any data or actions signed with the corresponding private key can be
  trusted. Essentially, the root key serves as a trust anchor, enabling users to
  validate the authenticity and integrity of operations or communications
  associated with the node. It does not grant direct control over the node but
  ensures that actions authenticated with the private part of the root key are
  legitimate.
- **Client key** is a cryptographic key tailored for each user session, acting
  as a session key or token. Each client key must be signed with the root key to
  be valid which is done automatically during login. This ensures that only
  sessions authenticated by the trusted root key can interact with the node.
- **Specialized node** is third-party node that augment a context's capacity and
  reliability. It participates in a context but have additional capabilities,
  providing various services while maintaining the decentralized nature of the
  network.

---

## Identity

## Calimero Decentralized Identity

Calimero’s decentralized identity framework is designed to provide secure,
anonymous, and decentralized control across the network. It leverages multiple
types of cryptographic keys to manage identities and ensure the integrity of
operations within the network.

### Network identity

Network identity is defined within the configuration file on each node. This
identity is derived from [network keys](#network-keys), which generate a unique
`Peer ID` for each node, allowing peers to identify themselves to other peers in
the network.

#### Network Keys

Network keys are used to authenticate nodes within the network, with each node
having a unique private-public key pair that it uses to verify its identity to
other nodes. During connection setup, nodes exchange public keys to ensure they
are communicating with the intended parties. More in
[Network](../architecture/node/network#identify)

### Context identity

Context identity allows users to identify themselves within a specific context.
Users can have arbitrary number of identities within a specific context which
remains encapsulated within the context. These identities are linked to
[runtime keys](#runtime-keys), with each context identity connected to one
runtime key.

### Decentralized Identity (DID) document

All context-specific identities and node keys are managed through a
Decentralized Identity (DID) document stored on the node. This document
includes:

- [Root Keys](#root-keys)
- [Client Keys](#client-keys)
- [Runtime Keys](#runtime-keys)
- [Encryption Keys](#encryption-keys)

Calimero's key management utilizes multiple keys for various purposes, ensuring
secure, anonymous, and decentralized control across the network. This structure
underpins secure and efficient operations within the Calimero Network,
facilitating both node and application functionalities.

#### Root keys

Root keys provide full access for node operations, including managing root keys,
listing identifiers, and generating new client keys. Web3 wallets can be used as
fundamental for root keys, simplifying the setup process.

#### Client keys

Client keys are generated on login and used by the frontend. Stored in browser
local storage, these keys initiate applications and serves as permissioned
access to the node.

**Client Key Usage**:

1. **Key Creation**: Users generate a new keypair in their browser.
2. **Verification**:
   - A Verifiable Presentation Request is sent to the node, which responds with
     a challenge.
   - The challenge and public key are signed using the root key.
   - Upon node verification of the request and signature, the new key is cleared
     for JSONRPC API communication from the browser to the node.

Calimero's TypeScript SDK supports developers in building browser and CLI
applications by simplifying interaction with the network.

#### Runtime keys

Runtime keys are used for signing transactions within a context, with the
appropriate key selected based on the context identity.

#### Encryption keys

Keys used for encrypting and decrypting messages between peers in the context.
Each context has its own encryption key. More in [Encryption](./encryption)

---

## Contexts

Contexts are the core of the Calimero ecosystem. These are application specific
networks designed to enable direct communication between users, eliminating the
need for intermediaries. Here's a closer look at how they operate:

#### **How Contexts Work:**

1. **Initialization**: A user selects a WebAssembly (WASM) module from a
   repository, which contains the logic and rules for the application. With
   this, they initiate a new Application Network, creating a unique identity for
   this specific network and setting the initial parameters and update
   strategies.

2. **Joining the Network**:

   - **Inviting Peers**: The initial user can invite others directly or set up
     Access Control Lists (ACLs) to govern how new members can join the network.
   - **New Member Process**: When a new user joins, they generate a unique
     identity for the network, download the relevant WASM module, and
     synchronize with the existing data on the network. This process ensures
     they're up to speed and ready to engage fully with the network's
     activities.

3. **Data Interaction**: Within the network, users can query and modify data
   according to the application's rules. Each Application Network autonomously
   manages data interactions, ensuring consistency and integrity.

4. **Security and Privacy**: All communications within an Application Network
   are secured with end-to-end encryption, utilizing the Double Ratchet
   Algorithm. This ensures that data exchanged between peers remains private and
   secure.

5. **Offline Capability and Consistency**: Calimero's design is 'offline-first,'
   accommodating the reality that peers may not always be online. When a peer
   goes offline and later returns, they synchronize with the network to update
   and reconcile any changes, maintaining eventual consistency across the
   network's state.

6. **Governance and Updates**: Application Networks can be governed by the users
   themselves, with decisions made through a consensus mechanism. Updates to the
   network, including changes to the WASM module or network parameters, can be
   proposed and voted on by the network's members.

7. **Extending network capabilities**: In addition to the core components of
   Application Networks, Calimero introduces Specialized Nodes to further
   enhance network capabilities. These nodes are designed to perform specific
   functions that go beyond the standard operations of client nodes, such as
   heavy data processing, advanced encryption tasks, or providing additional
   storage solutions. They play a crucial role in scaling the network's
   functionality and performance, ensuring that even as demand grows, the
   network remains efficient and responsive. Specialized Nodes can be deployed
   by any participant in the network, including Calimero, third-party
   developers, or users themselves, offering a flexible and decentralized
   approach to augmenting the network's capabilities. By leveraging these nodes,
   Application Networks can meet the diverse needs of different applications,
   ensuring that each network can be customized and optimized for its unique
   requirements, all while maintaining the overarching principles of privacy,
   security, and decentralization inherent to Calimero.

---

## Applications

Applications in Calimero define the core logic governing how peers interact
within a decentralized network. Developers can programmatically augment the
protocol to create customized functionalities, supporting a wide range of
applications tailored to various use cases, from direct messaging and
communication channels to interactive games and collaborative editing.

### Examples of Applications

1. **Communication Platforms**

   - **Direct Messages and Channels**: Support for private, encrypted messaging
     between users and group communications in shared, secure spaces. This setup
     can scale from one-on-one conversations to large group discussions, similar
     to Slack channels or Discord communities.
   - **Community Platforms**: Decentralized alternatives to platforms like
     Reddit or Hacker News, enabling independent contexts for different
     purposes, fostering discussions, and sharing content securely.

2. **Interactive Games**

   - **Privacy-Focused Games**: These games require the privacy of each player's
     moves until both have played, ensuring fair play and maintaining the
     confidentiality of strategies. Examples include:

     - **Rock-Paper-Scissors**: Players' choices are revealed simultaneously
       after both have made their moves.
     - **Battleship**: The positions of ships are kept secret until revealed
       through gameplay.

   - **Non-Privacy Games**: These games do not require concealment of moves and
     allow all actions to be visible to both players. Examples include:
     - **Chess**: A strategy game where all moves are visible to both players,
       with game logic running locally.
     - **Checkers**: Another strategy game where all moves are open and visible
       to both players.

3. **Collaborative Work**
   - **Document Collaboration**: Real-time collaboration on documents, akin to
     Google Docs, but decentralized and secure.
   - **Creative Projects**: Shared canvases or environments for drawing,
     designing, or working on various creative projects, where all contributions
     are securely encrypted.

### Benefits of Decentralized Applications

- **Resilience**: Distributed application logic ensures the system functions
  smoothly even if some devices go offline.
- **Autonomy**: Users control their data and activities without relying on a
  central authority.
- **Scalability**: The system scales effectively as more users join due to
  optimistic execution, with state being conflict-free and eventually
  reconciled.
- **Privacy**: Keeping data local and encrypted prevents exposure to third
  parties, crucial for sensitive information.

### Security and Data Management

All non-state-transitional data, such as attached files in DMs, collaborative
document assets, and game resources, inherit the same level of security as
state-transitional transactions. This ensures that all forms of data within the
Calimero network are encrypted and secure.

Calimero also functions as a decentralized filesystem for these
non-state-transitional, encrypted blobs of data. Similar to BitTorrent or IPFS,
nodes can lazily share the data without needing any centralized storage options.
This decentralized approach allows for efficient and secure data distribution
across the network.

### Building Applications

Developers can leverage Calimero's framework to programmatically build and
augment a wide range of applications using provided tools and documentation.
This includes setting up the development environment and deploying applications
within the network.

1. **Development Tools** Calimero offers the Rust SDK and intuitive APIs,
   enabling developers to create applications that integrate seamlessly with the
   network.

2. **Documentation and Support** Comprehensive documentation and community
   support assist developers in every step of the application development
   process, ensuring that they can build and deploy high-quality, secure
   applications efficiently.

---

## Blockchains Integration

import InitNode from '../shared/node-init-binary.mdx';

# Blockchain Integrations

Calimero offers integration with multiple blockchain protocols, allowing users
to interact with the blockchain and perform read and write operations.

## Current Blockchain Integrations

Calimero currently supports the following blockchain protocols:

- NEAR
- Starknet
- Internet Computer (ICP)
- Stellar
- Ethereum

```mermaid
graph TD
A[Calimero] --> B[Integrations]
B --> C[NEAR]
B --> D[Starknet]
B --> E[ICP]
B --> F[Stellar]
B --> G[Ethereum]
```

## Operations

- Read
- Read the data from the Calimero contracts.
- Write
- Write data to any contract on the same blockchain protocol through
  cross-contract calls in the Proxy Contract.

```mermaid
graph TD
A[Calimero]
B[Context Contract]
C[Proxy Contract]
D[Transfers]
E[Cross-Contract Calls]

A  B
A  C
C --> D
C --> E
```

## Functionalities

- Cross-contract calls
- Transfers
- Storage of arbitrary data
- Configuration of the internal configuration variables
- Proposal creation and execution

```mermaid
graph TD
A[Proxy Contract] -->|Cross-contract Calls| B[Other Contracts]
A -->|Transfers| C[Token Transfers]
A -->|Data Storage| D[Key-Value Storage]
A -->|Configuration| E[Internal Variables]
E -->|Change Votes Required| F[Vote Configuration]
E -->|Change Proposal Limits| G[Proposal Limits]
```

## Functionality Details

- **Cross-contract calls**: Proxy contract allows making cross-contract calls to
  other contracts on the same blockchain protocol. Users need to specify the
  contract address, the method to call, and the arguments for that method.
- **Transfers**: Proxy contract allows transferring tokens to the specified
  address. Users need to specify the recipient address and the amount of tokens
  to transfer.
- **Storage of arbitrary data**: Proxy contract allows storing arbitrary data in
  the context storage. Users need to specify the key and the value for the data
  to be stored.
- **Configuration of the internal configuration variables**: Configure the
  internal configuration variables of the Calimero contracts:
- **Vote configuration**: Number of votes required for a proposals to be
  approved (u32)
- **Proposal limits**: Maximum number of proposals that one user can have at the
  same time(u32)
- **Proposal creation and execution**: Proposals are created by users and
  contain one or multiple actions that are voted on by the users of the context.
  If a proposal is approved, it is automatically executed by the Calimero Proxy
  Contract.

## Calimero Contracts

Calimero integrates two types of contracts for each blockchain protocol:

- Context Contract
- Proxy Contract

```mermaid
graph TD
A[User] -->|Creates Context| B[Context Contract]
B -->|Creates| C[Context]
B -->|Adds Admin| D[User as Admin]
B -->|Deploys| E[Proxy Contract]
E -->|Handles| F[Proposals, Votes, Execution]
F -->|Executes Actions| G[Blockchain Operations]
```

### Context Contract

The Context Contract is responsible for creating contexts, adding and removing
members, editing their privileges, and associating specific applications with a
context.

### Proxy Contract

Each context has its own Proxy Contract instance which is deployed during the
context creation.

```mermaid
graph TD
A[User] -->|Creates Proposal| B[Proxy Contract]
B -->|Stores Proposal| C[Proposal Storage]
C -->|Voting by Members| D{Required Votes Met?}
D -->|Yes| E[Execute Proposal]
D -->|No| F[Store Vote Count]
```

Tutorial on how to use proxy contract functionalities is available in
[tutorials section](../../tutorials/proxy-contract-interaction)

### Deployment of Contracts

#### Context Contract

Context Contract is predeployed on each blockchain by the Calimero team.

#### Proxy Contract

Proxy Contract is deployed during the context creation.

```mermaid
graph TD
A[Calimero Team] -->|Pre-deploys| B[Context Contract]
B -->|During Context Creation| C[Proxy Contract]
C -->|Unique Instance| D[Context-specific Proxy]
```

:::info

Proxy Contract is deployed on the same blockchain as the Context Contract.

:::

:::warning

Users are responsible for funding the Proxy Contract.

:::

### Example Application

We have an example application that connects to Calimero Proxy Contract and
allows creating proposals, voting on them, and executing the approved proposals.

```mermaid
graph TD
A[Application] -->|Connects to| B[Calimero Proxy Contract]
B -->|Handles| C[Proposals]
C -->|Create| D[New Proposals]
C -->|Approve| E[Proposal Voting]
C -->|Delete| J[Delete Proposal]
E -->|Check Votes| F{Required Votes Met?}
F -->|Yes| G[Execute Proposal]
G -->|Perform Actions| H[Blockchain Operations]
F -->|No| I[Store Vote Count]
```

Application showcases all the actions that can be done on the Proxy Contract.

To create context on specific blockchain user check out our
[Create Context](../06-tutorials/02-create-context.mdx) guide.

Full source code is available in our GitHub
[repository](https://github.com/calimero-network/demo-blockchain-integrations).

---

## Encryption

Encryption in Calimero ensures data security in transit over the network,
maintaining confidentiality and integrity.

### Key Principles

1. **Forward Secrecy**: Ensuring past messages remain secure even if a key is
   compromised in the future.
2. **Post-Compromise Security**: Ensuring future messages remain secure even
   after any previous message has been compromised.
3. **Zero Trust in Third Parties**: No reliance on intermediaries for security.
4. **Verifiable End-to-End Encryption**: Confirming that only the intended
   recipients can read the messages.
5. **Asynchronous Communication**: Ability to start communications without
   recipients being online.
6. **Multi-Device Support**: Ensuring seamless use across multiple devices.
7. **Deniability**: Providing plausible deniability for message authorship to
   non-context members.
8. **Non-Interactive Group Management**: Adding and removing context members
   without requiring interaction.

### Double Ratchet Algorithm

Each network message uses a distinct encryption key derived from the ratchet
state, providing forward secrecy by ensuring that the compromise of one key does
not affect the security of previous messages.

Each context can configure Diffie-Hellman reset parameters. For one-on-one peer
interactions, resets can occur instantaneously, while for larger groups, resets
can happen at non-deterministic intervals to balance security and performance.

### Tree-Based Diffie-Hellman Key Exchange

All contexts use a tree-based Diffie-Hellman key exchange. This method
efficiently manages shared secrets among multiple members, ensuring that keys
are updated and propagated correctly. The reset of keys occurs at the leaf nodes
of the tree, guaranteeing post-compromise security.

Adding a new member involves existing members using their prekeys to complete an
X3DH (Triple Diffie-Hellman) exchange, securely adding the new member without
requiring direct interaction. Removing a member involves invalidating their keys
and updating the shared secrets among remaining members, ensuring efficient and
secure updates.

By leveraging advanced encryption techniques such as the Double Ratchet
Algorithm and tree-based Diffie-Hellman key exchange, Calimero ensures that all
data in transit is protected, maintaining the confidentiality and integrity of
network messages.

---

## Specialized Nodes

Specialized nodes in the Calimero Network are third-party nodes that augment a
context's capacity and reliability. They participate in a context but have
additional capabilities, providing various services while maintaining the
decentralized nature of the network.

### Key Concepts

- **Incentivization**: These nodes can be incentivized through contracts on
  blockchains that pay them for their services, ensuring they remain motivated
  to perform their roles effectively.
- **Permissions and Roles**: Specialized nodes can have different levels of
  permissions, ranging from being subscribed to encrypted network events to
  fully participating as part of the context.

### Types of Specialized Nodes

1. **Storage Nodes**:

   - **Encrypted Transaction Storage**: These nodes store encrypted transactions
     without the ability to read them. They guarantee 100% uptime, ensuring that
     all transactions are available even when peers are offline. When peers come
     back online, the node provides missed transactions and new transactions for
     replication.
   - **Blob Storage**: These nodes also store encrypted blobs of
     non-state-transitional data, ensuring that all necessary data is always
     available without holding decryption keys.

2. **Delegated Execution Nodes**:

   - **Context Maintenance**: These nodes fully join a context and maintain the
     context state on their end. They can handle resource-intensive executions,
     delegating specific calls to optimize performance and resource utilization.

3. **Administrative Nodes**:
   - **Event Observation and Action**: These nodes observe real-world events and
     act on them within the context. For example, in a billionaire's club
     context, an administrative node could monitor members' accounts on a
     blockchain and evict them if their balance falls below a certain threshold.

### Reliability Through Decentralization

Specialized nodes ensure that the context remains operational and consistent,
even when primary peers are offline. They provide the necessary data and
transactions to keep the context up-to-date. The decentralized nature ensures
that the state is eventually consistent. Fragmentation does not cause issues as
the system reconciles itself when peers come back online, highlighting the
network's reliability without reliance on any single specialized node.

---

## Node



---

## State Reconciliation



---

## System Overview

Calimero Network offers a robust framework for developing and running
peer-to-peer (P2P) applications. Our framework allows users to participate in
the network or build applications for others to use.

## Participate

Users participate in the network with a client node. By encapsulating the
complexities of operating a client node, we aim to make it easy and intuitive
for everyone to engage in the decentralized world.

- Client node acts as a gateway that runs applications and connects with other
  peers
- Each application is loaded and isolated from other applications into a
  separate context. This ensures that each application runs independently while
  still allowing interactions through shared states or messages.
- Context consolidates all necessary components into a secure, isolated
  environment.

Some networks may require specialized functionalities, which are provided by a
dedicated compute market. Users can integrate these special functionalities from
a pool of available specialized nodes.

![Calimero Architecture](/learn/architecture.png)

## Build

To develop applications on the Calimero Network, we provide comprehensive SDKs:

- Protocol SDK to define how the application should behave and communicate with
  the node.
- Client SDK to connect to node and use data in user interface and authenticate
  using wallets UI.

Developer applications are shared through application registry where developers
upload their applications and share it with other users

Explore other sections to learn more about each component, and how they
contribute to a seamless decentralized experience.

---

## Client Node

### Runtime

Overview: The runtime environment of a client node in the Calimero Network is
crucial for the execution of decentralized applications (DApps), particularly
those compiled to WebAssembly (WASM).

Functionality:

- State Synchronization: Each node can download and synchronize the state with
  existing applications, ensuring that all nodes participating in a particular
  application network are consistent and up-to-date.
- Application Settings: Nodes can be configured with specific settings for each
  application, including which WASM modules to run, source URLs for fetching
  these modules, encryption protocols to be used, and more.
- Network Topology & Update Rules: Defines the structure of the network and how
  nodes communicate and update each other. Proper update rules are crucial for
  application security and integrity, particularly in a decentralized setting
  where trust is distributed.

#### Recommendations for Developers: Thorough testing of applications in a controlled environment is advised before deploying them in production to ensure stability and security. Additionally, developers are encouraged to implement locked update rules to prevent unauthorized modifications to the application's behavior.

### Storage

Overview: Storage on client nodes involves maintaining the state and data
required for the decentralized applications they support.

Functionality:

- Local Storage: Each node stores application data locally, contributing to the
  overall decentralized storage model of the network. This ensures that data is
  distributed across the network, enhancing privacy and resilience against
  central points of failure.

### Encryption:

Data stored on client nodes can be encrypted, providing an additional layer of
security and privacy for user data.

### Identity Management

Overview: Managing identities on the Calimero Network is fundamental for
ensuring secure and private interactions between nodes and applications.
Functionality:

### Authentication

Nodes implement mechanisms for authenticating users and applications, ensuring
that interactions are secure and that entities are who they claim to be.

### Key Management

The management of cryptographic keys is an integral part of identity management,
enabling secure communication and data encryption across the network.

### Application Marketplace

Current State: The marketplace for decentralized applications within the
Calimero Network is facilitated by a smart contract on the NEAR blockchain, with
application data and metadata hosted on IPFS. This setup serves as a temporary
solution while further community engagement and discussions are underway to
refine the marketplace's infrastructure and governance. The Calimero Network's
approach to client nodes emphasizes security, decentralization, and privacy,
with a strong recommendation for users to engage with applications that have
securely locked update mechanisms. These applications are more reliable for
critical use cases and are the only ones featured in the official marketplace,
ensuring a curated and trustworthy selection of DApps for users. This framework
demonstrates Calimero Network's commitment to building a secure and user-centric
decentralized ecosystem.

---

## Runtime

The runtime environment in the Calimero Network is essential for executing
decentralized applications (DApps). It acts as a bridge between the application
logic, the network, and storage layers, ensuring seamless operation and
integration. The runtime ensures secure, isolated, and efficient execution of
applications by managing resources effectively, supporting real-time event
handling, enabling scalability, and providing robust storage and transaction
management.

### Core Capabilities

- **Security and Isolation**: The runtime provides a secure execution
  environment for Calimero applications using WebAssembly (WASM). Each
  application is sandboxed in the WASM VM, ensuring proper isolation and
  preventing interference between applications. This setup also ensures that
  applications cannot access unauthorized resources, maintaining a secure
  environment.

- **Multi-Application Support**: The runtime allows multiple applications to run
  concurrently on the same node and supports multiple instances (contexts) of
  the same application, each with its own state. This capability enhances the
  flexibility and scalability of the network.

- **Scoped Storage**: The runtime manages storage by partitioning it and
  governing where each context stores its state. These implementation details
  are abstracted from the app developer, ensuring that storage management is
  handled seamlessly and securely.

- **Atomic Transactions**: The runtime guarantees atomic transactions, ensuring
  that if a transaction fails, it is completely rolled back with no state
  updates or side effects detected. This guarantees consistency and reliability
  in the application's state and any connected clients.

- **Log Collection and Relaying Events**: The runtime facilitates log collection
  and relays events emitted by the applications to connected clients, enabling
  real-time monitoring and interaction.

- **Resource Management**: The runtime defines resource limits for applications
  to ensure fair usage and prevent malicious behavior. This includes limiting
  CPU, memory, and network usage to prevent any single application from
  monopolizing system resources or compromising the host system.

- **Task Management and Performance**: The runtime keeps track of WASM instances
  up to a defined threshold, effortlessly queueing transactions to reuse live
  instances and shutting down stale ones to reclaim system resources. These
  optimizations ensure efficient resource utilization and improved performance.

---

## Server

The server is a core component for interacting with a Calimero node. Calimero
can be embedded with your client to make it a self-contained node, or it can run
as a remote node that multiple clients can connect to, allowing centralized
state management.

### Core Capabilities

- **JSON-RPC API**: Provides a standardized way for clients to query or mutate
  the state of their counterpart applications on the node, ensuring seamless
  integration and communication.

- **WebSocket Interface**: Allows clients to subscribe to events emitted from
  applications, enabling real-time reactions to activity triggered by other
  peers in the network.

- **Admin API**: Manages various aspects of the node, including:
  - **Context Administration**: Create, delete, invite others to contexts, and
    accept invitations.
  - **Storage Management**: Track usage, view raw state storage for each
    context, and view encrypted blobs.
  - **State Management**: Manually garbage collect state-transitional
    transactions.
  - **Network Management**: Manually connect to peers and manage blocklists.
  - **Application Management**: Manage installed applications, create contexts
    from applications, delete applications if no contexts are associated, and
    manually sideload applications.
  - **Peer Identity Management**: Rotate peer identities without affecting
    context identities.
  - **Node Metrics**: Track network bandwidth usage, both total and by context,
    to manage resource usage effectively.

---

## Storage

The storage component in the Calimero Network is essential for managing and
maintaining the data generated and utilized by decentralized applications
(DApps). It ensures data integrity, security, and efficient access, enabling
seamless operation of applications within the network.

### Core Capabilities

- **Generic Storage Interface**: Calimero provides a flexible storage interface
  that allows app developers to choose their preferred database. By default,
  Calimero uses RocksDB, but it can also support LevelDB, Sled, TigerBeetle,
  SQLite, or even cloud storage solutions like S3.

- **Context State Storage**: The context state is backed by a Patricia-Trie
  structure flattened into the key-value map of the datastore. This structure
  ensures efficient state management and retrieval.

- **Data Blobs**: The storage system handles non-state-transitional, encrypted
  blobs of data, similar to BitTorrent or IPFS. Nodes can lazily share these
  data blobs without needing centralized storage, ensuring efficient and secure
  data distribution across the network. By default, the blobstore is the local
  filesystem, but it can be configured to use any cloud storage option or
  content-addressed storage like IPFS.

- **Data Encryption**: All data stored within the network is encrypted at rest,
  ensuring that sensitive information remains protected. This includes both
  state-transitional data and non-state-transitional data like attached files in
  DMs or collaborative document assets.

- **Efficient Data Operations**: The storage component is optimized for quick
  data operations, ensuring that applications can access, retrieve, and update
  the data they need promptly. Caching mechanisms are employed to further
  improve data access speeds.

- **Garbage Collection**: The system includes mechanisms for garbage collection
  using reference counting for trie data, allowing for the cleanup of obsolete
  or redundant data. This helps in maintaining optimal storage performance and
  resource utilization.

- **Metrics and Monitoring**: The storage component provides detailed metrics on
  storage usage, including total usage and breakdowns by context. This allows
  for effective monitoring and management of storage resources.

---

## Network

## Overview

This document provides an overview of the networking component of Calimero
Network, which is implemented using the `libp2p` library. The network consists
of two types of peers: client nodes and boot nodes, each serving distinct roles
and utilizing specific protocols to facilitate peer-to-peer communication.
Client node is the component which hosts and runs client applications,
communicates and shares data between other client nodes. Boot node is the
component used for the initial discovery of the peers in the network.

## Node Types

### Client Node

- **Deployment:** Can run on any machine
- **Protocols Utilized:**

  - [dcutr](#dcutr-direct-connection-upgrade-through-relay)
  - [gossipsub](#gossipsub)
  - [identify](#identify)
  - [kad](#kademlia-kad)
  - [mdns](#mdns-multicast-dns)
  - [ping](#ping)
  - [rendezvous](#rendezvous)
  - [relay](#relay)

- **Behavior:**
  - **Configuration:** A client node can be configured to use zero boot nodes.
  - **External Address:**
    - **Direct Public External Address:** Nodes with a direct public external
      address do not require reservation at the relay server. These nodes
      publish their public external address to the Kademlia DHT, making them
      directly accessible to other peers.
    - **Relayed External Address:** Nodes that do not have a direct public
      external address, typically those behind a NAT or firewall, can obtain a
      relayed external address by requesting a reservation at a relay server.
      Once the reservation is accepted, the node publishes its new external
      address to the rendezvous server. This allows other nodes to discover
      relayed addresses of a peers in a certain rendezvous namespace. The relay
      server can be used for the coordination of the hole punching between two
      nodes. If the hole punching attempt fails, the relay server will bridge
      the traffic.
  - **Discovery Protocols:** `mDNS`, `rendezvous` and `Kademlia`
  - **Connection Management:** A peer, identified via PeerId, can be discovered
    either via mDNS, rendezvous or Kademlia. mDNS discovery provides local
    network addresses, rendezvous discovery provides relayed addresses, and
    Kademlia discovery provides direct public external addresses. The node
    maintains information about its connections to peers, including the
    discovery source. For a discovered external address, either relayed or
    direct public, the node will only attempt to dial the peer if the same peer
    is not already connected via a discovered local address. This ensures that
    local connections have higher priority and that there are no unnecessary
    hole punching attempts.
  - **Message Relaying:** The node participates in the `gossipsub` protocol,
    relaying messages to all connected peers that support it. This enables
    efficient and scalable message dissemination across the network.

### Boot Node

- **Deployment:** Must run on a publicly available machine with a static IP
  address.
- **Protocols Utilized:**

  - [identify](#identify)
  - [kad](#kademlia-kad)
  - [ping](#ping)
  - [rendezvous](#rendezvous)
  - [relay](#relay)

- **Behavior:**
  - **Characteristics:** Boot nodes are publicly available, long-running nodes
    that provide stable entry points to the network.
  - **Functions:**
    - **Bootstrap Node:** Acts as a well-known peer for the Kademlia protocol,
      facilitating peer discovery and network join operations.
    - **Circuit Relay Server:** Serves as a generic relay that provides the
      medium that facilitates the hole punching, enabling peers to establish
      direct connections even when they are behind NAT or firewalls. The relay
      server is used for the coordination of the hole punching between two
      nodes, and briding traffic if the hole punching attempt fails.
    - **Rendezvous Server:** Facilitates peer discovery by allowing nodes to
      register their presence and query for other peers within a shared
      rendezvous namespace. This enables dynamic and efficient peer-to-peer
      connections without relying on a static list of peers.

## P2P protocols and techniques

### Protocol Descriptions

#### DCUtR (Direct Connection Upgrade through Relay)

- DCUtR is used to upgrade connections through relay nodes, allowing peers to
  establish direct connections even if they are behind NATs or firewalls. Peers
  initially connect via a relay node, then use the DCUtR protocol to attempt a
  direct connection, which reduces latency and bandwidth usage.
- **Reference:**
  [libp2p DCUtR Documentation](https://github.com/libp2p/specs/blob/master/relay/DCUtR.md)

#### Gossipsub

- Gossipsub is a scalable and efficient pub-sub protocol for message
  dissemination. It combines the best aspects of gossip protocols and
  topic-based pub-sub systems. It minimizes bandwidth usage by only gossiping
  metadata and ensuring that messages are only sent once per peer.
- **Reference:**
  [libp2p Gossipsub Documentation](https://github.com/libp2p/specs/tree/master/pubsub/gossipsub)

#### Identify

- The Identify protocol allows peers to identify themselves and share their
  capabilities with other peers. Peers exchange identification information such
  as supported protocols, listen addresses, and public keys. This helps peers
  make informed decisions about connecting and interacting.
- **Reference:**
  [libp2p Identify Documentation](https://github.com/libp2p/specs/blob/master/identify/README.md)

#### Kademlia (Kad)

- Kademlia is a distributed hash table (DHT) protocol used for peer discovery
  and data routing. It uses an XOR metric to ensure efficient and scalable peer
  lookup. Each node maintains a routing table with information about other
  nodes, facilitating quick lookups and robust network operation.
- **Reference:**
  [libp2p Kademlia DHT Documentation](https://github.com/libp2p/specs/tree/master/kad-dht)

#### mDNS (Multicast DNS)

- mDNS enables local network peer discovery without the need for a central
  server. It uses multicast DNS to allow peers to find each other on the same
  local network by broadcasting their presence and listening for broadcasts from
  other peers.
- **Reference:**
  [libp2p mDNS Documentation](https://github.com/libp2p/specs/tree/master/discovery/mdns)

#### Ping

- The Ping protocol measures the round-trip time (latency) between peers. It
  regularly pings connected peers and measures the time it takes for a response.
  This helps in maintaining healthy connections and understanding network
  latency.
- **Reference:**
  [libp2p Ping Documentation](https://github.com/libp2p/go-libp2p-ping)

#### Relay

- The Relay protocol supports relay-based communication, allowing peers to
  communicate through intermediary nodes when direct connections are not
  possible. Nodes can use relay nodes to forward their traffic, which is
  especially useful for nodes behind NATs or firewalls. The protocol includes
  mechanisms for reserving relay slots and managing relay connections.
- **Reference:**
  [libp2p Relay Documentation](https://github.com/libp2p/specs/tree/master/relay)

#### Rendezvous

- The Rendezvous protocol enables peers to discover each other by registering at
  and querying a shared rendezvous point. This is useful for dynamically finding
  peers without needing a central directory or pre-established list of peers.
  Peers register their presence at a rendezvous server and can also query the
  server to find other peers.
- **Reference:**
  [libp2p Rendezvous Documentation](https://github.com/libp2p/specs/tree/master/rendezvous)

### NAT Traversal Techniques

One of the common techniques used for NAT traversal in P2P networks is **Hole
Punching**. This technique allows two peers, each behind a NAT, to establish a
direct connection with each other. Here's a brief explanation:

- **Hole Punching:** This technique involves three steps:
  - **Step 1 - Connection to Public Server:** Both peers initially connect to a
    public server (in this case, the relay server). This creates a NAT mapping
    (a "hole") for outgoing packets to the server.
  - **Step 2 - Exchange of Address Information:** The server shares the public
    address information of each peer with the other. This information includes
    the IP address and port number that the NAT has assigned for the connection
    to the server.
  - **Step 3 - Direct Connection:** Each peer sends a packet to the other peer's
    public address. Since a mapping for this address already exists in the NAT
    (from the connection to the server), the NAT forwards the packet to the
    appropriate internal address, and a direct connection is established.

This technique is particularly useful in P2P networks, as it allows peers to
communicate directly, reducing the load on relay servers and improving network
efficiency. However, it's worth noting that hole punching may not work with all
types of NATs, and success can depend on the specific NAT implementation and
configuration.

- **Reference:**
  [Hole punching in libp2p](https://blog.ipfs.tech/2022-01-20-libp2p-hole-punching/)
- **Reference:**
  [How NAT traversal works](https://tailscale.com/blog/how-nat-traversal-works)

---

## Developer Tools

We provide different tools for building decentralized applications.

### CLI Tools for interacting with the node and its functionalities

You can use CLI to interact with the node using the terminal.
[Merod](./CLI/merod) is a CLI tool for managing nodes. [Meroctl](./CLI/meroctl)
is tool for performing various operations with the node such as context
creationa or app installation.

### SDKs for building the application

Two primary SDKs are available:

[Protocol SDK](./SDK/protocol-sdk/protocol-sdk): Used for building WebAssembly
(WASM) application logic in Rust. Provide macros for identifying different
application components such as state, logic and events.

[Client SDK](./SDK/client-sdk/client-ts-sdk): Enables frontend development in
TypeScript, supporting wallet authentication and context data handling via
JSON-RPC and WebSockets.

### Apps for node administration throught the UI

- [Admin dashboard](./apps/admin-dashboard) is web interface for node admin api.
- [Desktop application](./apps/desktop-app) is a desktop interface for the node
  where node is available as a service on the local machine.

### Examples

We have few repositories that demonstrate how SDK can be used. Check our
[GitHub](https://github.com/calimero-network)

---

## Merod

import MerodInstallation from '../../shared/install-merod.mdx';

Merod is a command-line tool that allows you to initialize, configure and run
Calimero nodes.

  Installation
  
    
  

## Usage

```bash title="Terminal"
merod [OPTIONS] --node-name  
```

### Commands:

- `config` Configure the node
- `init` Initialize node configuration
- `run` Run a node
- `relay` Relay incoming requests to specific location
- `help` Print this message or the help of the given subcommand(s)

:::tip

Run help to get more information about the available options and commands.

```bash title="Terminal"
merod --help
```

:::

### Options:

- `--home ` Directory for config and data
- `-n`, `--node-name ` Name of node
- `-h`, `--help` Print help
- `-V`, `--version` Print version

:::tip

Default location of the config and data directory is `~/.calimero`. You can
change the location by using the `--home` option.

:::

### Examples:

| **Command**                                                                      | **Description**                                                                      |
| -------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------ |
| `merod --node-name node1 init`                                                   | Initialize a node with default settings. (server-port = 2428 and swarm-port = 2528`) |
| `merod --node-name node1 init --server-port 2429 --swarm-port 2529`              | Initialize a node with custom ports.                                                 |
| `mkdir data && merod --home data/ --node-name node1 init`                        | Initialize a node with a custom home directory.                                      |
| `merod --node-name node1 config --server-host 143.34.182.202 --server-port 3000` | Configure an existing node with a specific server host and port.                     |
| `merod --node-name node1 run`                                                    | Run a node.                                                                          |
| `merod --node-name node2 relay --listen 127.0.0.1:3333`                          | Relay incoming requests to a specific location.                                      |

```

```

---

## Meroctl

import MeroctlInstallation from '../../shared/install-meroctl.mdx';

Meroctl is a command-line tool that enables you to interact with your Calimero
node directly from the shell.

  Installation
  
    
  

## Usage

```bash title="Terminal"
meroctl [OPTIONS] --node  
```

### Commands:

- `app` Command for managing applications
- `context` Command for managing contexts
- `identity` Command for creating an empty identity
- `proxy` Command for managing proxy contract
- `call` Executing read and write RPC calls
- `peers` Show a number of connected peers
- `bootstrap` Setup two nodes inside the same context
- `help` Print this message or the help of the given subcommand(s)

:::tip

Run help to get more information about the available options and commands.

```bash title="Terminal"
meroctl --help
```

:::

### Options:

- `--home ` Directory for config and data
- `-n`, `--node-name ` Name of node
- `-h`, `--help` Print help
- `-output-format ` [default: plain-text] [possible values:
  json, plain-text]
- `-V`, `--version` Print version

:::tip

Default location of the config and data directory is `~/.calimero`. You can
change the location by using the `--home` option.

:::

:::note

All of the communication with your node through the meroctl CLI is protected by
your nodes private key.

:::

### Examples:

| **Command**                                                                  | **Description**                     |
| ---------------------------------------------------------------------------- | ----------------------------------- |
| `meroctl --node  app `                                        | Command for managing applications   |
| `meroctl --node  context `                                    | Command for managing contexts       |
| `meroctl --node  identity `                                   | Command for creating identities     |
| `meroctl --node  proxy `                                      | Command for managing proxy contract |
| `meroctl --node  call [OPTIONS] --as   ` | Executing read and write RPC calls  |

### Manage Applications

```bash title="Terminal"
meroctl --node  app 
```

Commands:

- `get` Fetch application details
- `install` Install an application
- `list` List installed applications

### Manage Contexts

```bash title="Terminal"
meroctl --node  context 
```

Commands:

- `alias` Create an alias for a context
- `list` List all contexts
- `create` Create a new context
- `join` Join an application context
- `invite` Create invitation to a context for a invitee
- `get` Fetch details about the context

  
    `get` subcommands- `info` Get context information -
    `client-keys` Get client keys - `storage` Get storage information
  

- `identity` Create or list a context identity or it's alias
- `delete` Delete a context
- `watch` Watch events from a context
- `update` Update app in context
- `peers` Show a number of connected peers

### Managing Context Identities and Aliases

The `context identity` command supports alias management to simplify working
with public keys across contexts:

```bash
meroctl --node  context identity 
```

Commands:

- `list` List identities in a context

  - Use `--owned` to get only owned identities

    ```bash
    meroctl --node  context identity list  --owned
    ```

- `alias` Manage identity aliases
  - `add   --context ` Create new alias for
    an identity
  - `remove  --context ` Remove an identity alias
  - `get  --context ` Look up an identity's hash by
    alias

### Context Management with Aliases

The `context` command includes alias management as a subcommand to simplify
working with context IDs:

```bash
meroctl --node  context 
```

The alias subcommand structure:

```bash
meroctl --node  context alias 
```

- `add  ` Create new alias for a context
- `remove ` Remove a context alias
- `get ` Look up a context by alias

Additional context commands support using aliases:

- `create --as  ...` Create context with an identity alias
- `get ` Get context info using alias
- `invite   --as ` Create
  invitation using aliases
- And more...

:::tip

See the Invitations and Joinings guide for detailed examples of using aliases to
streamline context management.

:::

### Manage Identities

```bash title="Terminal"
meroctl --node  identity 
```

Commands:

- `generate` Generate public/private key pair used for context identity

### Command for managing proxy contract

```bash title="Terminal"
 meroctl --node  proxy 
```

Commands:

- `get` Fetch details about the proxy contract

### Show a number of connected peers

```bash title="Terminal"
meroctl --node  peers
```

### Executing read and write RPC calls

```bash title="Terminal"
meroctl --node  call [OPTIONS] --as   
```

Arguments:

- `` ContextId of the context
- `` Method to fetch details

Options:

- `--args ` JSON arguments to pass to the method
- `--as ` Public key of the executor
- `--id ` Id of the RPC execute call [default: dontcare]

---

## Cargo Mero

import CargoMeroInstallation from '../../shared/install-cargo-mero.mdx';

# cargo-mero

A Cargo subcommand for building applications on the Calimero network.

  Installation
  
    
  

Make sure `~/.cargo/bin` is in your `PATH` so that `cargo mero` is available as
a subcommand.

## Commands

### new

Scaffold a new Calimero application.

```bash title="Terminal"
cargo mero new 
```

### build

Build your Calimero application to WASM.

```bash title="Terminal"
cargo mero build [OPTIONS]
```

#### Build Options

| Option                  | Description                                           |
| ----------------------- | ----------------------------------------------------- |
| `--locked`              | Assert that `Cargo.lock` will remain unchanged        |
| `--no-release`          | Build app in `dev` profile, without optimizations     |
| `-v`, `--verbose`       | Use verbose output                                    |
| `-q`, `--quiet`         | Do not print cargo log messages                       |
| `-F`, `--features`      | Space or comma separated list of features to activate |
| `--no-default-features` | No default features                                   |
| `-h`, `--help`          | Print help                                            |

#### Example: Build with options

```bash title="Terminal"
cargo mero build --verbose --features feature1,feature2 --no-release
```

### help

Prints the help message or the help of the given subcommand(s).

```bash title="Terminal"
cargo mero --help
```

---

## Protocol SDK

The Protocol SDK within the Calimero Network serves as a foundational tool for
developers, enabling them to design, develop, and deploy the specific protocols
that govern the operation of their decentralized applications (DApps). This SDK
is particularly crucial in a network like Calimero, where privacy, security, and
decentralized communication are paramount. Here's an overview of the Protocol
SDK, highlighting its features, functionalities, and its role in the development
lifecycle of DApps:

### Features and Functionalities

- **Protocol Definition**: Allows developers to define the rules and behaviors
  of their application networks, including communication protocols, data
  formats, and interaction patterns among nodes.
- **Code Generation**: Automates the generation of boilerplate code required to
  implement the defined protocols, significantly speeding up the development
  process and reducing the potential for errors.
- **Interoperability Support**: Facilitates the creation of protocols that can
  interact with various blockchains and external systems, ensuring that
  Calimero-based DApps can operate within the broader blockchain ecosystem.
- **Security Focus**: Provides tools and libraries to incorporate advanced
  security features into protocols, such as end-to-end encryption, secure key
  management, and privacy-preserving data sharing mechanisms.
- **Performance Optimization**: Includes optimization tools and best practices
  to ensure that the protocols are efficient in terms of resource usage,
  suitable for decentralized networks where performance can be a critical
  concern.

### Role in DApp Development

- **Protocol Development**: At the core of any DApp on the Calimero Network is a
  protocol that dictates how the application functions, how nodes within the
  application's network communicate, and how data is handled and stored. The
  Protocol SDK is the primary tool for developing these protocols.
- **Testing and Deployment**: The SDK provides an environment for thorough
  testing of the protocols in simulated conditions before they are deployed on
  the live network. This ensures that any issues can be identified and resolved
  in a controlled setting, minimizing risks.
- **Versioning and Updates**: Supports protocol versioning, enabling developers
  to iterate on their protocols and roll out updates in a structured manner.
  This is crucial for maintaining compatibility and ensuring the longevity and
  scalability of DApps.

### Integration with Other Calimero Components

- **Client Nodes**: Protocols developed with the Protocol SDK are deployed on
  client nodes, which act as the runtime environment for the DApps built on
  these protocols.
- **Client SDKs**: These SDKs interact with the protocols at a higher level,
  providing interfaces for end-users to interact with the DApps. The seamless
  integration between the Protocol SDK and Client SDKs ensures a smooth user
  experience.
- **Specialized Nodes**: Some protocols may require specialized computational
  resources or functionalities. The Protocol SDK allows for the integration of
  these services, enabling DApps to leverage the specialized nodes within the
  Calimero Network.

### Use Cases

- **Decentralized Messaging**: For a messaging app, the Protocol SDK could be
  used to define the encryption protocols, message delivery mechanisms, and peer
  discovery protocols.
- **Decentralized Finance (DeFi)**: In a DeFi application, the SDK could define
  the protocols for executing smart contracts, handling transactions, and
  interacting with external blockchains for asset transfers.

The Protocol SDK is a critical component of the Calimero Network, empowering
developers to build sophisticated, secure, and efficient decentralized
applications. By abstracting much of the complexity associated with protocol
development, the SDK enables developers to focus on the unique features and
functionalities of their DApps, fostering innovation and growth within the
Calimero ecosystem.

---

## Rust Protocol SDK

## Calimero SDK Macros for Rust

This guide provides a comprehensive reference of the essential macros provided
by the Calimero SDK for building Rust applications.

## Core Macros

### #[app::state]

Marks a struct as the application state. The state struct must implement
`BorshSerialize` and `BorshDeserialize`.

```rust
#[app::state]
#[derive(Default, BorshSerialize, BorshDeserialize)]
#[borsh(crate = "calimero_sdk::borsh")]
struct MyAppState {
    // Your state fields here
}
```

When emitting events, specify the event type:

```rust
#[app::state(emits = for MyEvent)]
struct MyAppState {
    // Your state fields here
}
```

### #[app::logic]

Marks an implementation block as containing the application logic.

```rust
#[app::logic]
impl MyAppState {
    // Your methods here
}
```

### #[app::init]

Marks a method as the initializer, which is called when the application is first
deployed.

```rust
#[app::logic]
impl MyAppState {
    #[app::init]
    pub fn init() -> Self {
        Self::default()
    }
}
```

### #[app::event]

Defines an event type that can be emitted by your application.

```rust
#[app::event]
pub enum MyEvent {
    ValueUpdated { key: &'a str, value: &'a str },
    ValueRemoved { key: &'a str },
}
```

## Event emission

Use the `app::emit!` macro to emit events from your application:

```rust
app::emit!(MyEvent::ValueUpdated {
    key: &key,
    value: &new_value
});
```

## Complete Example

Here's a minimal example showing how these macros work together:

```rust
use calimero_sdk::borsh::{BorshDeserialize, BorshSerialize};
use calimero_sdk::{app, env};
use calimero_storage::collections::UnorderedMap;

#[app::event]
pub enum StoreEvent {
    ValueSet { key: &'a str, value: &'a str },
}

#[app::state(emits = for StoreEvent)]
#[derive(Default, BorshSerialize, BorshDeserialize)]
#[borsh(crate = "calimero_sdk::borsh")]
struct Store {
    values: UnorderedMap,
}

#[app::logic]
impl Store {
    #[app::init]
    pub fn init() -> Self {
        Self {
            values: UnorderedMap::new(),
        }
    }

    pub fn set(&mut self, key: String, value: String) {
        self.values.insert(key, value).unwrap();
        app::emit!(StoreEvent::ValueSet {
            key: &key,
            value: &value
        });
    }
}
```

## Important Notes

  
    State changes are atomic - if a method fails, all changes are rolled back
  
  Events are only emitted if the transaction succeeds
  Read-only operations have no network overhead
  
    All public methods in the `#[app::logic]` block become available as
    application endpoints
  

For a detailed guide on building a complete application using these macros, see
our [Tutorial](../../../../tutorials/build-app) Guide on building a Key Value
Store.

---

## Rust SDK Deep Dive

# Rust SDK Deep Dive

This comprehensive guide covers advanced usage of the Calimero Rust SDK,
including collections, events, macros, and best practices for building
production applications.

## Table of Contents

- [Collections](#collections)
- [Events and Event Handling](#events-and-event-handling)
- [Advanced Macros](#advanced-macros)
- [State Management Patterns](#state-management-patterns)
- [Performance Optimization](#performance-optimization)
- [Testing and Debugging](#testing-and-debugging)
- [Common Patterns and Anti-patterns](#common-patterns-and-anti-patterns)

## Collections

Calimero provides a rich set of collections optimized for WebAssembly and
decentralized applications. These collections are designed to work efficiently
with the Calimero storage system.

### Core Collections

#### UnorderedMap

A hash map implementation optimized for Wasm:

```rust
use calimero_storage::collections::UnorderedMap;

#[app::state]
#[derive(Default, BorshSerialize, BorshDeserialize)]
#[borsh(crate = "calimero_sdk::borsh")]
struct MyApp {
    users: UnorderedMap,
    settings: UnorderedMap,
}

#[app::logic]
impl MyApp {
    pub fn add_user(&mut self, username: String, profile: UserProfile) -> Result {
        if self.users.contains_key(&username) {
            return Err("User already exists".to_string());
        }

        self.users.insert(username, profile);
        Ok(())
    }

    pub fn get_user(&self, username: &str) -> Option {
        self.users.get(username)
    }

    pub fn remove_user(&mut self, username: &str) -> Option {
        self.users.remove(username)
    }
}
```

#### UnorderedSet

A hash set for unique elements:

```rust
use calimero_storage::collections::UnorderedSet;

#[app::state]
#[derive(Default, BorshSerialize, BorshDeserialize)]
#[borsh(crate = "calimero_sdk::borsh")]
struct AccessControl {
    admins: UnorderedSet,
    moderators: UnorderedSet,
}

#[app::logic]
impl AccessControl {
    pub fn add_admin(&mut self, username: String) {
        self.admins.insert(username);
    }

    pub fn is_admin(&self, username: &str) -> bool {
        self.admins.contains(username)
    }

    pub fn remove_admin(&mut self, username: &str) -> bool {
        self.admins.remove(username)
    }
}
```

#### Vector

A dynamic array implementation:

```rust
use calimero_storage::collections::Vector;

#[app::state]
#[derive(Default, BorshSerialize, BorshDeserialize)]
#[borsh(crate = "calimero_sdk::borsh")]
struct TaskManager {
    tasks: Vector,
    completed_tasks: Vector,
}

#[app::logic]
impl TaskManager {
    pub fn add_task(&mut self, task: Task) {
        self.tasks.push(task);
    }

    pub fn complete_task(&mut self, index: u32) -> Result {
        if index >= self.tasks.len() {
            return Err("Invalid task index".to_string());
        }

        let task = self.tasks.remove(index as usize);
        self.completed_tasks.push(task);
        Ok(())
    }

    pub fn get_task(&self, index: u32) -> Option {
        self.tasks.get(index as usize)
    }
}
```

### Advanced Collection Patterns

#### Nested Collections

```rust
#[app::state]
#[derive(Default, BorshSerialize, BorshDeserialize)]
#[borsh(crate = "calimero_sdk::borsh")]
struct SocialNetwork {
    // User -> List of friends
    friendships: UnorderedMap>,
    // User -> List of posts
    user_posts: UnorderedMap>,
    // Post -> List of likes
    post_likes: UnorderedMap>,
}

#[app::logic]
impl SocialNetwork {
    pub fn add_friend(&mut self, user: String, friend: String) {
        // Add bidirectional friendship
        self.friendships
            .entry(user.clone())
            .or_insert_with(UnorderedSet::new)
            .insert(friend.clone());

        self.friendships
            .entry(friend)
            .or_insert_with(UnorderedSet::new)
            .insert(user);
    }

    pub fn get_friends(&self, user: &str) -> Vec {
        self.friendships
            .get(user)
            .map(|friends| friends.iter().collect())
            .unwrap_or_default()
    }
}
```

#### Collection Iterators

```rust
#[app::logic]
impl MyApp {
    pub fn get_all_users(&self) -> Vec {
        self.users.values().collect()
    }

    pub fn search_users(&self, query: &str) -> Vec {
        self.users
            .iter()
            .filter(|(username, _)| username.contains(query))
            .map(|(_, profile)| profile)
            .collect()
    }

    pub fn get_active_users(&self) -> Vec {
        self.users
            .iter()
            .filter(|(_, profile)| profile.is_active)
            .map(|(_, profile)| profile)
            .collect()
    }
}
```

## Events and Event Handling

Events are a powerful way to communicate state changes and enable reactive
applications.

### Event Definition

```rust
#[app::event]
pub enum UserEvent {
    UserCreated {
        username: &'a str,
        timestamp: u64,
    },
    UserUpdated {
        username: &'a str,
        field: &'a str,
        old_value: &'a str,
        new_value: &'a str,
    },
    UserDeleted {
        username: &'a str,
        reason: &'a str,
    },
    FriendshipRequested {
        from: &'a str,
        to: &'a str,
    },
    FriendshipAccepted {
        user1: &'a str,
        user2: &'a str,
    },
}

#[app::event]
pub enum SystemEvent {
    MaintenanceMode { enabled: bool, reason: &'a str },
    PerformanceAlert { metric: &'a str, value: f64 },
    ErrorOccurred { error: &'a str, context: &'a str },
}
```

### Event Emission

```rust
#[app::logic]
impl MyApp {
    pub fn create_user(&mut self, username: String, profile: UserProfile) -> Result {
        if self.users.contains_key(&username) {
            return Err("User already exists".to_string());
        }

        self.users.insert(username.clone(), profile);

        // Emit event
        app::emit!(UserEvent::UserCreated {
            username: &username,
            timestamp: env::block_timestamp(),
        });

        Ok(())
    }

    pub fn update_user_profile(&mut self, username: String, new_profile: UserProfile) -> Result {
        let old_profile = self.users.get(&username)
            .ok_or("User not found")?;

        // Emit event before update
        app::emit!(UserEvent::UserUpdated {
            username: &username,
            field: "profile",
            old_value: &old_profile.to_string(),
            new_value: &new_profile.to_string(),
        });

        self.users.insert(username, new_profile);
        Ok(())
    }
}
```

### Event Handling Patterns

#### Conditional Event Emission

```rust
#[app::logic]
impl MyApp {
    pub fn process_friendship_request(&mut self, from: String, to: String) -> Result {
        // Check if users exist
        if !self.users.contains_key(&from) || !self.users.contains_key(&to) {
            return Err("One or both users do not exist".to_string());
        }

        // Check if already friends
        if self.are_friends(&from, &to) {
            return Err("Users are already friends".to_string());
        }

        // Emit event
        app::emit!(UserEvent::FriendshipRequested {
            from: &from,
            to: &to,
        });

        // Add to pending requests
        self.pending_requests.insert((from, to));
        Ok(())
    }
}
```

#### Batch Event Emission

```rust
#[app::logic]
impl MyApp {
    pub fn bulk_update_users(&mut self, updates: Vec) -> Result {
        for (username, new_profile) in updates {
            let old_profile = self.users.get(&username)
                .ok_or(format!("User {} not found", username))?;

            // Emit individual update events
            app::emit!(UserEvent::UserUpdated {
                username: &username,
                field: "profile",
                old_value: &old_profile.to_string(),
                new_value: &new_profile.to_string(),
            });

            self.users.insert(username, new_profile);
        }

        Ok(())
    }
}
```

## Advanced Macros

### Custom State Configuration

```rust
#[app::state(
    emits = for UserEvent,
    version = "1.0.0",
    name = "UserManagementApp"
)]
#[derive(Default, BorshSerialize, BorshDeserialize)]
#[borsh(crate = "calimero_sdk::borsh")]
struct UserManagementApp {
    users: UnorderedMap,
    settings: AppSettings,
}

#[derive(BorshSerialize, BorshDeserialize, Default)]
struct AppSettings {
    max_users: u32,
    allow_public_profiles: bool,
    maintenance_mode: bool,
}
```

### Conditional Logic

```rust
#[app::logic]
impl UserManagementApp {
    pub fn create_user(&mut self, username: String, profile: UserProfile) -> Result {
        // Check maintenance mode
        if self.settings.maintenance_mode {
            return Err("Application is in maintenance mode".to_string());
        }

        // Check user limit
        if self.users.len() >= self.settings.max_users {
            return Err("Maximum user limit reached".to_string());
        }

        if self.users.contains_key(&username) {
            return Err("User already exists".to_string());
        }

        self.users.insert(username.clone(), profile);

        app::emit!(UserEvent::UserCreated {
            username: &username,
            timestamp: env::block_timestamp(),
        });

        Ok(())
    }
}
```

### Access Control Macros

```rust
#[app::logic]
impl UserManagementApp {
    #[app::admin_only]
    pub fn update_settings(&mut self, new_settings: AppSettings) {
        self.settings = new_settings;
    }

    #[app::moderator_or_admin]
    pub fn suspend_user(&mut self, username: String, reason: String) -> Result {
        // Implementation
        Ok(())
    }

    pub fn get_public_profile(&self, username: &str) -> Option {
        if !self.settings.allow_public_profiles {
            return None;
        }

        self.users.get(username).filter(|profile| profile.is_public)
    }
}
```

## State Management Patterns

### Immutable State Access

```rust
#[app::logic]
impl UserManagementApp {
    pub fn get_user_stats(&self) -> UserStats {
        let total_users = self.users.len();
        let active_users = self.users.values()
            .filter(|profile| profile.is_active)
            .count();
        let premium_users = self.users.values()
            .filter(|profile| profile.is_premium)
            .count();

        UserStats {
            total: total_users as u32,
            active: active_users as u32,
            premium: premium_users as u32,
        }
    }
}
```

### Mutable State with Validation

```rust
#[app::logic]
impl UserManagementApp {
    pub fn update_user_role(&mut self, username: String, new_role: UserRole) -> Result {
        let user = self.users.get_mut(&username)
            .ok_or("User not found")?;

        // Validate role transition
        if !self.is_valid_role_transition(&user.role, &new_role) {
            return Err("Invalid role transition".to_string());
        }

        let old_role = user.role.clone();
        user.role = new_role;

        app::emit!(UserEvent::UserUpdated {
            username: &username,
            field: "role",
            old_value: &old_role.to_string(),
            new_value: &user.role.to_string(),
        });

        Ok(())
    }

    fn is_valid_role_transition(&self, from: &UserRole, to: &UserRole) -> bool {
        match (from, to) {
            (UserRole::User, UserRole::Moderator) => true,
            (UserRole::Moderator, UserRole::Admin) => true,
            (UserRole::User, UserRole::Admin) => false, // Must go through moderator
            _ => false,
        }
    }
}
```

## Performance Optimization

### Efficient Collection Usage

```rust
#[app::logic]
impl UserManagementApp {
    // Use references to avoid cloning
    pub fn get_users_by_role(&self, role: &UserRole) -> Vec {
        self.users
            .iter()
            .filter(|(_, profile)| &profile.role == role)
            .map(|(_, profile)| profile)
            .collect()
    }

    // Batch operations for better performance
    pub fn bulk_delete_users(&mut self, usernames: Vec) -> Result {
        for username in usernames {
            if let Some(profile) = self.users.remove(&username) {
                app::emit!(UserEvent::UserDeleted {
                    username: &username,
                    reason: "Bulk deletion",
                });
            }
        }
        Ok(())
    }
}
```

### Memory Management

```rust
#[app::logic]
impl UserManagementApp {
    // Clean up old data periodically
    pub fn cleanup_old_data(&mut self, cutoff_timestamp: u64) {
        let mut to_remove = Vec::new();

        for (username, profile) in self.users.iter() {
            if profile.last_seen  String {
        format!(
            "Users: {}, Settings: {:?}, Maintenance: {}",
            self.users.len(),
            self.settings,
            self.settings.maintenance_mode
        )
    }
}
```

## Common Patterns and Anti-patterns

### Good Patterns

```rust
// ✅ Use events for important state changes
pub fn promote_user(&mut self, username: String) -> Result {
    let user = self.users.get_mut(&username)
        .ok_or("User not found")?;

    let old_role = user.role.clone();
    user.role = UserRole::Moderator;

    app::emit!(UserEvent::UserUpdated {
        username: &username,
        field: "role",
        old_value: &old_role.to_string(),
        new_value: &user.role.to_string(),
    });

    Ok(())
}

// ✅ Validate input before processing
pub fn update_user_email(&mut self, username: String, email: String) -> Result {
    if !self.is_valid_email(&email) {
        return Err("Invalid email format".to_string());
    }

    // Process update...
    Ok(())
}
```

### Anti-patterns to Avoid

```rust
// ❌ Don't emit events for every small change
pub fn update_user_last_seen(&mut self, username: String, timestamp: u64) {
    if let Some(user) = self.users.get_mut(&username) {
        user.last_seen = timestamp;
        // Don't emit event for frequent updates like this
    }
}

// ❌ Don't ignore errors
pub fn unsafe_user_creation(&mut self, username: String, profile: UserProfile) {
    self.users.insert(username, profile); // What if username is empty?
}
```

---

## Calimero Collections Reference

# Calimero Collections Reference

This comprehensive reference covers all available collections in the Calimero
SDK, their performance characteristics, and best practices for using them
effectively.

## Table of Contents

- [Overview](#overview)
- [Core Collections](#core-collections)
- [Specialized Collections](#specialized-collections)
- [Performance Characteristics](#performance-characteristics)
- [Collection Patterns](#collection-patterns)
- [Best Practices](#best-practices)
- [Migration from Standard Collections](#migration-from-standard-collections)

## Overview

Calimero collections are specifically designed for WebAssembly and decentralized
applications. They provide:

- **Wasm Optimization**: Designed for efficient serialization and memory usage
- **Persistent Storage**: Automatic integration with Calimero's storage system
- **Type Safety**: Full Rust type safety with compile-time guarantees
- **Performance**: Optimized for common operations in decentralized apps

## Core Collections

### UnorderedMap

A hash map implementation optimized for Wasm with O(1) average case operations.

#### Basic Usage

```rust
use calimero_storage::collections::UnorderedMap;

#[app::state]
#[derive(Default, BorshSerialize, BorshDeserialize)]
#[borsh(crate = "calimero_sdk::borsh")]
struct UserRegistry {
    users: UnorderedMap,
    user_count: u32,
}

#[app::logic]
impl UserRegistry {
    pub fn add_user(&mut self, username: String, profile: UserProfile) -> Result {
        if self.users.contains_key(&username) {
            return Err("User already exists".to_string());
        }

        self.users.insert(username, profile);
        self.user_count += 1;
        Ok(())
    }

    pub fn get_user(&self, username: &str) -> Option {
        self.users.get(username)
    }

    pub fn update_user(&mut self, username: String, profile: UserProfile) -> Result {
        if !self.users.contains_key(&username) {
            return Err("User not found".to_string());
        }

        self.users.insert(username, profile);
        Ok(())
    }

    pub fn remove_user(&mut self, username: &str) -> Option {
        let user = self.users.remove(username);
        if user.is_some() {
            self.user_count -= 1;
        }
        user
    }
}
```

#### Advanced Operations

```rust
#[app::logic]
impl UserRegistry {
    // Batch operations
    pub fn add_multiple_users(&mut self, users: Vec) -> Result {
        for (username, profile) in users {
            if self.users.contains_key(&username) {
                return Err(format!("User {} already exists", username));
            }
            self.users.insert(username, profile);
            self.user_count += 1;
        }
        Ok(())
    }

    // Filtering and searching
    pub fn get_users_by_role(&self, role: UserRole) -> Vec {
        self.users
            .iter()
            .filter(|(_, profile)| profile.role == role)
            .map(|(_, profile)| profile)
            .collect()
    }

    // Aggregation
    pub fn get_user_stats(&self) -> UserStats {
        let mut stats = UserStats::default();

        for (_, profile) in self.users.iter() {
            stats.total_users += 1;
            if profile.is_active {
                stats.active_users += 1;
            }
            if profile.is_premium {
                stats.premium_users += 1;
            }
        }

        stats
    }

    // Conditional updates
    pub fn update_user_if_exists(&mut self, username: String, profile: UserProfile) -> bool {
        if self.users.contains_key(&username) {
            self.users.insert(username, profile);
            true
        } else {
            false
        }
    }
}
```

### UnorderedSet

A hash set for unique elements with O(1) average case operations.

#### Basic Usage

```rust
use calimero_storage::collections::UnorderedSet;

#[app::state]
#[derive(Default, BorshSerialize, BorshDeserialize)]
#[borsh(crate = "calimero_sdk::borsh")]
struct AccessControl {
    admins: UnorderedSet,
    moderators: UnorderedSet,
    banned_users: UnorderedSet,
}

#[app::logic]
impl AccessControl {
    pub fn add_admin(&mut self, username: String) -> bool {
        self.admins.insert(username)
    }

    pub fn remove_admin(&mut self, username: &str) -> bool {
        self.admins.remove(username)
    }

    pub fn is_admin(&self, username: &str) -> bool {
        self.admins.contains(username)
    }

    pub fn promote_to_moderator(&mut self, username: String) -> Result {
        if !self.admins.contains(&username) {
            return Err("Only admins can be promoted to moderator".to_string());
        }

        self.moderators.insert(username);
        Ok(())
    }

    pub fn ban_user(&mut self, username: String) {
        // Remove from all access levels
        self.admins.remove(&username);
        self.moderators.remove(&username);
        self.banned_users.insert(username);
    }
}
```

#### Set Operations

```rust
#[app::logic]
impl AccessControl {
    // Union of two sets
    pub fn get_all_staff(&self) -> Vec {
        let mut all_staff: Vec = self.admins.iter().collect();
        all_staff.extend(self.moderators.iter());
        all_staff
    }

    // Check if user has any elevated privileges
    pub fn has_privileges(&self, username: &str) -> bool {
        self.admins.contains(username) || self.moderators.contains(username)
    }

    // Get users with specific role
    pub fn get_users_by_role(&self, role: UserRole) -> Vec {
        match role {
            UserRole::Admin => self.admins.iter().collect(),
            UserRole::Moderator => self.moderators.iter().collect(),
            UserRole::User => vec![], // Regular users not stored in sets
        }
    }
}
```

### Vector

A dynamic array implementation with O(1) amortized push and O(n) insert/remove
operations.

#### Basic Usage

```rust
use calimero_storage::collections::Vector;

#[app::state]
#[derive(Default, BorshSerialize, BorshDeserialize)]
#[borsh(crate = "calimero_sdk::borsh")]
struct TaskManager {
    pending_tasks: Vector,
    completed_tasks: Vector,
    task_counter: u64,
}

#[derive(BorshSerialize, BorshDeserialize, Clone)]
struct Task {
    id: u64,
    title: String,
    description: String,
    priority: TaskPriority,
    created_at: u64,
}

#[app::logic]
impl TaskManager {
    pub fn create_task(&mut self, title: String, description: String, priority: TaskPriority) -> u64 {
        let task = Task {
            id: self.task_counter,
            title,
            description,
            priority,
            created_at: env::block_timestamp(),
        };

        self.pending_tasks.push(task);
        self.task_counter += 1;
        self.task_counter - 1
    }

    pub fn get_task(&self, id: u64) -> Option {
        self.pending_tasks
            .iter()
            .chain(self.completed_tasks.iter())
            .find(|task| task.id == id)
    }

    pub fn complete_task(&mut self, id: u64) -> Result {
        let index = self.pending_tasks
            .iter()
            .position(|task| task.id == id)
            .ok_or("Task not found")?;

        let task = self.pending_tasks.remove(index);
        self.completed_tasks.push(task);
        Ok(())
    }

    pub fn get_tasks_by_priority(&self, priority: TaskPriority) -> Vec {
        self.pending_tasks
            .iter()
            .filter(|task| task.priority == priority)
            .collect()
    }
}
```

#### Advanced Vector Operations

```rust
#[app::logic]
impl TaskManager {
    // Batch operations
    pub fn create_multiple_tasks(&mut self, tasks: Vec) -> Vec {
        let mut ids = Vec::new();

        for (title, description, priority) in tasks {
            let id = self.create_task(title, description, priority);
            ids.push(id);
        }

        ids
    }

    // Sorting and filtering
    pub fn get_high_priority_tasks(&self) -> Vec {
        let mut high_priority: Vec = self.pending_tasks
            .iter()
            .filter(|task| task.priority == TaskPriority::High)
            .collect();

        // Sort by creation time (oldest first)
        high_priority.sort_by(|a, b| a.created_at.cmp(&b.created_at));
        high_priority
    }

    // Pagination
    pub fn get_tasks_page(&self, page: u32, page_size: u32) -> Vec {
        let start = (page * page_size) as usize;
        let end = start + page_size as usize;

        self.pending_tasks
            .iter()
            .skip(start)
            .take(page_size as usize)
            .collect()
    }

    // Search functionality
    pub fn search_tasks(&self, query: &str) -> Vec {
        self.pending_tasks
            .iter()
            .filter(|task| {
                task.title.to_lowercase().contains(&query.to_lowercase()) ||
                task.description.to_lowercase().contains(&query.to_lowercase())
            })
            .collect()
    }
}
```

## Specialized Collections

### LookupMap

A map optimized for cases where you need to iterate over keys or values
frequently.

```rust
use calimero_storage::collections::LookupMap;

#[app::state]
#[derive(Default, BorshSerialize, BorshDeserialize)]
#[borsh(crate = "calimero_sdk::borsh")]
struct Analytics {
    // User -> Page views
    page_views: LookupMap,
    // Page -> Total views
    total_views: LookupMap,
}

#[app::logic]
impl Analytics {
    pub fn record_page_view(&mut self, user: String, page: String) {
        // Increment user's page views
        let user_views = self.page_views.get(&user).unwrap_or(0);
        self.page_views.insert(user, user_views + 1);

        // Increment total page views
        let total = self.total_views.get(&page).unwrap_or(0);
        self.total_views.insert(page, total + 1);
    }

    pub fn get_user_stats(&self, user: &str) -> u32 {
        self.page_views.get(user).unwrap_or(0)
    }

    pub fn get_page_stats(&self, page: &str) -> u64 {
        self.total_views.get(page).unwrap_or(0)
    }

    pub fn get_top_pages(&self, limit: usize) -> Vec {
        let mut pages: Vec = self.total_views
            .iter()
            .map(|(page, views)| (page.clone(), *views))
            .collect();

        pages.sort_by(|a, b| b.1.cmp(&a.1));
        pages.truncate(limit);
        pages
    }
}
```

### TreeMap

A sorted map implementation for cases where you need ordered keys.

```rust
use calimero_storage::collections::TreeMap;

#[app::state]
#[derive(Default, BorshSerialize, BorshDeserialize)]
#[borsh(crate = "calimero_sdk::borsh")]
struct Leaderboard {
    // Score -> List of users with that score
    score_rankings: TreeMap>,
    // User -> Current score
    user_scores: UnorderedMap,
}

#[app::logic]
impl Leaderboard {
    pub fn update_score(&mut self, user: String, new_score: u32) {
        // Remove user from old score ranking
        if let Some(old_score) = self.user_scores.get(&user) {
            if let Some(users_at_score) = self.score_rankings.get_mut(old_score) {
                users_at_score.remove(&user);

                // Remove empty score entry
                if users_at_score.is_empty() {
                    self.score_rankings.remove(old_score);
                }
            }
        }

        // Add user to new score ranking
        self.score_rankings
            .entry(new_score)
            .or_insert_with(UnorderedSet::new)
            .insert(user.clone());

        // Update user's score
        self.user_scores.insert(user, new_score);
    }

    pub fn get_top_players(&self, limit: usize) -> Vec {
        let mut top_players = Vec::new();

        // Iterate in reverse order (highest scores first)
        for (score, users) in self.score_rankings.iter().rev() {
            for user in users.iter() {
                top_players.push((user.clone(), *score));
                if top_players.len() >= limit {
                    break;
                }
            }
            if top_players.len() >= limit {
                break;
            }
        }

        top_players
    }

    pub fn get_user_rank(&self, user: &str) -> Option {
        let user_score = self.user_scores.get(user)?;
        let mut rank = 1;

        // Count users with higher scores
        for (score, users) in self.score_rankings.iter().rev() {
            if score > user_score {
                rank += users.len() as u32;
            } else {
                break;
            }
        }

        Some(rank)
    }
}
```

## Performance Characteristics

### Operation Complexity

| Collection   | Insert         | Remove   | Lookup   | Iteration |
| ------------ | -------------- | -------- | -------- | --------- |
| UnorderedMap | O(1) avg       | O(1) avg | O(1) avg | O(n)      |
| UnorderedSet | O(1) avg       | O(1) avg | O(1) avg | O(n)      |
| Vector       | O(1) amortized | O(n)     | O(1)     | O(n)      |
| LookupMap    | O(1) avg       | O(1) avg | O(1) avg | O(n)      |
| TreeMap      | O(log n)       | O(log n) | O(log n) | O(n)      |

### Memory Usage

- **UnorderedMap/Set**: Most memory efficient for large datasets
- **Vector**: Good for sequential access, moderate memory overhead
- **LookupMap**: Optimized for iteration, slightly more memory than UnorderedMap
- **TreeMap**: Highest memory overhead due to tree structure

### When to Use Each Collection

#### Use UnorderedMap when:

- You need fast key-value lookups
- Order doesn't matter
- Memory efficiency is important

#### Use UnorderedSet when:

- You need to track unique elements
- Fast membership testing is required
- Order doesn't matter

#### Use Vector when:

- You need ordered elements
- Sequential access is common
- You frequently add/remove from the end

#### Use LookupMap when:

- You frequently iterate over keys or values
- Memory overhead is acceptable
- You need both map and iteration performance

#### Use TreeMap when:

- You need sorted keys
- Range queries are common
- Order matters for your use case

## Collection Patterns

### Composite Collections

```rust
#[app::state]
#[derive(Default, BorshSerialize, BorshDeserialize)]
#[borsh(crate = "calimero_sdk::borsh")]
struct SocialNetwork {
    // User -> Friends
    friendships: UnorderedMap>,
    // User -> Posts
    user_posts: UnorderedMap>,
    // Post -> Reactions
    post_reactions: UnorderedMap>,
    // User -> Followers
    followers: UnorderedMap>,
    // User -> Following
    following: UnorderedMap>,
}

#[app::logic]
impl SocialNetwork {
    pub fn add_friend(&mut self, user: String, friend: String) {
        // Add bidirectional friendship
        self.friendships
            .entry(user.clone())
            .or_insert_with(UnorderedSet::new)
            .insert(friend.clone());

        self.friendships
            .entry(friend)
            .or_insert_with(UnorderedSet::new)
            .insert(user);
    }

    pub fn create_post(&mut self, user: String, content: String) -> u64 {
        let post = Post {
            id: self.generate_post_id(),
            content,
            author: user.clone(),
            created_at: env::block_timestamp(),
        };

        self.user_posts
            .entry(user)
            .or_insert_with(Vector::new)
            .push(post.clone());

        post.id
    }

    pub fn follow_user(&mut self, follower: String, following: String) {
        if follower == following {
            return; // Can't follow yourself
        }

        self.followers
            .entry(following.clone())
            .or_insert_with(UnorderedSet::new)
            .insert(follower.clone());

        self.following
            .entry(follower)
            .or_insert_with(UnorderedSet::new)
            .insert(following);
    }

    pub fn get_feed(&self, user: &str) -> Vec {
        let mut feed = Vec::new();

        // Get posts from followed users
        if let Some(following) = self.following.get(user) {
            for followed_user in following.iter() {
                if let Some(posts) = self.user_posts.get(followed_user) {
                    feed.extend(posts.iter());
                }
            }
        }

        // Sort by creation time (newest first)
        feed.sort_by(|a, b| b.created_at.cmp(&a.created_at));
        feed
    }
}
```

### Indexed Collections

```rust
#[app::state]
#[derive(Default, BorshSerialize, BorshDeserialize)]
#[borsh(crate = "calimero_sdk::borsh")]
struct ProductCatalog {
    // Product ID -> Product details
    products: UnorderedMap,
    // Category -> Product IDs
    products_by_category: UnorderedMap>,
    // Price range -> Product IDs
    products_by_price: TreeMap>,
    // Search index: word -> Product IDs
    search_index: UnorderedMap>,
}

#[app::logic]
impl ProductCatalog {
    pub fn add_product(&mut self, product: Product) {
        let product_id = product.id;

        // Add to main products map
        self.products.insert(product_id, product.clone());

        // Add to category index
        self.products_by_category
            .entry(product.category.clone())
            .or_insert_with(UnorderedSet::new)
            .insert(product_id);

        // Add to price index
        self.products_by_price
            .entry(product.price)
            .or_insert_with(UnorderedSet::new)
            .insert(product_id);

        // Add to search index
        for word in product.name.split_whitespace() {
            let word = word.to_lowercase();
            self.search_index
                .entry(word)
                .or_insert_with(UnorderedSet::new)
                .insert(product_id);
        }
    }

    pub fn search_products(&self, query: &str) -> Vec {
        let query_words: Vec = query.split_whitespace().collect();
        let mut product_ids = UnorderedSet::new();

        // Find products matching all query words
        for word in query_words {
            let word = word.to_lowercase();
            if let Some(ids) = self.search_index.get(&word) {
                if product_ids.is_empty() {
                    product_ids = ids.clone();
                } else {
                    // Intersection of all word matches
                    product_ids = product_ids.intersection(ids).cloned().collect();
                }
            }
        }

        // Convert IDs to products
        product_ids
            .iter()
            .filter_map(|id| self.products.get(id))
            .collect()
    }

    pub fn get_products_by_category(&self, category: &str) -> Vec {
        self.products_by_category
            .get(category)
            .map(|ids| {
                ids.iter()
                    .filter_map(|id| self.products.get(id))
                    .collect()
            })
            .unwrap_or_default()
    }

    pub fn get_products_in_price_range(&self, min_price: u32, max_price: u32) -> Vec {
        let mut products = Vec::new();

        for (price, ids) in self.products_by_price.range(min_price..=max_price) {
            for id in ids.iter() {
                if let Some(product) = self.products.get(id) {
                    products.push(product);
                }
            }
        }

        products
    }
}
```

## Best Practices

### Memory Management

```rust
// ✅ Good: Clean up old data
pub fn cleanup_old_sessions(&mut self, cutoff_time: u64) {
    let mut to_remove = Vec::new();

    for (session_id, session) in self.active_sessions.iter() {
        if session.last_activity  Vec {
    self.users
        .iter()
        .filter(|(_, profile)| profile.is_active)
        .map(|(_, profile)| profile)
        .collect()
}

// ❌ Bad: Unnecessary cloning
pub fn get_active_users_bad(&self) -> Vec {
    self.users
        .iter()
        .filter(|(_, profile)| profile.is_active)
        .map(|(_, profile)| profile.clone()) // Unnecessary clone
        .collect()
}
```

### Batch Operations

```rust
// ✅ Good: Batch operations for better performance
pub fn bulk_update_users(&mut self, updates: Vec) -> Result {
    for (username, profile) in updates {
        if !self.users.contains_key(&username) {
            return Err(format!("User {} not found", username));
        }
        self.users.insert(username, profile);
    }
    Ok(())
}

// ❌ Bad: Multiple individual operations
pub fn bulk_update_users_bad(&mut self, updates: Vec) -> Result {
    for (username, profile) in updates {
        self.update_user(username, profile)?; // Multiple function calls
    }
    Ok(())
}
```

## Migration from Standard Collections

### From std::collections::HashMap

```rust
// Before (standard collections)
use std::collections::HashMap;

struct OldApp {
    users: HashMap,
}

// After (Calimero collections)
use calimero_storage::collections::UnorderedMap;

#[app::state]
#[derive(Default, BorshSerialize, BorshDeserialize)]
#[borsh(crate = "calimero_sdk::borsh")]
struct NewApp {
    users: UnorderedMap,
}
```

### From std::collections::HashSet

```rust
// Before
use std::collections::HashSet;

struct OldApp {
    admins: HashSet,
}

// After
use calimero_storage::collections::UnorderedSet;

#[app::state]
#[derive(Default, BorshSerialize, BorshDeserialize)]
#[borsh(crate = "calimero_sdk::borsh")]
struct NewApp {
    admins: UnorderedSet,
}
```

### From Vec

```rust
// Before
struct OldApp {
    tasks: Vec,
}

// After
use calimero_storage::collections::Vector;

#[app::state]
#[derive(Default, BorshSerialize, BorshDeserialize)]
#[borsh(crate = "calimero_sdk::borsh")]
struct NewApp {
    tasks: Vector,
}
```

---

## TypeScript Client SDK

## Getting Started with Calimero SDK for Typescript

Our TypeScript Client SDK is a powerful tool designed to simplify the process of
interacting with decentralized peer-to-peer applications installed on the node.

Install the SDK using npm:

```bash
npm install @calimero-network/calimero-client
```

## Core Components

The TypeScript Client SDK consists of several key components:

### 1. RpcClient (JsonRpcClient)

Handles communication with the node's RPC server for executing queries and
mutations.

### 2. SubscriptionsClient (WsSubscriptionsClient)

Manages WebSocket connections for real-time updates and event subscriptions.

### 3. HttpClient (AxiosHttpClient)

Provides HTTP communication capabilities for admin API interactions.

### 4. Authentication Components

- `AccessTokenWrapper`: Manages JWT token lifecycle
- `ClientLogin`: Handles user authentication flow
- `SetupModal`: Configures node URL and application settings

### 5. Storage Utilities

Manages local storage for:

- Access tokens
- Refresh tokens
- Application URLs
- Context identities

## Authentication Setup

### 1. Client Login Component

```typescript
import { ClientLogin } from '@calimero-network/calimero-client';

const LoginPage = () => {
    return (
         process.env.NEXT_PUBLIC_API_URL}
            getApplicationId={() => process.env.NEXT_PUBLIC_APPLICATION_ID}
            successRedirect={() => navigate('/dashboard')}
        />
    );
};
```

### 2. Token Management

```typescript
import { AccessTokenWrapper } from '@calimero-network/calimero-client';

const App = () => {
    return (
         process.env.NEXT_PUBLIC_API_URL}
        >
            
        
    );
};
```

### 3. Initial Setup

```typescript
import { SetupModal } from '@calimero-network/calimero-client';

const Setup = () => {
    return (
         navigate('/dashboard')}
            getNodeUrl={() => localStorage.getItem('nodeUrl')}
            setNodeUrl={(url) => localStorage.setItem('nodeUrl', url)}
            getApplicationId={() => localStorage.getItem('appId')}
            setApplicationId={(id) => localStorage.setItem('appId', id)}
        />
    );
};
```

### 4. Token Storage

```typescript
import {
  setAccessToken,
  getAccessToken,
  setRefreshToken,
  getRefreshToken,
  clearJWT,
} from '@calimero-network/calimero-client';

// Store tokens
setAccessToken(accessToken);
setRefreshToken(refreshToken);

// Retrieve tokens
const accessToken = getAccessToken();
const refreshToken = getRefreshToken();

// Clear tokens on logout
clearJWT();
```

## Using RpcClient

Important: Always use the `execute` method instead of deprecated `query` or
`mutate` methods.

```typescript
import { JsonRpcClient } from '@calimero-network/calimero-client';

// Initialize client
const rpcClient = new JsonRpcClient(
  process.env.NEXT_PUBLIC_API_URL,
  '/jsonrpc',
);

// Define interfaces
interface CreatePost {
  title: string;
  text: string;
}

interface Post {
  id: string;
  title: string;
  text: string;
}

// Execute a method
const response = await rpcClient.execute({
  applicationId: process.env.NEXT_PUBLIC_APPLICATION_ID,
  method: 'create_post',
  argsJson: {
    title: 'My First Post',
    text: 'Hello Calimero!',
  },
});
```

## Using SubscriptionsClient

```typescript
import { WsSubscriptionsClient } from '@calimero-network/calimero-client';

// Initialize client
const wsClient = new WsSubscriptionsClient(
  process.env.NEXT_PUBLIC_API_URL,
  '/ws',
);

// Connect to WebSocket
await wsClient.connect();

// Subscribe to application events
wsClient.subscribe([process.env.NEXT_PUBLIC_APPLICATION_ID]);

// Handle incoming events
wsClient.addCallback((event) => {
  switch (event.type) {
    case 'StateMutation':
      console.log('State updated:', event.data.newRoot);
      break;
    case 'ExecutionEvent':
      console.log('Event:', event.data);
      break;
  }
});

// Cleanup
wsClient.disconnect();
```

## Contract API Integration

```typescript
import { ContractApiDataSource } from '@calimero-network/calimero-client';

const contractApi = new ContractApiDataSource(httpClient);

// Get proposals
const proposals = await contractApi.getContractProposals();

// Get proposal details
const details = await contractApi.getProposalDetails(proposalId);

// Get number of approvals
const approvals = await contractApi.getNumberOfApprovals(proposalId);
```

## Error Handling

```typescript
interface ErrorResponse {
  code?: number;
  message: string;
}

try {
  const result = await rpcClient.execute(params);
  if (result.error) {
    if (result.error.code === 401) {
      // Handle authentication error
      clearJWT();
      redirectToLogin();
    }
    console.error('RPC Error:', result.error.message);
  }
} catch (error) {
  console.error('Unexpected error:', error);
}
```

## Admin API Endpoints

### Protected Endpoints (Requires Authentication)

#### Application Management

- `POST /admin-api/root-key` - Create root key
- `POST /admin-api/install-application` - Install application
- `POST /admin-api/uninstall-application` - Uninstall application
- `GET /admin-api/applications` - List applications
- `GET /admin-api/applications/:app_id` - Get application details

#### Context Management

- `POST /admin-api/contexts` - Create context
- `GET /admin-api/contexts` - List contexts
- `GET /admin-api/contexts/:context_id` - Get context details
- `DELETE /admin-api/contexts/:context_id` - Delete context
- `GET /admin-api/contexts/:context_id/users` - Get context users
- `GET /admin-api/contexts/:context_id/client-keys` - Get context client keys
- `GET /admin-api/contexts/:context_id/storage` - Get context storage
- `GET /admin-api/contexts/:context_id/identities` - Get context identities
- `POST /admin-api/contexts/invite` - Invite to context
- `POST /admin-api/contexts/join` - Join context
- `POST /admin-api/contexts/:context_id/capabilities/grant` - Grant capabilities
  to context identities
- `POST /admin-api/contexts/:context_id/capabilities/revoke` - Revoke
  capabilities from context identities

#### Identity Management

- `POST /admin-api/identity/context` - Generate context identity
- `DELETE /admin-api/identity/keys` - Delete auth keys
- `POST /admin-api/generate-jwt-token` - Generate JWT token
- `GET /admin-api/did` - Fetch DID
- `DELETE /admin-api/did` - Delete DID

#### Alias Management

##### Create routes

```http title="POST /admin-api/alias/create/context"
{
  "alias": "string",
  "value": {
    "contextId": "ContextId"
  }
}
```

- Generate context identity

```http title="POST /admin-api/alias/create/identity/{context_id}"
{
  "alias": "string",
  "value": {
    "identity": "PublicKey"
  }
}
```

- Creates an alias for an identity within a specific context.

```http title="POST /admin-api/alias/create/application"
{
  "alias": "string",
  "value": {
    "applicationId": "ApplicationId"
  }
}
```

- Creates an alias for an application ID.

##### Capabilities Management

```http title="POST /admin-api/contexts/:context_id/capabilities/grant"
{
  "capabilities": [["ContextIdentity", "Capability"]],
  "signer_id": "PublicKey"
}
```

- Grants specific capabilities to context identities.

```http title="POST /admin-api/contexts/:context_id/capabilities/revoke"
{
  "capabilities": [["ContextIdentity", "Capability"]],
  "signer_id": "PublicKey"
}
```

- Revokes specific capabilities from context identities.

##### Lookup routes

- `POST /admin-api/alias/lookup/context/:name` - Generate context identity
- `POST /admin-api/alias/lookup/application/:name` - Generate context identity
- `POST /admin-api/alias/lookup/identity/:context/:name` - Generate context
  identity

##### Delete routes

- `POST /admin-api/alias/delete/context/:name` - Generate context identity
- `POST /admin-api/alias/delete/application/:name` - Generate context identity
- `POST /admin-api/alias/delete/identity/:context/:name` - Generate context
  identity

### Unprotected Endpoints

#### Authentication

- `GET /admin-api/health` - Health check
- `GET /admin-api/certificate` - Get certificate
- `POST /admin-api/request-challenge` - Request challenge
- `POST /admin-api/add-client-key` - Add client key
- `POST /admin-api/refresh-jwt-token` - Refresh JWT token

#### Proposal Management

- `GET /admin-api/contexts/:context_id/proposals/:proposal_id/approvals/count` -
  Get proposal approvals count
- `GET /admin-api/contexts/:context_id/proposals/:proposal_id/approvals/users` -
  Get proposal approvers
- `GET /admin-api/contexts/:context_id/proposals/count` - Get active proposals
  count
- `POST /admin-api/contexts/:context_id/proposals` - Get proposals
- `GET /admin-api/contexts/:context_id/proposals/:proposal_id` - Get proposal
  details
- `POST /admin-api/contexts/:context_id/proposals/get-context-value` - Get
  context value
- `POST /admin-api/contexts/:context_id/proposals/context-storage-entries` - Get
  context storage entries
- `GET /admin-api/contexts/:context_id/proxy-contract` - Get proxy contract

## Using Admin API

Any endpoints not exposed throught the SDK you can use like this:

```typescript
import { AxiosHttpClient } from '@calimero-network/calimero-client';

const httpClient = new AxiosHttpClient(axios);

// Example: Get context details
const contextDetails = await httpClient.get(
  `${nodeUrl}/admin-api/contexts/${contextId}`,
);

// Example: Create context
const createContext = await httpClient.post(
  `${nodeUrl}/admin-api/contexts`,
  contextData,
);
```

## Important Notes

1. Always use the `execute` method for RPC calls instead of deprecated `query`
   or `mutate`
2. Implement proper error handling for both RPC and WebSocket operations
3. Ensure proper cleanup of WebSocket connections when they're no longer needed
4. Store sensitive information securely using the provided storage utilities
5. Use the built-in token refresh mechanism to maintain sessions
6. All protected endpoints require valid JWT authentication

---

## Admin Dashboard

Node is gated with authentication. In order to interact with the node from any
app, you need to register a decentralized identity. We have build an Admin
Dashboard which is a web application designed to streamline the management of
node states within your system. Connected with the API provided by the Admin
Client API, this user interface offers a user-friendly platform for overseeing
and controlling various aspects of your node infrastructure.

### Access Admin Dashboard

The node operates as a server for the Admin Dashboard and can be accessed
directly through a web browser.

The Admin Dashboard is locally available at
`http://localhost:NODE_PORT/admin-dashboard/` but you can also use application
deployed on Github Pages at
`https://calimero-network.github.io/admin-dashboard/`.

> **_NOTE:_** Update `NODE_PORT` in the placeholder `http://localhost:NODE_PORT`
> with the `--server-port` value defined during node setup in
> [Getting-started](../../getting-started/setup)

### Setup

After the initial setup you will see the setup page where you need to enter node
URL.

![SetupPage](/admin-dashboard-functions/1setup-node-url.png)

> **NOTE**: Error occurs if the entered URL is not valid node url or the node is
> not running

![SetupPageError](/admin-dashboard-functions/setup-node-url-error.png)

### Login

After button "Set node url" is clicked you will be redirected to select wallet
page.

![WalletSelector](/admin-dashboard-functions/2select-wallet.png)

In this example we will be using Metamask with Ethereum Mainnet.

Press "Connect wallet" button to invoke Metamask extension which is needed to
continue login process.

![ConnectWallet](/admin-dashboard-functions/3connect-wallet.png)

When wallet is connected you will be shown the next screen with displayed
connected wallet address.

![ConnectedAccount](/admin-dashboard-functions/4logged-in-acc.png)

To finish login process press "Sign authentication transaction" which will
envoke Metamask to sign transaction.

![SignLoginTxn](/admin-dashboard-functions/5metamask-sign-msg-login.png)

> **NOTE**: Displayed "BNB 2" text is just a wallet name and this is configued
> in Metamask. You might have default wallet name "Account" or "Account 1"

On the first login, your selected wallet will be used as a root key to use
further functionalities.

> **NOTE**: If you logout and try to login with different wallet that is not the
> root key you will get the next error

![SinginError](/admin-dashboard-functions/7no-root-key-login.png)

After this request is confimed you will be redirected to the Identity page of
the Admin Dashboard where you can see your root key.

![IdentityPage](/admin-dashboard-functions/6identity.png)

### Add new root key

To add new root key press the "Add new root key" button and you will go through
the same process.

In this example we will be using Metamask again but this time we will use BNB
Chain network with different wallet.

![AddNewRootKey](/admin-dashboard-functions/8add-new-root-key.png)

Again, sign the transaction.

![ConfirmNewRootKey](/admin-dashboard-functions/9add-root-key-txn.png)

You will be redirected back the Identity page and in the list you can see that
the new root key with BNB network was added.

![NewRootkeyList](/admin-dashboard-functions/10new-root-key-added.png)

### Applications

Navigate to "Applications" tab to view table of available, owned or installed
applications.

![Applications](/admin-dashboard-functions/12applications.png)

#### Publish new application

To publish new application click on the "Publish new application" button and you
will be redirected to next page.

> **NOTE**: For this step you will need a NEAR blockchain account because the
> Package Manager application is a smart contract deployed on the NEAR
> blockchain.

> This is needed because from your account you interact with the smart contract
> deployed on the NEAR blockchain

> You can create NEAR blockchain account with
> [MyNEARWallet](https://testnet.mynearwallet.com/)

> Package Manager contains metadata of applications used by the node

Metadata for each application contains:

- Package name `String`
- Description `String` - optional and can be set to "-"
- Repository URL `String` - optional and can be set to "-"
- Path `String` - IPFS URL to the application binary, filled automatically when
  application wasm is uploaded
- Version `String` - has "X.X.X" format (e.g. 0.0.1 or 1.0.0)
- Noted `String` - optional and can be set to "-"
- Hash `String` - Hash value of application wasm, filled automatically when
  application wasm is uploaded

![PublishApp](/admin-dashboard-functions/13upload-new-app.png)

After you fill in the Package name, Description, Repository URL click on the
"Upload wasm" button and select your application `.wasm` file (e.g. only-peers
application wasm).

![SelectWasmFile](/admin-dashboard-functions/13select-wasm.png)

After file was uploaded to IPFS, Path and Hash field will be filled
automatically and only thing left is to fill in version and notes.

![UploadedWasm](/admin-dashboard-functions/13filled-in-fields.png)

After you click the "Publish" button, application will be published in the
Package Manager contract and it will be available in the available applications
list.

You will get a status popup message.

![ApplicationPublished](/admin-dashboard-functions/13published-application.png)

#### Install available application

To install one of the available application from the Package Manager click on
the "install new application" button.

![Applications](/admin-dashboard-functions/12applications.png)

You will be redirected to install page where you can browse available
applications or upload a new one.

![InstallApplication](/admin-dashboard-functions/14install-application.png)

On "Browse" button click you will get a available application list where you can
select application you want to install.

![BrowseApplications](/admin-dashboard-functions/14browse-applications.png)

On selection the application Metadata will be displayed and you can press
"install application" button to install the application.

![BrowseApplications](/admin-dashboard-functions/15install-application.png)

On sucessfull installation you will get status popup.

![ApplicationInstalled](/admin-dashboard-functions/16application-installed.png)

### Context

Preview context which you have already joined or invited. You can also create a
new context.

![ContextList](/admin-dashboard-functions/18context-list.png)

#### Start new context

To start new context press the "Start new context" button on previous page.

You can select application with which you want to create a new context or you
can upload a new application.

![StartContextSelect](/admin-dashboard-functions/19start-context-select.png)

If your application requires initialization parameters, you can select the
'Initialize application state' option during startup.

> **NOTE**: To understand this lets take two examples.
>
> 1. Consider a JavaScript class MyClass. In some cases, you can create an
>    instance using `new MyClass()` if there are no initialization parameters
>    required.
> 2. However, if your class requires specific parameters for initialization, you
>    need to pass them like this: `new MyClass({ application_name: name })`.
>    This is similar to your WASM application's requirement for initialization
>    parameters during its startup process.

![StartContextSelected](/admin-dashboard-functions/20start-context-selected.png)

> **NOTE**: You must select a protocol for your context. Currently supported
> protocols are: NEAR, Starknet, ICP, Stellar, Ethereum

On button "Start" click the new context will be created and you will get status
popup.

![Context installed](/admin-dashboard-functions/21context-installed.png)

You can now see created context in the context list.

![ContextListInstalled](/admin-dashboard-functions/22context-list.png)

### Export

Allows you to export you identity on current device and import it on new device.

![ContextList](/admin-dashboard-functions/23export-identity.png)

---

## Desktop App

Calimero Node Manager Desktop app is a simple desktop application that allows
you to manage and interact with Calimero nodes without needing any technical
knowledge.

## Download and Install the App

1. Go to the
   [Calimero Node Manager download page](https://github.com/calimero-network/node-multiplatform-tauri/releases).
2. Select the latest version and download the app for your machine from the
   assets list:

Download and run the installer. Follow the instructions to install the app.

> **_NOTE:_** Supported OS
>
> - Linux: Works on modern distributions like Fedora, Red Hat, CentOS, Ubuntu,
>   and Debian (64-bit systems)
> - Mac: Supports macOS for both Intel and Apple Silicon Supported

### Key Features

- Initialize Node: Create and initialize a new node with specified parameters.
- Update Node: Modify the configuration of an existing node.
- Start Node: Start a specified node.
- Stop Node: Stop a running node.
- Get Node Log: Retrieve the log file for a specified node.
- Delete Node: Remove a specified node from the application.
- Open Dashboard: Open the admin dashboard for a specified node.

If you'd like to run the app locally or contribute to its development, you can
access the source code on our GitHub repository:
[Node Multiplatform Tauri](https://github.com/calimero-network/node-multiplatform-tauri)

Feel free to explore, fork the repository, and contribute by submitting pull
requests or reporting issues.

---

## Overview

Welcome to the Tutorials section of the Calimero Network documentation! Here,
you’ll find step-by-step guides to help you build, deploy, and integrate
applications using Calimero's features. Whether you're a beginner setting up
your first environment or an experienced developer exploring advanced use cases,
these tutorials are designed to provide practical insights and hands-on
experience. Let's get started!

---

## Near Wallet

## Logging in with NEAR Wallet

Calimero allows users to authenticate via their NEAR wallet, ensuring secure
access to the Admin Dashboard. The process of logging in with a NEAR wallet
involves the following steps:

### 1. User Initiates Login

- The user navigates to the Admin Dashboard and selects the option to "Login
  with NEAR Wallet."

### 2. Server Issues Challenge

- Upon selecting the login option, the server generates a challenge. This
  challenge is then presented to the user for signing.

### 3. Redirect to MyNearWallet

- The user is redirected to the [MyNearWallet](https://mynearwallet.com/) page,
  where they will be asked to sign the server-issued challenge using their NEAR
  wallet.

### 4. Signature Sent to Backend

- After the user signs the challenge, the signature is sent back to the server
  for verification.

### 5. Signature Verification

- The backend verifies the signature to ensure its authenticity. If the
  signature is valid, the user's public key is extracted from the signature and
  added as the user's unique identifier.
- This public key serves as the user's Decentralized Identifier (DID), not as a
  context-specific identity. The DID enables decentralized authentication,
  ensuring that the user can interact with the platform securely across
  different contexts and applications.

### 6. Successful Login

- Once verified, the user is successfully logged into the Admin Dashboard, with
  their public key (DID) serving as their user ID for future interactions.

This login flow ensures a secure and seamless authentication process leveraging
NEAR's robust blockchain-based security.

---

## Starknet Wallet

## Logging in with Starknet

Calimero allows users to authenticate via their Starknet wallet, ensuring secure
access to the Admin Dashboard. The process of logging in with a Starknet wallet
involves the following steps:

### 1. User Initiates Login

- The user navigates to the Admin Dashboard and selects the option to "Login
  with Starknet."
- They are presented with two wallet options: ArgentX and Metamask Snap.

### 2. Wallet Selection

- The user chooses their preferred wallet: ArgentX or Metamask Snap.

### 3. Wallet Connection

#### For ArgentX:

- If ArgentX is installed, the user is prompted to connect their wallet.
- If not installed, the user is directed to install the ArgentX browser
  extension.

#### For Metamask Snap:

- If Metamask with Starknet Snap is installed, the user is prompted to connect.
- If not installed, the user is guided to install Metamask and the Starknet
  Snap.

### 4. Server Issues Challenge

- Upon selecting the wallet, the server generates a challenge. This challenge is
  then presented to the user for signing.

### 5. User Signs Challenge

- The user is prompted to sign the server-issued challenge using their selected
  Starknet wallet.

### 6. Signature Sent to Backend

- After the user signs the challenge, the signature is sent back to the server
  for verification.

### 7. Signature Verification

The backend verifies the signature to ensure its authenticity using a process
tailored to Starknet's cryptographic standards. This verification process
differs depending on whether the user is using ArgentX or Metamask Snap.

#### For ArgentX Wallets:

1. **On-Chain Verification**:

   - The signature is initially verified on-chain using the Starknet network.
   - A JSON-RPC call is made to the Starknet node, invoking the
     `isValidSignature` function on the user's wallet contract.
   - This on-chain verification ensures the signature's validity according to
     the wallet's implementation.

2. **Message Hash Verification**:
   - If the on-chain verification succeeds, an additional verification of the
     message hash is performed off-chain.
   - This step ensures the integrity of the signed message and prevents any
     tampering.

#### For Metamask Snap:

1. **Off-Chain Verification**:

   - The signature is verified off-chain using Starknet's cryptographic
     libraries.
   - This involves using the `verify` function from the `starknet_crypto`
     library to check the signature against the provided public key.

2. **Message Hash Verification**:
   - If the signature is valid, an additional verification of the message hash
     is performed.
   - This ensures the integrity of the signed message, similar to the ArgentX
     process.

#### Final Steps:

- If the signature and hash are valid, the user's Starknet address is extracted
  from the wallet address used in the verification process.
- This address serves as the user's Decentralized Identifier (DID), enabling
  decentralized authentication across different contexts and applications.

### 8. Successful Login

- Once verified, the user is successfully logged into the Admin Dashboard, with
  their Starknet address (DID) serving as their user ID for future interactions.

This login flow ensures a secure and seamless authentication process leveraging
Starknet's robust blockchain-based security.

---

## ICP Wallet

## Logging in with Internet Identity

The login process with Internet Identity involves these key steps:

### 1. User Initiates Login

- The user navigates to the Admin Dashboard and selects the option to "Login
  with Internet Identity."

### 2. Challenge Preparation

- The system prepares a challenge (encoded as a session public key) before
  initiating the authentication process.

### 3. Internet Identity Authentication

- A popup window opens, connecting to the Internet Identity service.
- The user authenticates through this popup.
- The challenge (session public key) is sent to the II service.

### 4. Delegation Chain Retrieval

- Upon successful authentication, the II service creates and returns a
  delegation chain.
- This delegation chain includes cryptographic proofs of the user's
  authentication.

### 5. Processing the Authentication Result

- The application receives the delegation chain from the II service.
- It processes this data, extracting necessary information like the user's
  public key.

### 6. Login Request Preparation

- The application prepares a login request including:
  - The serialized delegation chain
  - The original challenge payload
  - Wallet metadata (ICP canister ID and wallet name)

### 7. Server-side Verification

- The login request is sent to the Calimero server.
- The server verifies the delegation chain and challenge.

### 8. Successful Login

- Upon successful verification, the user is logged in and directed to the
  identity page.
- The user's Internet Identity becomes their unique identifier for future
  interactions within the Calimero ecosystem.

This process leverages ICP's delegation chain mechanism for secure,
decentralized authentication.

---

## Create Context

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import ContextCreateBinary from '../shared/context-create-binary.mdx';
import ContextCreateInteractiveCli from '../shared/context-create-interactive-cli.mdx';
import ContextCreateAdminDashboard from '../shared/context-create-admin-dashboard.mdx';
import InitNode from '../shared/node-init-binary.mdx';
import RunNode from '../shared/node-run-binary.mdx';

### Initialize node

### Run node

### Create a New Context

  
    
  
  
    
  
  
    
  

You have now created a new context.

To create an alias for this context, use:

```bash title="Terminal"
context alias add my_context 
```

Next step is to invite users to join your context. Continue with
[invitations and joinings](./invitations-and-joinings).

---

## Invitations and Joinings

## Invite to context with Admin Dashboard

> Currently not available

## Invite node to context using interactive CLI

Inviting to the context consists of 3 steps:

1. Identity Exchange: The peer wishing to join (invitee) shares their identity
   with the existing member (invitor).
2. Create Invitation: The invitor generates an invitation payload for the
   context.
3. Accept Invitation: The invitee signs the invitation payload to confirm their
   identity and join the context.

In the example below, Node 2 is the invitee, and Node 1 is the invitor.

:::tip

If you create an Context Alias for your context using

```bash title="Context Alias (Node1)"
context alias add my_context {contextID}
```

And then create an Identity Alias for your identity in the context using

```bash title="Identity Alias (Node1)"
identity alias add bob {PublicKey} --context my_context ## ERROR HERE
```

Everywhere in the tutorial, on the node which you have created the aliases
(aliases are node specific), you can use `my_context` and `bob` instead of the
contextID and the invitorContextIdentity

:::

### Step-by-Step Process

1. Invitee Generates and Shares Identity To join the context, the invitee must
   first create and share their identity with the invitor. This can be done
   using the following command:

```bash title="Node 2"
context identity new
```

This generates a private and public key pair, where the public key is the
inviteeContextIdentity. Share this public key with the invitor.

```bash title="Example"
context identity new
│ Private Key: 6i52ykNTqSqCgfDPYiKktListssSP9YwxLMzApDZe5U7
│ Public Key: 3yBQQvn2G8ghWk2ZwmLFYxJQgM1YmDtiigi84nGpZBb9
```

![Create Identity](/cli/3-create-identity.png)

2. Invitor Creates an Invitation Once the invitee’s public key is shared, the
   invitor generates an invitation to the context using the following command:

```bash title="Node 1"
context invite -c {contextId} {inviteeContextIdentity} --as {inviterContextIdentity}
```

```bash title="Example"
context invite -c 567C5Gg4mxHMPKy2wLJ4uvb3DHsbcpVDYUsuAWgTPgXn 3yBQQvn2G8ghWk2ZwmLFYxJQgM1YmDtiigi84nGpZBb9 --as DaSkad6DK7f6fUhjz1CvNW7L4TkWZmWqAcwysZHG3Xs5
│ Invited 3yBQQvn2G8ghWk2ZwmLFYxJQgM1YmDtiigi84nGpZBb9 to context 567C5Gg4mxHMPKy2wLJ4uvb3DHsbcpVDYUsuAWgTPgXn
│ Invitation Payload: axDfZcWCw7jc3i7MeG9JqhsYrNXRSvg6hXVWYpdsxNRhAjKD35S5FruCzyRWHYHzQyN1QbSVyRKRiTwz8Kbq4aj2dSdmi7HNxwcjTS5JkK1xwJMA8ogYuWHhDj4jfLdukPZb2SavC8cq3npFydinVZ
```

![Context Invite](/cli/4-context-invite.png)

To check the invitor's identity, use this command:

```bash title="Node 1"
context identity ls -c {contextId}
```

```bash title="Example"
context identity ls -c 567C5Gg4mxHMPKy2wLJ4uvb3DHsbcpVDYUsuAWgTPgXn
│ Identity                                     |  Owned │
| DaSkad6DK7f6fUhjz1CvNW7L4TkWZmWqAcwysZHG3Xs5 | *
```

Listed identity is invitorContextIdentity used above.

3. Invitee Accepts the Invitation After receiving the invitation payload from
   the invitor, the invitee can accept the invitation by signing it with their
   private key:

```bash title="Node 2"
context join {inviteePrivateKey} {invitationPayload}
```

```bash title="Example"
context join 6i52ykNTqSqCgfDPYiKktListssSP9YwxLMzApDZe5U7 axDfZcWCw7jc3i7MeG9JqhsYrNXRSvg6hXVWYpdsxNRhAjKD35S5FruCzyRWHYHzQyN1QbSVyRKRiTwz8Kbq4aj2dSdmi7HNxwcjTS5JkK1xwJMA8ogYuWHhDj4jfLdukPZb2SavC8cq3npFydinVZ
2024-10-07T12:18:51.809231Z  INFO calimero_context: Subscribed to context context_id=567C5Gg4mxHMPKy2wLJ4uvb3DHsbcpVDYUsuAWgTPgXn
2024-10-07T12:18:51.811102Z  INFO calimero_context: Joined context with pending catchup context_id=567C5Gg4mxHMPKy2wLJ4uvb3DHsbcpVDYUsuAWgTPgXn
│ Joined context 567C5Gg4mxHMPKy2wLJ4uvb3DHsbcpVDYUsuAWgTPgXn as 3yBQQvn2G8ghWk2ZwmLFYxJQgM1YmDtiigi84nGpZBb9, waiting for catchup to complete...
```

![Context Join](/cli/5-context-join.png)

4. Verifying Context Membership To confirm successful joining of the context,
   the invitee can list their contexts with the following command:

```bash title="Node 2"
context ls
```

```bash title="Example"
context ls
│ Context ID                                   | Application ID                               | Last Transaction
│ 567C5Gg4mxHMPKy2wLJ4uvb3DHsbcpVDYUsuAWgTPgXn | Ahe2vLWLgswJARv5LsafXp7uJyb2Ba9GjzUSeLc71gUF | b3ipivssRRm1ehRTSpUD3GKdUpvi3vq311pCT4iLvui
```

![Context List](/cli/8-context-list.png)

5. The invitee can also list identities in the context

```bash title="Node 2"
context identity ls -c {contextId}
```

```bash title="Example"
context identity ls -c 567C5Gg4mxHMPKy2wLJ4uvb3DHsbcpVDYUsuAWgTPgXn
│ Identity                                     | Owned
│ 3yBQQvn2G8ghWk2ZwmLFYxJQgM1YmDtiigi84nGpZBb9 | *
│ DaSkad6DK7f6fUhjz1CvNW7L4TkWZmWqAcwysZHG3Xs5 |
```

![Context Identity List](/cli/6-identity-list.png)

---

## Key-Value Store tutorial

## Building a Key-Value Store with Calimero SDK

The Calimero SDK for Rust empowers developers to build applications that compile
to WebAssembly (Wasm) and run securely within the Calimero virtual machine. This
guide will walk you through creating a complete key-value store application and
preparing it for deployment.

### Prerequisites

Before you begin, ensure you have Rust installed on your system. If not, follow
the official Rust installation guide for your platform:
[Rust Installation Guide](https://www.rust-lang.org/tools/install).

You should ensure you have the `wasm32-unknown-unknown` target installed. Run
the following command in your terminal to install the target:

```bash title="Terminal"
rustup target add wasm32-unknown-unknown
```

### Setting Up Your Project

To create a new project, initialize a Rust library project using Cargo. Run the
following command in your terminal:

```bash title="Terminal"
cargo new --lib kv-store
```

You should have a tree that looks like this:

```bash title="Terminal"
$ tree kv-store
kv-store
├── Cargo.toml
└── src
    └── lib.rs

2 directories, 2 files
```

At this point, we can `cd` into the `kv-store` directory:

```bash title="Terminal"
cd kv-store
```

Next, you need to specify the crate-type as `cdylib` in your `Cargo.toml` file
to generate a dynamic library that can be compiled to Wasm:

```toml title="File: Cargo.toml"
[lib]
crate-type = ["cdylib"]
```

You can now configure your project to use the Calimero SDK by adding it as a
dependency in your `Cargo.toml` file:

```toml title="File: Cargo.toml"
[dependencies]
calimero-sdk = { git = "https://github.com/calimero-network/core" }
calimero-storage = { git = "https://github.com/calimero-network/core" }
```

Then, we need to specify a custom build profile for the most compact Wasm
output:

```toml title="File: Cargo.toml"
[profile.app-release]
inherits = "release"
codegen-units = 1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true
```

 Your `Cargo.toml` file should now look like this 

```toml title="File: Cargo.toml" showLineNumbers
[package]
name = "kv-store"
version = "0.1.0"
edition = "2021"

# highlight-start
[lib]
crate-type = ["cdylib"]
# highlight-end

# highlight-start
[dependencies]
calimero-sdk = { git = "https://github.com/calimero-network/core" }
calimero-storage = { git = "https://github.com/calimero-network/core" }
# highlight-end

# highlight-start
[profile.app-release]
inherits = "release"
codegen-units = 1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true
# highlight-end
```

And finally, create a `build.sh` script to compile your application into Wasm
format, for example:

```bash title="File: build.sh" showLineNumbers
#!/bin/bash
set -e

cd "$(dirname $0)"

TARGET="${CARGO_TARGET_DIR:-../../target}"

rustup target add wasm32-unknown-unknown

cargo build --target wasm32-unknown-unknown --profile app-release

mkdir -p res

cp $TARGET/wasm32-unknown-unknown/app-release/kv_store.wasm ./res/
```

You can optionally choose to install and use
[`wasm-opt`](https://github.com/WebAssembly/binaryen), for an additional
optimization step in the build script. This step is not required but can help
reduce the size of the generated Wasm file:

```bash title="File: build.sh"
if command -v wasm-opt > /dev/null; then
  wasm-opt -Oz ./res/kv_store.wasm -o ./res/kv_store.wasm
fi
```

Don't forget to make the `build.sh` script executable:

```bash title="Terminal"
chmod +x build.sh
```

At this point, your project structure should look like this:

```bash title="Terminal"
$ tree
.
├── Cargo.toml
├── build.sh
└── src
    └── lib.rs

2 directories, 3 files
```

### Writing Your Application

Now, let's create a simple key-value store application using the Calimero SDK.
Start by defining your application logic in `lib.rs`:

```rust title="File: src/lib.rs" showLineNumbers
use calimero_sdk::borsh::{BorshDeserialize, BorshSerialize};
use calimero_sdk::app;

#[app::state]
#[derive(Default, BorshSerialize, BorshDeserialize)]
#[borsh(crate = "calimero_sdk::borsh")]
struct KvStore {}

#[app::logic]
impl KvStore {
    #[app::init]
    pub fn init() -> KvStore {
        KvStore {}
    }
}
```

The `KvStore` struct represents the state of your application, which will be
borsh-encoded in the app-scoped state partition on the node's storage. The
`#[app::state]` attribute macro marks the struct as the application state,
permitting its use by Calimero SDK.

The `#[app::logic]` attribute macro marks the implementation block as the
application logic, allowing you to define the methods that interact with the
application state. An initializer method (named `init`) is denoted by the
`#[app::init]` attribute macro, which is called when the application is executed
against a freshly created context.

Consider a method like `get` that retrieves a value from the key-value store:

```rust
pub fn get(&self, key: &str) -> Result, Error> {
    // Snip...
}
```

The inputs must be deserializable from the transaction data, and the output must
be serializable to the response data. The `Option` type is used to represent the
possibility of the key not being present in the store. The `Error` type is used
to represent the possible error conditions that may occur during the execution
of the method.

And now, here's a complete example of a key-value store application:

```rust title="File: src/lib.rs" showLineNumbers
use calimero_sdk::borsh::{BorshDeserialize, BorshSerialize};
use calimero_sdk::types::Error;
use calimero_sdk::{app, env};
use calimero_storage::collections::UnorderedMap;

#[app::state]
#[derive(Default, BorshSerialize, BorshDeserialize)]
#[borsh(crate = "calimero_sdk::borsh")]
struct KvStore {
    entries: UnorderedMap,
}

#[app::logic]
impl KvStore {
    #[app::init]
    pub fn init() -> KvStore {
        // highlight-start
        KvStore {
            items: UnorderedMap::new(),
        }
        // highlight-end
    }

    // highlight-start
    pub fn set(&mut self, key: String, value: String) -> Result {
        env::log(&format!("Setting key: {:?} to value: {:?}", key, value));

        self.entries.insert(key, value)?;

        Ok(())
    }
    // highlight-end

    // highlight-start
    pub fn entries(&self) -> Result, Error> {
        env::log("Getting all entries");

        Ok(self.items.entries()?.collect())
    }
    // highlight-end

    // highlight-start
    pub fn get(&self, key: &str) -> Result, Error> {
        env::log(&format!("Getting key: {:?}", key));

        self.items.get(key).map_err(Into::into)
    }
    // highlight-end

    // highlight-start
    pub fn remove(&mut self, key: &str) -> Result, Error> {
        env::log(&format!("Removing key: {:?}", key));

        self.items.remove(key).map_err(Into::into)
    }
    // highlight-end
}
```

### Building Your Application

Once your application logic is defined, run the `./build.sh` script to compile
your application into Wasm format. This script will generate `kv_store.wasm` in
the `res` folder of your application.

```bash title="Terminal"
$ ./build.sh
info: component 'rust-std' for target 'wasm32-unknown-unknown' is up to date
   # Snip...
   Compiling calimero-sdk v0.1.0
   Compiling calimero-storage v0.1.0
   Compiling kv-store v0.1.0 (/apps/kv-store)
    Finished `app-release` profile [optimized] target(s) in 1.20s

$ tree
.
├── Cargo.toml
├── build.sh
├── res
│   └── kv_store.wasm
└── src
    └── lib.rs

3 directories, 4 files
```

### Deploying Your Application

After successfully building your application, you can upload the compiled
`kv_store.wasm` to the registry for use by a live Calimero node.

### Writing Efficient Code with Calimero SDK

In the following code snippet:

```rust title="File: src/lib.rs"
pub fn get(&self, key: &str) -> Result, Error> {
    // Snip...
}
```

you'll notice that we prioritize using references instead of owned values. This
approach optimizes performance and memory usage by minimizing unnecessary data
copying.

For input parameters, such as `&str` and `&[u8]`, utilizing references allows
you to avoid unnecessary copying of data. Similarly, for output values, you can
return references to data that live as long as `&self` or any of the input
parameters. By doing so, you reduce memory overhead and improve the overall
efficiency of your application.

### Handling Errors with Calimero SDK

When designing methods that may potentially fail, it's recommended to return a
`Result` type with an error variant representing the possible failure cases.
This enables you to handle errors more effectively and communicate error
conditions to users of your application. This is recommended over using the
`Error` type exported from `calimero_sdk` and over panicking. Both of which only
return a string message.

#### Error Report Comparison

Let's take the following cases (all of which fail when the key does not exist);

1. Using `calimero_sdk::types::Error`:

   This is provided for convenience, since most errors already don't implement
   `Serialize`, and so they cannot be immediately returned. This first converts
   the error to a string and then returns it. Which then JSON-encodes the string
   representation.

   ```rust title="File: src/lib.rs"
   use calimero_sdk::types::Error;

   pub fn get(&self, key: &str) -> Result {
       self.items.get(key)?.ok_or_else(|| Error::msg("key not found"))
   }
   ```

   This failure will result in this outcome:

   ```rust
   ExecutionError([ 107, 75, 101, 121, 32, 110, 111, 116, 32, 102, 111, 117, 110, 100, 34 ])
   ```

   which can be decoded to

   ```json
   "key not found"
   ```

   This `Error` can be constructed with `?` so long as the source error
   implements `std::error::Error`.

   Behaviourally similar to
   [`anyhow::Error`](https://docs.rs/anyhow/latest/anyhow/struct.Error.html) or
   [`eyre::Report`](https://docs.rs/eyre/latest/eyre/struct.Report.html).

2. Using a custom error type (recommended):

   For structured error handling, we recommend defining a custom error type that
   encodes all the possible error variants for that method. This allows you to
   provide more context about the error condition and handle different error
   scenarios more effectively. As opposed to string parsing.

   ```rust title="File: src/lib.rs"
   use calimero_sdk::serde::Serialize;

   #[derive(Debug, Serialize)]
   #[serde(crate = "calimero_sdk::serde")]
   #[serde(tag = "kind", content = "data")]
   pub enum Error {
       NotFound(&'a str),
   }
   ```

   ```rust title="File: src/lib.rs"
   pub fn get(&self, key: &'a str) -> Result> {
       // Snip...
       Err(Error::NotFound(key))
   }
   ```

   This failure will result in this outcome:

   ```rust
   ExecutionError([ 123, 34, 107, 105, 110, 100, 34, 58, 34, 78, 111, 116, 70, 111, 117, 110, 100, 34, 44, 34, 100, 97, 116, 97, 34, 58, 34, 116, 104, 105, 110, 103, 34, 125 ])
   ```

   which can be decoded to

   ```json
   { "kind": "NotFound", "data": "thing" }
   ```

   As will most likely be the case, you may need to work with storage errors
   while you've defined a custom error type.

   In this case, you can pull in
   [`thiserror`](https://docs.rs/thiserror/latest/thiserror/) to help.

   ```rust title="File: src/lib.rs"
   use thiserror::Error;

   #[derive(Debug, Error, Serialize)]
   #[serde(crate = "calimero_sdk::serde")]
   #[serde(tag = "kind", content = "data")]
   pub enum Error {
       #[error("key not found: {0}")]
       NotFound(&'a str),
       #[error("store error: {0}")]
       StoreError(#[from] StoreError),
   }
   ```

   ```rust title="File: src/lib.rs"
   pub fn get(&self, key: &'a str) -> Result> {
       // Snip...
       self.items.get(key)?.ok_or_else(|| Error::NotFound(key))
   }
   ```

   An example store error would then be represented as:

   ```rust
   ExecutionError(
       [
           123, 34, 107, 105, 110, 100, 34, 58, 34, 83, 116, 111, 114, 101, 69, 114, 114, 111, 114, 34, 44, 34, 100, 97, 116, 97, 34, 58,
           34, 73, 110, 100, 101, 120, 32, 110, 111, 116, 32, 102, 111, 117, 110, 100, 32, 102, 111, 114, 32, 73, 68, 58, 32, 57, 51, 49, 53,
           97, 98, 101, 49, 101, 97, 101, 48, 102, 102, 53, 98, 48, 48, 52, 53, 51, 97, 100, 97, 102, 99, 99, 53, 102, 101, 102, 50, 49, 100,
           55, 52, 49, 51, 57, 55, 101, 50, 49, 99, 53, 49, 53, 51, 55, 99, 51, 54, 52, 52, 50, 52, 50, 48, 56, 55, 52, 57, 99, 57, 34, 125,
       ],
   )
   ```

   which can be decoded to

   ```json
   {
     "kind": "StoreError",
     "data": "Index not found for ID: 9315abe1eae0ff5b00453adafcc5fef21d741397e21c51537c364424208749c9"
   }
   ```

3. Panic (ideally, development only)

   ```rust title="File: src/lib.rs"
   pub fn get(&self, key: &str) -> String {
       self.items.get(key).expect("store error").expect("key not found")
   }
   ```

   A non-existent key would then lead to this outcome:

   ```rust
   HostError(
       Panic {
           context: Guest,
           message: "key not found",
           location: At {
               file: "apps/kv-store/src/lib.rs",
               line: 98,
               column: 14,
           },
       },
   )
   ```

   And a storage error, would produce this:

   ```rust
   HostError(
       Panic {
           context: Guest,
           message: "store error: StorageError(IndexNotFound(Id { bytes: [123, 240, 135, 21, 77, 143, 81, 169, 15, 202, 99, 210, 167, 165, 188, 156, 87, 146, 7, 211, 100, 92, 169, 189, 124, 115, 200, 242, 240, 73, 68, 123] }))",
           location: At {
               file: "apps/kv-store/src/lib.rs",
               line: 98,
               column: 14,
           },
       },
   )
   ```

By following the second (recommended) approach, you can handle errors more
gracefully and provide meaningful feedback to users of your Calimero
application.

And the first approach, if you want a hassle-free method of dealing with errors.

### Emitting Events with Calimero SDK

To facilitate real-time monitoring of state transitions within your Calimero
application, you can emit events using the `app::emit!` macro provided by the
Calimero SDK. Event emission is particularly useful for handling live state
transitions triggered by other actors, allowing subscribed clients to receive
immediate updates about relevant actions.

Let's focus on emitting events for mutating calls, specifically `set` and
`remove` methods:

First, define your custom events using the `#[app::event]` proc macro. In this
example, we'll define events for setting a new key-value pair (`Inserted`),
updating an existing value (`Updated`), and removing a key-value pair
(`Removed`):

```rust title="File: src/lib.rs"
use calimero_sdk::app;

#[app::event]
pub enum Event {
    Inserted { key: &'a str, value: &'a str },
    Updated { key: &'a str, value: &'a str },
    Removed { key: &'a str },
}
```

Each event variant can carry additional data to provide context about the event.

Now, you need to associate the event with the application logic by annotating
the application state.

```rust title="File: src/lib.rs"
// highlight-start
#[app::state(emits = for Event)]
// highlight-end
#[derive(Default, BorshSerialize, BorshDeserialize)]
#[borsh(crate = "calimero_sdk::borsh")]
struct KvStore {
    // Snip...
}
```

And finally, within your application logic methods, emit events using the
`app::emit!` macro:

```rust title="File: src/lib.rs"
pub fn set(&mut self, key: String, value: String) -> Result {
    if self.items.contains(&key)? {
        app::emit!(Event::Updated {
            key: &key,
            value: &value,
        });
    } else {
        app::emit!(Event::Inserted {
            key: &key,
            value: &value,
        });
    }

    self.items.insert(key, value)?;

    Ok(())
}

pub fn remove(&mut self, key: &str) -> Result {
    app::emit!(Event::Removed { key });

    self.entries.remove(key)?.ok_or_else(|| Error::msg("key not found"))
}
```

In each method, we emit the corresponding event with relevant data. This allows
external observers to react to these events and take appropriate actions.

By emitting events, you can ensure connected clients receive real-time updates
about state transitions within your Calimero application, enabling them to
respond to changes as they occur.

### Ensuring Atomicity and Event Reliability in Calimero Applications

In Calimero applications, ensuring atomicity of state changes and reliability of
event emission is crucial for maintaining data consistency and facilitating
reliable communication between actors. Here's how atomicity and event
reliability are enforced:

#### Atomic State Changes

When a method call fails, whether due to panics or returning an `Err`, all state
changes made up to that point are discarded. This ensures that if an operation
cannot be completed successfully, the application's state remains consistent and
unaffected by partial updates. By enforcing atomicity, Calimero promotes data
integrity and prevents inconsistencies that may arise from incomplete
transactions.

#### Reliable Event Emission

Similarly, event emission in Calimero applications is tied to the successful
execution of transactions. Events are only relayed when a transaction has been
successfully executed, ensuring that external observers receive updates about
state changes reliably. By linking event emission to transaction execution,
Calimero guarantees that event notifications accurately reflect the
application's current state, enhancing the reliability and consistency of
communication between actors.

This also means it doesn't matter if the event emission is done before or after
the state change, as the event will only be emitted if the state change is
successful.

By adhering to these principles of atomicity and event reliability, Calimero
applications maintain data integrity and enable robust interaction between
different components, facilitating the development of secure and dependable
decentralized systems.

### Local-First Efficiency

Read-only operations (like `get`) have no network overhead, as they don't modify
state and can be executed locally.

### Conclusion

You've now learned how to set up a Rust project using the Calimero SDK, write a
simple application, build it into Wasm, and prepare it for deployment.
Experiment with different features and functionalities to create powerful and
secure applications with Calimero.

Happy coding! 🚀

---

## Publish App

After you have built your application, you can publish it to the network. This
will make it available for users to interact with.

## Publishing application

Navigate to [Admin Dashboard](../developer-tools/apps/admin-dashboard) and
select `Applications` tab.

![Publish application](/admin-dashboard/publish-new-application.png)

Enter the required data and publish the application. After publishing, your
application will be available for users to interact with in new contexts.

## Application preview

Good practice allows users to try an app before they decide to use it. You can
deploy an app to any host provider.

We have used GitHub Pages to preview our [example app](./install-application).
You can do the same by following the steps below.

## Example app preview

First you need to enable GitHub Pages by following
[Creating a GitHub Pages](https://docs.github.com/en/pages/getting-started-with-github-pages/creating-a-github-pages-site)

Our example app is written in next.js and code is available in
[only-peers-client](https://github.com/calimero-network/only-peers-client) After
enabling GitHub Pages, a few changes are required in your next.js app.
`next.config.mjs` should contain output: "export" field

GitHub Actions is a platform used to automate the deployment process. You can
find example in
[github workflow](https://github.com/calimero-network/only-peers-client/tree/master/.github/workflows)

---

## Install application

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

We have created simple and easy to use example application called `only-peers`.
Application enables writing posts and leaving comments. To try out application
you need to create new context where application will be installed.

### Create new context

To create new context, node CLI has to be used.

If the node doesn't have application installed, you need to install the
application first. If the application is already installed, you can skip this
step.

```bash
meroctl --node node1 app install --path /path/to/app
```

:::note

If you want to install an application that is published in the registry, check
`meroctl --node node1 app install -h` for options

:::

After the application is installed, you can create new context:

```bash title="Terminal"
meroctl --node node1 context create --application-id  --protocol near
```

```bash title="Terminal"
meroctl --node node1 context create --application-id  --protocol starknet
```

```bash title="Terminal"
meroctl --node node1 context create --application-id  --protocol icp
```

```bash title="Terminal"
meroctl --node node1 context create --application-id  --protocol stellar
```

```bash title="Terminal"
meroctl --node node1 context create --application-id  --protocol ethereum
```

You are now part of the context and can start using the application.

### Try out Only-peers application

We have built and deployed a demo app so you can try it out immediately.

Navigate to https://calimero-network.github.io/only-peers-client/ to access app
frontend.

You will be asked to setup the app by the adding the node url. It is the same
url you used while starting the node in
[Getting-started](../getting-started/setup) `http://localhost:NODE_PORT` After
setting up node url, you will be asked to login.

> **_NOTE:_** Use your wallet which you have already added as root key in
> [Admin Dashboard](../developer-tools/apps/admin-dashboard)

You are now ready to use the app. Enjoy!

---

## Only Peers

Only Peers is a decentralized social networking app that empowers you to share
your thoughts and engage with your community without compromising your privacy.
It allows you to write posts, leave comments, and interact with friends.
However, unlike traditional social networks, Only Peers ensures your data
remains under your control, protected from central authorities and prying eyes.
Experience the freedom of a decentralized platform where your voice cannot be
censored and your privacy is prioritized. Explore the source code on
[GitHub repository](https://github.com/calimero-network/only-peers-client).

---

## Private DAO

An example application that connects to Calimero Proxy Contract and allows
creating proposals, voting on them, and executing the approved proposals.

```mermaid
graph TD
A[Application] -->|Connects to| B[Calimero Proxy Contract]
B -->|Handles| C[Proposals]
C -->|Create| D[New Proposals]
C -->|Approve| E[Proposal Voting]
C -->|Delete| J[Delete Proposal]
E -->|Check Votes| F{Required Votes Met?}
F -->|Yes| G[Execute Proposal]
G -->|Perform Actions| H[Blockchain Operations]
F -->|No| I[Store Vote Count]
```

Full source code is available in our GitHub
[repository](https://github.com/calimero-network/demo-blockchain-integrations).

---

## Building with Internet Computer (ICP)

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Building with Internet Computer (ICP)

Step-by-Step Guide to Building an Application for Calimero with Internet
Computer (ICP)

This tutorial will cover the following topics:

1. **Starting a Local Devnet** - Setting and configuring a local devnet using
   dfx through a script.

2. **Configuring Nodes** - Setting and configuring nodes, installing demo
   application, creating context and inviting nodes into the context.

3. **Installing a Blockchain Demo Application** - Setup demo application that
   contains all functionalities for interaction with smart contracts.

4. **Creating a Proposal** - Creating a proposal to execute cross-contract call
   to "Greet" smart contract deployed in step 3.

:::note

For easier guidance, we have named each terminal block by their purpose.

:::

## Requirements

To follow this tutorial, you'll need the following:

- Calimero ICP Devnet -
  [Repository](https://github.com/calimero-network/icp-devnet)
- Calimero Core - Installation instructions -
  [Instructions](/getting-started/packaged#installation)
- Demo Blockchain Integrations -
  [Repository](https://github.com/calimero-network/demo-blockchain-integrations)

You also need following tools:

- **Cargo**: Version `1.86.0-nightly` used for tutorial -
  [url](https://www.rust-lang.org/tools/install)
- **DFX** (Dfinity SDK): Version `0.24.3` used for tutorial -
  [url](https://internetcomputer.org/docs/current/developer-docs/getting-started/install)
- **Candid Extractor**: Version `0.1.5` used for tutorial -
  [url](https://crates.io/crates/candid-extractor)
- **Pnpm**: Version `9.6.0` used for tutorial -
  [url](https://pnpm.io/installation)

## Configuring a Local Devnet

We have prepared a script that will deploy the contracts and create needed
accounts on local environment. The script does the following:

- Creates accounts needed for ledger deployment.
- Deploys the context, ledger and example external contract.
- Funds the deployed context contract for initial usage.
- Calls required initial methods on deployed contracts.

Scripts are located in Calimero ICP Devnet repository. First clone the
[repository](https://github.com/calimero-network/icp-devnet).

```bash title="ICP Setup Terminal"
git clone https://github.com/calimero-network/icp-devnet

cd icp-devnet

chmod +x ./deploy_devnet_addon.sh

```

The repository contains two scripts:

  `deploy_devnet_fresh.sh` - Starts fresh dfx environment and deploys the contracts and needed accounts.
  :::caution
  This script will delete the current dfx environment and create a new one.
  :::

  `deploy_devnet_addon.sh` - Deploys the contracts and creates needed account on already existing dfx environment.

:::note

dfx environment needs to be started before running this script.

:::

For this tutorial we will be using `deploy_devnet_fresh.sh` script.

```bash title="ICP Setup Terminal"
./deploy_devnet_fresh.sh
```

```bash title="ICP Setup Terminal | Output of successful deployment"
=== Deployment Summary ===
Context Contract ID: bkyz2-fmaaa-aaaaa-qaaaq-cai
Ledger Contract ID: bd3sg-teaaa-aaaaa-qaaba-cai
Demo External Contract ID: be2us-64aaa-aaaaa-qaabq-cai

Account Information:
Minting Account: 8b768d662eeebfcbe55b180a7ac0ccb46e2ccd59cacd0b4ec3404f0c8d8b8086
Initial Account: 670183527b941adeae9e1552525853af7812d9441758c668b2e3b8553dead7a0
Archive Principal: kbwrg-ggsyr-4zl47-3z7by-owf4g-draak-xj2ni-mcvwv-6wqxc-nkjam-gae
Recipient Principal: mfefj-dsyoh-rb3b2-3yagk-rvb2p-wcb2v-fhu2n-fel2f-wqzjn-yhtxx-hqe

Deployment completed successfully!
```

:::note

Leave this terminal open as you will need values in later steps.

:::

## Context and Proxy Contract

### Context contract

Calimero context contract is used to create and manage contexts and their
members.

More information about context contract can be found
[here](/core-concepts/blockchains-integration#context-contract). To see the
context contract implementation, refer to the
[calimero-network/core](https://github.com/calimero-network/core/tree/master/contracts/icp/context-config)
repository.

### Proxy contract

Proxy contract is used to handle blockchain operations such as cross-contract
calls and trasnfers as well as storing variables.

More information about proxy contract can be found
[here](/core-concepts/blockchains-integration#functionality-details). To see the
proxy contract implementation, refer to the
[calimero-network/core](https://github.com/calimero-network/core/tree/master/contracts/icp/context-proxy)
repository. ## Setting up and configuring nodes

:::info

By deafult proposal needs 3 approvals before it is executed so we will setup 3
nodes.

:::

- Initialize and start 3 nodes
- Install
  [blockchain demo application](https://github.com/calimero-network/demo-blockchain-integrations/tree/master/logic)
- Create context for blockchain demo application
- Invite all nodes in the same context

#### Initialize and Start Nodes

Open 3 terminals side by side.

```bash title="Node1 Terminal"
merod --node-name node1 init --server-port 2427 --swarm-port 2527
```

```bash title="Node2 Terminal"
merod --node-name node2 init --server-port 2428 --swarm-port 2528
```

```bash title="Node3 Terminal"
merod --node-name node3 init --server-port 2429 --swarm-port 2529
```

The output should look like this:

You can verify nodes initialization files by looking into `~/.calimero` folder.

More on node initialization can be found [here](/getting-started/setup/).

Now we are going to start the nodes with the commands:

```bash title="Node1 Terminal"
merod --node-name node1 run
```

```bash title="Node2 Terminal"
merod --node-name node2 run
```

```bash title="Node3 Terminal"
merod --node-name node3 run
```

After running the nodes you should see the similar to this one:

#### Install application

Inside the node1 terminal we are going to install blockchain demo application.

1. Clone the
   [Demo Blockchain Integrations](https://github.com/calimero-network/demo-blockchain-integrations)
   repository.
2. Navigate to the `logic` directory.
3. Build the application using the `build.sh` script, script will compile wasm
   file in /res directory.
4. Copy the `blockchain.wasm` file path

Applications are installed with the following command:

```bash title="Node1 Terminal"
application install file 
>Installed application: 
```

After installing the application we can create context:

```bash title="Node1 Terminal"
context create  --protocol icp
>Created context  with identity 
```

After creating context we need to add node2 and node3 to it.

 To be able to do that we need to create identities for node2 and node3
with whom they will join to the created context.

```bash title="Node2 Terminal"
identity new
>> Private key: 
>> Public key: 
```

```bash title="Node3 Terminal"
identity new
>> Private key: 
>> Public key: 
```

The output should look like this:

After creating identities we can invite node2 and node3 to join the created
context.

```bash title="Node1 Terminal"
context invite   --as 
>> Invitation payload: 
```

This will generate a invitation payload which can node2 use to join the context.
Copy the invitation payload and do the following command in node2 terminal:

```bash title="Node2 Terminal"
context join  
>> Joined context 
```

Repeat the same steps for Node3.

```bash title="Node1 Terminal"
context invite   --as 
```

```bash title="Node3 Terminal"
context join  
>> Joined context 
```

The output in terminal after inviting and joining nodes should look like this:

More on invitations and joining the context can be found
[here](https://calimero-network.github.io/tutorials/invitations-and-joinings)

Lastly we can check if all nodes are connected in context with:

```bash title="Node1 Terminal"
context ls
> 
```

```bash title="Node1 Terminal"
identity ls 
```

We can see there are 3 nodes connected in context.

#### Fund Proxy Contract

We have now installed the application and created context. To be able to fully
use proxy contract we need to fund it. To get proxy contract address we need to
use API GET call to retrieve it from the node.

The 3 running nodes are located on:

- https://localhost:2427
- https://localhost:2428
- https://localhost:2429.

Any of them can be queried to get the value of proxy contract id.

API endpoint to fetch proxy contract id is:
`http://localhost:2428/admin-api/contexts/CONTEXT_ID/proxy-contract`

> CONTEXT_ID can be copied from previous steps

And for our case it is:
`http://localhost:2428/admin-api/contexts/7krojDziAKRWP8KrUD8aYGL3z5peScNxPXaBWTKCFr2h/proxy-contract`

Example of request in postman:

With proxy contract id we can now fund it using dfx native commands. Reopen the
terminal you used to execute devnet deployment script and do the following
commands:

Switch to initial identity.

```bash title="ICP Setup Terminal Terminal"
dfx identity use initial
>Using identity: "initial".
```

To fund the contract we are going to use command:

```bash
dfx canister call  icrc1_transfer '(
  record {
    to = record {
      owner = principal "";
      subaccount = null;
    };
    amount = 1_000_000_000;
    fee = null;
    memo = null;
    from_subaccount = null;
    created_at_time = null;
  }
)'
```

> LEDGER_CONTRACT_ID - this value can be viewed when ./deploy_devnet.sh script
> finishes.
>
>  In our case value its: `bd3sg-teaaa-aaaaa-qaaba-cai`
>
> PROXY_CONTRACT_ID - value we got in previous step.
>
>  In our case value its: `b77ix-eeaaa-aaaaa-qaada-cai`

```bash title="ICP Setup Terminal Terminal"
dfx canister call bd3sg-teaaa-aaaaa-qaaba-cai icrc1_transfer '(
  record {
    to = record {
      owner = principal "b77ix-eeaaa-aaaaa-qaada-cai";
      subaccount = null;
    };
    amount = 1_000_000_000;
    fee = null;
    memo = null;
    from_subaccount = null;
    created_at_time = null;
  }
)'
> (variant { Ok = 1 : nat })
```

And verify the contract balance:

```bash title="ICP Setup Terminal Terminal"
dfx canister call bd3sg-teaaa-aaaaa-qaaba-cai icrc1_balance_of '(
  record {
    owner = principal "b77ix-eeaaa-aaaaa-qaada-cai";
    subaccount = null;
  }
)'
> (1_000_000_000 : nat)
```

## Blockchain Demo Application

This application is used to demonstrate how to interact with Calimero Proxy
contract through creating, approving and executing proposals.

The proxy contract supports the following types of proposals:

- **External function call** - Enables cross-contract call execution.
- **Transfer** - Allows transferring funds.
- **Set approval threshold** - Specifies the number of approvals required for
  proposal execution.
- **Set active proposal limit** - Defines the maximum number of active
  proposals.
- **Set context variables** - Allows setting key-value pairs for context
  variables.

While the demo focuses on specific functionality, you can customize the
application to suit your needs. Instead of building a complete frontend, this
demo serves as a foundation that you can extend to create a fully-featured
frontend application tailored to your requirements.

Navigate to frontend directory and install dependencies.

```bash title="Terminal"
cd demo-blockchain-integrations/app && pnpm install
```

Since we have 3 nodes we will need to setup frontend for each of them. Open 3
terminals side by side and run the following commands in each of them from /app
directory:

```bash title="Terminal 1 | Terminal 2 | Terminal 3"
pnpm run dev
```

After running the frontend you should see the following output in each of the
terminals:

Open the applications in by clicking on the link in each of the terminals and
you will see form with input fields for node URL and application ID.

To get application ID you can use following command from any of node terminals:

```bash title="Node1 Terminal"
application ls
> 
```

The node URL of the nodes are respectively:

- http://localhost:2427
- http://localhost:2428
- http://localhost:2429

After submitting the form you will be redirected to admin dashboard where you
will see the login page with wallet selector.

Select a wallet you wish to login with and afterwards you will be prompted to
select the context and context identity you wish to use.

After selecting both you will be logged in and automatically redirected to the
application.

### Change Approval Threshold Proposal

First we are going to create an approval threshold change proposal so future
proposals can be executed by only 1 node. As mentioned earlier each proposal by
default needs 3 approvals to be executed.

1. Click on "Create Proposal" button and select "Change number of approvals
   needed" from dropdown.
2. In the input field set the number of approvals to 1 (this means that proposal
   will be executed on creation).
3. Click on "Create Proposal" button to create the proposal.

After proposal is created you will get the alert that proposal is created and it
will be shown in other frontend applications by selecting it in select field.

After selecting proposal on other frontend applications (node2 and node3) you
can see that it is created and can be approved by clicking on "Approve Proposal"
button.

### Cross-Contract Call Proposal

At this point proposal approval threshold is 1, meaning proposal will be
executed on creation. This means when we create cross-contract call proposal it
will insantly be executed.

We have created a demo external contract that contains following methods:

- **test_method_no_transfer** - This method does not require a deposit for
  execution, it sets sent arguments in its storage.
- **test_method** - This method requires a deposit for execution, it first
  transfers the funds to the contract from proxy contract and then sets sent
  arguments in its storage, if the transfer is completed successfully.
- **get_calls** - This method returns all calls stored in the contract.
- **clear_state** - This method clears the storage of the contract.

You can see the contract itself and its implementation
[here](https://github.com/calimero-network/core/tree/master/contracts/icp/context-proxy/mock/external).

When creating cross-contract call proposal we need to provide following values:

- **Contract ID**: br5f7-7uaaa-aaaaa-qaaca-cai - Address of the external
  contract - shown in terminal output of dfx deployment script for demo external
  contract
- **Method Name**: test_method_no_transfer - Name of the method that will be
  called
- **Deposit**: 0 - Deposit for transfer, in this case we are not transferring
  any funds so we can set it to 0
- **Arguments**: someKey: someValue - Key and value pairs for arguments that are
  sent to the external contract

After we create proposal it will be executed, and the success of the execution
can be checked by running following command in terminal:

```bash title="DFX terminal"
dfx canister call  get_calls
```

:::caution

It's important to note that in this tutorial, we use a function call that does
not require a deposit for execution.

On the other hand, there are examples where cross-contract calls require a
deposit. For instance, in the case of an ERC20 token implementation, the
following steps typically occur:

1. The contract detects that an attached deposit is present.
2. It calls the deployed ledger contract to enable the external contract (the
   contract being called) to withdraw funds. Before doing so, it sets the
   allowance to 0 to prevent vulnerabilities related to the Attack Vector.
3. It then calls the ledger contract again to set the allowance equal to the
   deposit attached to the call.
4. The external contract is called, and it must contain logic to withdraw the
   funds that have been allocated for it in the ledger contract.
5. After the cross-contract call is completed, the proxy contract sets the
   allowance back to 0 to ensure security.

:::

## Conclusion

This tutorial has covered all the essential steps developers need to build an
application for Calimero and ICP, from setting up the environment to deploying a
fully functional smart contract. By following this guide, you should now have a
solid understanding of the development workflow and how to build your own ICP
application for Calimero.

Feel free to use our demo applications as a starting point to build and
customize your own application. If you have any questions or need assistance,
don't hesitate to reach out to us on Socials. We're here to help!

---

## Building with Stellar

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Building with Stellar

Step-by-Step Guide to Building an Application for Calimero with Stellar

This tutorial will cover the following topics:

1. **Smart contract overview** - Overview of the smart contracts and their
   functionality.

2. **Configuring Nodes** - Setting and configuring nodes, installing demo
   application, creating context and inviting nodes into the context.

3. **Installing a Blockchain Demo Application** - Setup demo application that
   contains all functionalities for interaction with smart contracts.

4. **Creating a Proposal** - Creating a proposal to execute cross-contract call
   to "Greet" smart contract deployed in step 3.

:::note

For easier guidance, we have named each terminal block by their purpose.

:::

## Requirements

To follow this tutorial, you'll need the following:

- Calimero Core - Installation instructions -
  [Instructions](/getting-started/packaged#installation)
- Demo Blockchain Integrations -
  [Repository](https://github.com/calimero-network/demo-blockchain-integrations)

You also need following tools:

- **Cargo**: Version `1.86.0-nightly` used for tutorial -
  [url](https://www.rust-lang.org/tools/install)
- **Pnpm**: Version `9.6.0` used for tutorial -
  [url](https://pnpm.io/installation)
- **Stellar CLI** - Installation instructions -
  [Instructions](https://developers.stellar.org/docs/build/smart-contracts/getting-started/setup#install-the-stellar-cli)

## Smart contract overview

### Contracts overview

Both contracts are written in Rust, you can find their implementations in the
following repositories:

- [Context contract](https://github.com/calimero-network/core/tree/master/contracts/stellar/context-config)
- [Proxy contract](https://github.com/calimero-network/core/tree/master/contracts/stellar/context-proxy)

## Context and Proxy Contract

### Context contract

Context contract is deployed on Stellar testnet and implemented into Calimero.
It is used to create and manage contexts and their members.

More information about context contract can be found
[here](/core-concepts/blockchains-integration#context-contract).

### Proxy contract

With each context creation a proxy contract for that context is deployed. Proxy
contract is used to handle blockchain operations such as cross-contract calls
and transfers as well as storing variables.

More information about proxy contract can be found
[here](/core-concepts/blockchains-integration#functionality-details).

## Setting up and configuring nodes

:::info

By deafult proposal needs 3 approvals before it is executed so we will setup 3
nodes.

:::

- Initialize and start 3 nodes
- Install
  [blockchain demo application](https://github.com/calimero-network/demo-blockchain-integrations/tree/master/logic)
- Create context for blockchain demo application
- Invite all nodes in the same context

#### Initialize and Start Nodes

Open 3 terminals side by side.

```bash title="Node1 Terminal"
merod --node-name node1 init --server-port 2427 --swarm-port 2527
```

```bash title="Node2 Terminal"
merod --node-name node2 init --server-port 2428 --swarm-port 2528
```

```bash title="Node3 Terminal"
merod --node-name node3 init --server-port 2429 --swarm-port 2529
```

The output should look like this:

You can verify nodes initialization files by looking into `~/.calimero` folder.

:::note Self signer vs. Relayer signer

In `config.toml` file you can see default configuration:

```
[context.config.stellar]
signer = "self"
protocol = "stellar"
network = "testnet"
contract_id = 
```

If you use `self` for signer then you also need to change `public` and `secret`
key.

```
[context.config.signer.self.stellar.testnet]
rpc_url = "https://soroban-testnet.stellar.org/"
public_key = 
secret_key = 
```

The values auto-generated only represent the format needed for self signing
feature and are not real Stellar accounts. To create your own Stellar account
with CLI follow the Stellar
[Docs](https://developers.stellar.org/docs/build/guides/cli)

If signer is changed to `signer = "relayer"` you don't need to changed anything
as relayer will handle all the blockchain operations.

:::

More on node initialization can be found [here](/getting-started/setup/).

Now we are going to start the nodes with the commands:

```bash title="Node1 Terminal"
merod --node-name node1 run
```

```bash title="Node2 Terminal"
merod --node-name node2 run
```

```bash title="Node3 Terminal"
merod --node-name node3 run
```

After running the nodes you should see the similar to this one:

#### Install application

Inside the node1 terminal we are going to install blockchain demo application.

1. Clone the
   [Demo Blockchain Integrations](https://github.com/calimero-network/demo-blockchain-integrations)
   repository.
2. Navigate to the `logic` directory.
3. Build the application using the `build.sh` script, script will compile wasm
   file in /res directory.
4. Copy the `blockchain.wasm` file path

Applications are installed with the following command:

```bash title="Node1 Terminal"
application install file 
>Installed application: 
```

After installing the application we can create context:

```bash title="Node1 Terminal"
context create  --protocol stellar
>Created context  with identity 
```

After creating context we need to add node2 and node3 to it.

 To be able to do that we need to create identities for node2 and node3
with whom they will join to the created context.

```bash title="Node2 Terminal"
identity new
>> Private key: 
>> Public key: 
```

```bash title="Node3 Terminal"
identity new
>> Private key: 
>> Public key: 
```

The output should look like this:

After creating identities we can invite node2 and node3 to join the created
context.

```bash title="Node1 Terminal"
context invite   --as 
>> Invitation payload: 
```

This will generate a invitation payload which can node2 use to join the context.
Copy the invitation payload and do the following command in node2 terminal:

```bash title="Node2 Terminal"
context join  
>> Joined context 
```

Repeat the same steps for Node3.

```bash title="Node1 Terminal"
context invite   --as 
```

```bash title="Node3 Terminal"
context join  
>> Joined context 
```

The output in terminal after inviting and joining nodes should look like this:

More on invitations and joining the context can be found
[here](https://calimero-network.github.io/tutorials/invitations-and-joinings)

Lastly we can check if all nodes are connected in context with:

```bash title="Node1 Terminal"
context ls
> 
```

```bash title="Node1 Terminal"
identity ls 
```

We can see there are 3 nodes connected in context.

#### Fund Proxy Contract

We have now installed the application and created context. To be able to fully
use proxy contract we need to fund it. To get proxy contract address we need to
use API GET call to retrieve it from the node.

The 3 running nodes are located on:

- https://localhost:2427
- https://localhost:2428
- https://localhost:2429.

Any of them can be queried to get the value of proxy contract id.

API endpoint to fetch proxy contract id is:
`http://localhost:2428/admin-api/contexts/CONTEXT_ID/proxy-contract`

> CONTEXT_ID can be copied from previous steps

And for our case it is:
`http://localhost:2428/admin-api/contexts/7krojDziAKRWP8KrUD8aYGL3z5peScNxPXaBWTKCFr2h/proxy-contract`

Example of request in postman:

With proxy contract id we can now fund it using Stellar CLI.

To be able to fund the contract we need to create a testnet account and seed it
with tokens.

You can create a testnet account and automatically fund it by using Stellar CLI:

```bash
stellar keys generate --global  --network testnet --fund
```

Where:

- `` is the name of the account you want to create.

To get the account address you can use the following command:

```bash
stellar keys address 
> 
```

Now you can fund the contract by using the following command:

```bash
stellar contract invoke \
  --id CDLZFC3SYJYDZT7K67VZ75HPJVIEUVNIXF47ZG2FB2RMQQVU2HHGCYSC \
  --source  \
  --network testnet \
  -- transfer \
  --from  \
  --to  \
  --amount 100000000
```

Where:

- `` is the name of the account for signing the transaction.
- `CDLZFC3SYJYDZT7K67VZ75HPJVIEUVNIXF47ZG2FB2RMQQVU2HHGCYSC` is the address of
  the Stellar testnet ledger contract.
- `` is the address of the account you created.
- `` is the address of the proxy contract you want to fund.
- `100000000` is the amount of lumens you want to fund the contract with. (1 XLM
  = 10000000)

To verify contract balance you can check it on Stellar Explorer by visiting:

`https://stellar.expert/explorer/testnet/contract/`

## Blockchain Demo Application

This application is used to demonstrate how to interact with Calimero Proxy
contract through creating, approving and executing proposals.

The proxy contract supports the following types of proposals:

- **External function call** - Enables cross-contract call execution.
- **Transfer** - Allows transferring funds.
- **Set approval threshold** - Specifies the number of approvals required for
  proposal execution.
- **Set active proposal limit** - Defines the maximum number of active
  proposals.
- **Set context variables** - Allows setting key-value pairs for context
  variables.

While the demo focuses on specific functionality, you can customize the
application to suit your needs. Instead of building a complete frontend, this
demo serves as a foundation that you can extend to create a fully-featured
frontend application tailored to your requirements.

Navigate to frontend directory and install dependencies.

```bash title="Terminal"
cd demo-blockchain-integrations/app && pnpm install
```

Since we have 3 nodes we will need to setup frontend for each of them. Open 3
terminals side by side and run the following commands in each of them from /app
directory:

```bash title="Terminal 1 | Terminal 2 | Terminal 3"
pnpm run dev
```

After running the frontend you should see the following output in each of the
terminals:

Open the applications in by clicking on the link in each of the terminals and
you will see form with input fields for node URL and application ID.

To get application ID you can use following command from any of node terminals:

```bash title="Node1 Terminal"
application ls
> 
```

The node URL of the nodes are respectively:

- http://localhost:2427
- http://localhost:2428
- http://localhost:2429

After submitting the form you will be redirected to admin dashboard where you
will see the login page with wallet selector.

Select a wallet you wish to login with and afterwards you will be prompted to
select the context and context identity you wish to use.

After selecting both you will be logged in and automatically redirected to the
application.

### Change Approval Threshold Proposal

First we are going to create an approval threshold change proposal so future
proposals can be executed by only 1 node. As mentioned earlier each proposal by
default needs 3 approvals to be executed.

1. Click on "Create Proposal" button and select "Change number of approvals
   needed" from dropdown.
2. In the input field set the number of approvals to 1 (this means that proposal
   will be executed on creation).
3. Click on "Create Proposal" button to create the proposal.

After proposal is created you will get the alert that proposal is created and it
will be shown in other frontend applications by selecting it in select field.

After selecting proposal on other frontend applications (node2 and node3) you
can see that it is created and can be approved by clicking on "Approve Proposal"
button.

### Cross-Contract Call Proposal

At this point proposal approval threshold is 1, meaning proposal will be
executed on creation. This means when we create cross-contract call proposal it
will instantly be executed.

We have created a `` and deployed it on Stellar
testnet.

Its address is:

```
CAJF5BPK4AT7UNVF4NDXMUXDKXCBFV56H2TNMUJIX6WUSNFP4UMH7W46
```

It contains following methods:

- **no_deposit** - This method does not require a deposit for execution, it sets
  sent arguments in its storage.
- **deposit** - This method requires a deposit for execution, it first transfers
  the funds to the contract from proxy contract and then sets sent arguments in
  its storage, if the transfer is completed successfully.
- **get_calls** - This method returns all calls stored in the contract.
- **clear_state** - This method clears the storage of the contract.

You can see the contract itself and its implementation
[here](https://github.com/calimero-network/core/tree/master/contracts/stellar/context-proxy/mock_external).

When creating cross-contract call proposal we need to provide following values:

- **Contract ID**: `{DEMO_EXTERNAL_CONTRACT_ID}` - Address of the external
  contract
- **Method Name**: `deposit` - Name of the contract method that will be called
- **Deposit**: 10000000 - Deposit for transfer (1 XLM)
- **Arguments**: The following arguments correspond to the deposit method
  parameters:

  | Type    | Value                 |
  | ------- | --------------------- |
  | address | `{PROXY_CONTRACT_ID}` |
  | i128    | 10000000              |
  | string  | testKEY               |
  | string  | testVALUE             |

Supported Soroban argument types:

- `i32` - 32-bit signed integer
- `u32` - 32-bit unsigned integer
- `i64` - 64-bit signed integer
- `u64` - 64-bit unsigned integer
- `i128` - 128-bit signed integer
- `u128` - 128-bit unsigned integer
- `bool` - Boolean value
- `string` - Text string
- `address` - Contract or account address
- `symbol` - Symbol value
- `bytes` - Byte array

After we create proposal it will be executed, and the success of the execution
can be checked calling demo external contract method **get_value** with Stellar
CLI:

```bash
stellar contract invoke \
  --id  \
  --network testnet \
  --source  \
  -- \
  get_value \
  --key "testKEY"
```

To check if transfer was successful we can use Stellar Explorer by visiting:

`https://stellar.expert/explorer/testnet/contract/`

There you will see the current funds attached to the contract.

:::caution

The implementation of cross-contract call with deposit is based on the following
steps:

1. The contract detects that an attached deposit is present.
2. It calls the ledger contract to enable the external contract (the contract
   being called) to withdraw funds.
3. The external contract is called, and it must contain logic to withdraw the
   funds that have been allocated for it in the ledger contract.
4. After the cross-contract call is completed, the proxy contract sets the
   allowance back to 0 to ensure security.

:::

## Conclusion

This tutorial has covered all the essential steps developers need to build an
application for Calimero and Stellar, from environment overview to deploying a
fully functional smart contract. By following this guide, you should now have a
solid understanding of the development workflow and how to build your own
Stellar application for Calimero.

Feel free to use our demo applications as a starting point to build and
customize your own application. If you have any questions or need assistance,
don't hesitate to reach out to us on Socials. We're here to help!

---

## Building with Ethereum

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Building with Ethereum

Step-by-Step Guide to Building an Application for Calimero with Ethereum

This tutorial will cover the following topics:

1. **Smart contract overview** - Overview of the smart contracts and their
   functionality.

2. **Configuring Nodes** - Setting and configuring nodes, installing demo
   application, creating context and inviting nodes into the context.

3. **Installing a Blockchain Demo Application** - Setup demo application that
   contains all functionalities for interaction with smart contracts.

4. **Creating a Proposal** - Creating a proposal to execute cross-contract call
   to an external smart contract deployed in step 3.

:::note

For easier guidance, we have named each terminal block by their purpose.

:::

## Requirements

To follow this tutorial, you'll need the following:

- Calimero Core - Installation instructions -
  [Instructions](/getting-started/packaged#installation)
- Demo Blockchain Integrations -
  [Repository](https://github.com/calimero-network/demo-blockchain-integrations)

You also need following tools:

- **Cargo**: Version `1.86.0-nightly` used for tutorial -
  [url](https://www.rust-lang.org/tools/install)
- **Pnpm**: Version `9.6.0` used for tutorial -
  [url](https://pnpm.io/installation)
- **Foundry**: For local Ethereum development -
  [Instructions](https://book.getfoundry.sh/getting-started/installation)

## Smart contract overview

### Contracts overview

Both contracts are written in Solidity, you can find their implementations in
the following repositories:

- [Context contract](https://github.com/calimero-network/contracts/tree/master/contracts/ethereum/context-config)
- [Proxy contract](https://github.com/calimero-network/contracts/tree/master/contracts/ethereum/context-proxy)

## Context and Proxy Contract

### Context contract

Context contract is deployed on Ethereum sepolia network and implemented into
Calimero. It is used to create and manage contexts and their members.

More information about context contract can be found
[here](/core-concepts/blockchains-integration#context-contract).

### Proxy contract

With each context creation a proxy contract for that context is deployed. Proxy
contract is used to handle blockchain operations such as cross-contract calls
and transfers as well as storing variables.

More information about proxy contract can be found
[here](/core-concepts/blockchains-integration#functionality-details).

## Setting up and configuring nodes

:::info

By deafult proposal needs 3 approvals before it is executed so we will setup 3
nodes.

:::

- Initialize and start 3 nodes
- Install
  [blockchain demo application](https://github.com/calimero-network/demo-blockchain-integrations/tree/master/logic)
- Create context for blockchain demo application
- Invite all nodes in the same context

#### Initialize and Start Nodes

Open 3 terminals side by side.

```bash title="Node1 Terminal"
merod --node-name node1 init --server-port 2427 --swarm-port 2527
```

```bash title="Node2 Terminal"
merod --node-name node2 init --server-port 2428 --swarm-port 2528
```

```bash title="Node3 Terminal"
merod --node-name node3 init --server-port 2429 --swarm-port 2529
```

The output should look like this:

You can verify nodes initialization files by looking into `~/.calimero` folder.

:::note Self signer vs. Relayer signer

In `config.toml` file you can see default configuration:

```
[context.config.ethereum]
signer = "relayer"
protocol = "ethereum"
network = "sepolia"
contract_id = 
```

If you use `self` for signer then you also need to change `public` and `secret`
key.

```
[context.config.signer.self.ethereum.testnet]
rpc_url = 
account_id = 
secret_key = 
```

The values auto-generated only represent the format needed for self signing
feature and are not real Ethereum accounts. To create your own Ethereum account
with CLI follow the Foundry
[Docs](https://book.getfoundry.sh/reference/cast/cast-wallet-new)

:::

More on node initialization can be found [here](/getting-started/setup/).

Now we are going to start the nodes with the commands:

```bash title="Node1 Terminal"
merod --node-name node1 run
```

```bash title="Node2 Terminal"
merod --node-name node2 run
```

```bash title="Node3 Terminal"
merod --node-name node3 run
```

After running the nodes you should see the similar to this one:

#### Install application

Inside the node1 terminal we are going to install blockchain demo application.

1. Clone the
   [Demo Blockchain Integrations](https://github.com/calimero-network/demo-blockchain-integrations)
   repository.
2. Navigate to the `logic` directory.
3. Build the application using the `build.sh` script, script will compile wasm
   file in /res directory.
4. Copy the `blockchain.wasm` file path

Applications are installed with the following command:

```bash title="Node1 Terminal"
application install file 
>Installed application: 
```

After installing the application we can create context:

```bash title="Node1 Terminal"
context create  --protocol ethereum
>Created context  with identity 
```

After creating context we need to add node2 and node3 to it.

 To be able to do that we need to create identities for node2 and node3
with whom they will join to the created context.

```bash title="Node2 Terminal"
identity new
>> Private key: 
>> Public key: 
```

```bash title="Node3 Terminal"
identity new
>> Private key: 
>> Public key: 
```

The output should look like this:

After creating identities we can invite node2 and node3 to join the created
context.

```bash title="Node1 Terminal"
context invite   --as 
>> Invitation payload: 
```

This will generate a invitation payload which can node2 use to join the context.
Copy the invitation payload and do the following command in node2 terminal:

```bash title="Node2 Terminal"
context join  
>> Joined context 
```

Repeat the same steps for Node3.

```bash title="Node1 Terminal"
context invite   --as 
```

```bash title="Node3 Terminal"
context join  
>> Joined context 
```

The output in terminal after inviting and joining nodes should look like this:

More on invitations and joining the context can be found
[here](https://calimero-network.github.io/tutorials/invitations-and-joinings)

Lastly we can check if all nodes are connected in context with:

```bash title="Node1 Terminal"
context ls
> 
```

```bash title="Node1 Terminal"
identity ls 
```

We can see there are 3 nodes connected in context.

#### Fund Proxy Contract

We have now installed the application and created context. To be able to fully
use proxy contract we need to fund it. To get proxy contract address we need to
use API GET call to retrieve it from the node.

The 3 running nodes are located on:

- https://localhost:2427
- https://localhost:2428
- https://localhost:2429.

Any of them can be queried to get the value of proxy contract id.

API endpoint to fetch proxy contract id is:
`http://localhost:2428/admin-api/contexts/CONTEXT_ID/proxy-contract`

> CONTEXT_ID can be copied from previous steps

And for our case it is:
`http://localhost:2428/admin-api/contexts/7krojDziAKRWP8KrUD8aYGL3z5peScNxPXaBWTKCFr2h/proxy-contract`

Example of request in postman:

Now you can fund the proxy contract by using the following command:

```bash
cast send \
  --value 1eth \
  --private-key  \
  
```

Where:

- `` is the account from which to transfer the funds.
- `` is the address of the proxy contract you want to fund.
- `1eth` is the amount of eth you want to fund the contract with.

For more information about transferring funds checkout this
[link](https://book.getfoundry.sh/reference/cast/cast-send) To verify contract
balance you can check it on Etherscan Explorer by visiting:

`https://sepolia.etherscan.io/address/`

## Blockchain Demo Application

This application is used to demonstrate how to interact with Calimero Proxy
contract through creating, approving and executing proposals.

The proxy contract supports the following types of proposals:

- **External function call** - Enables cross-contract call execution.
- **Transfer** - Allows transferring funds.
- **Set approval threshold** - Specifies the number of approvals required for
  proposal execution.
- **Set active proposal limit** - Defines the maximum number of active
  proposals.
- **Set context variables** - Allows setting key-value pairs for context
  variables.

While the demo focuses on specific functionality, you can customize the
application to suit your needs. Instead of building a complete frontend, this
demo serves as a foundation that you can extend to create a fully-featured
frontend application tailored to your requirements.

Navigate to frontend directory and install dependencies.

```bash title="Terminal"
cd demo-blockchain-integrations/app && pnpm install
```

Since we have 3 nodes we will need to setup frontend for each of them. Open 3
terminals side by side and run the following commands in each of them from /app
directory:

```bash title="Terminal 1 | Terminal 2 | Terminal 3"
pnpm run dev
```

After running the frontend you should see the following output in each of the
terminals:

Open the applications in by clicking on the link in each of the terminals and
you will see form with input fields for node URL and application ID.

To get application ID you can use following command from any of node terminals:

```bash title="Node1 Terminal"
application ls
> 
```

The node URL of the nodes are respectively:

- http://localhost:2427
- http://localhost:2428
- http://localhost:2429

After submitting the form you will be redirected to admin dashboard where you
will see the login page with wallet selector.

Select a wallet you wish to login with and afterwards you will be prompted to
select the context and context identity you wish to use.

After selecting both you will be logged in and automatically redirected to the
application.

### Change Approval Threshold Proposal

First we are going to create an approval threshold change proposal so future
proposals can be executed by only 1 node. As mentioned earlier each proposal by
default needs 3 approvals to be executed.

1. Click on "Create Proposal" button and select "Change number of approvals
   needed" from dropdown.
2. In the input field set the number of approvals to 1 (this means that proposal
   will be executed on creation).
3. Click on "Create Proposal" button to create the proposal.

After proposal is created you will get the alert that proposal is created and it
will be shown in other frontend applications by selecting it in select field.

After selecting proposal on other frontend applications (node2 and node3) you
can see that it is created and can be approved by clicking on "Approve Proposal"
button.

### Cross-Contract Call Proposal

At this point proposal approval threshold is 1, meaning proposal will be
executed on creation. This means when we create cross-contract call proposal it
will instantly be executed.

We have created a `` and deployed it on Ethereum
sepolia.

Its address is:

```
0x2c42DADf80b1a76Db4038027D7DB24863a9d0d5D
```

It contains following methods:

- **setValueNoDeposit** - This method does not require a deposit for execution,
  it sets sent arguments in its storage.
- **deposit** - This method requires a deposit for execution, it first transfers
  the funds to the contract from proxy contract and then sets sent arguments in
  its storage, if the transfer is completed successfully.
- **getValue** - This method returns all calls stored in the contract.

You can see the contract itself and its implementation
[here](https://github.com/calimero-network/calimero-evm-contracts/tree/master/context-proxy/mock).

When creating cross-contract call proposal we need to provide following values:

- **Contract ID**: `{DEMO_EXTERNAL_CONTRACT_ID}` - Address of the external
  contract
- **Method Name**: `deposit(string, string)` - Name of the contract method that
  will be called with arguments types
- **Deposit**: 10000000 - Deposit for transfer in WEI (10¹⁸ WEI = 1 ETH)
- **Arguments**: The following arguments correspond to the deposit method
  parameters:

  | Type   | Value     |
  | ------ | --------- |
  | string | testKEY   |
  | string | testVALUE |

Supported Ethereum argument types:

- `bool` - Boolean value, representing true or false.
- `string` - Text string, used for storing sequences of characters.
- `address` - Contract or account address, a 20-byte value used to identify
  accounts.
- `bytes` - Byte array, used for arbitrary-length binary data.
- `int256` - 256-bit signed integer, used for storing large integer values.
- `uint256` - 256-bit unsigned integer, used for storing large non-negative
  integer values.
- `array(bool)` - Array of boolean values.
- `array(string)` - Array of strings.
- `array(address)` - Array of addresses.
- `array(bytes)` - Array of byte arrays.
- `array(int256)` - Array of 256-bit signed integers.
- `array(uint256)` - Array of 256-bit unsigned integers.
- `tuple` - A fixed-size collection of values, which can be of different types.

These types are used to define the parameters and return values of smart
contract functions in Ethereum-based blockchains.

After we create proposal it will be executed, and the success of the execution
can be checked calling demo external contract method **get_value** with Forge
CLI:

```bash
cast call \
   \
  "getValue(string)" \
  "testKEY"
```

To check if transfer was successful we can use Etherscan Explorer by visiting:

`https://sepolia.etherscan.io/address/`

There you will see the current funds attached to the contract.

:::caution

The implementation of cross-contract call with deposit is based on the following
steps:

1. The contract detects that an attached deposit is present.
2. It calls the ledger contract to enable the external contract (the contract
   being called) to withdraw funds.
3. The external contract is called, and it must contain logic to withdraw the
   funds that have been allocated for it in the ledger contract.
4. After the cross-contract call is completed, the proxy contract sets the
   allowance back to 0 to ensure security.

:::

## Conclusion

This tutorial has covered all the essential steps developers need to build an
application for Calimero and Ethereum, from environment overview to deploying a
fully functional smart contract. By following this guide, you should now have a
solid understanding of the development workflow and how to build your own
Ethereum application for Calimero.

Feel free to use our demo applications as a starting point to build and
customize your own application. If you have any questions or need assistance,
don't hesitate to reach out to us on Socials. We're here to help!

---

## Rock Paper Scissors

A popular game we all know and love, but this time played online and enforcing
complete security using the commit - reveal scheme. After you pick your choice
of either rock, paper or scissors, you encrypt your choice with a password. This
ensures the other player can’t see your choice. After your opponent has also
decided, it is time to reveal your password and determine the winner. You cannot
change your mind between choosing and revealing because your choice is locked
with the special password. This prevents any bad actors from changing their
minds in the middle of the game.Have fun with a classic game that is completely
fair and private! Explore the source code on
[GitHub repository](https://github.com/calimero-network/rock-paper-scissors)

---

## Blockchain interaction with Proxy Contract

## Overview

The Calimero proxy contract enables cross-chain interactions through a
proposal-based system. The integration consists of:

1. Backend Application (Rust)
2. Frontend Application (TypeScript/React)

:::tip

More info on blockchain integrations can be found in the
[Blockchains Integration](../core-concepts/blockchains-integration) section.

:::

## Backend Implementation

The backend contract handles proposal creation and management. Here's the core
functionality:

```rust
#[app::logic]
impl AppState {
    pub fn create_new_proposal(&mut self, request: CreateProposalRequest) -> Result {
        // Implementation handles different types of proposals:
        // 1. ExternalFunctionCall
        // 2. Transfer
        // 3. SetContextValue
        // 4. SetNumApprovals
        // 5. SetActiveProposalsLimit
    }

    pub fn approve_proposal(&self, proposal_id: ProposalId) -> Result {
        Self::external().approve(proposal_id);
        env::emit(&Event::ApprovedProposal { id: proposal_id });
        Ok(())
    }
}
```

## API Types

Define your types for the integration:

```typescript
// types.ts
export enum ProposalActionType {
  ExternalFunctionCall = 'ExternalFunctionCall',
  Transfer = 'Transfer',
  SetNumApprovals = 'SetNumApprovals',
  SetActiveProposalsLimit = 'SetActiveProposalsLimit',
  SetContextValue = 'SetContextValue',
}

export interface CreateProposalRequest {
  action_type: ProposalActionType;
  params: {
    receiver_id?: string;
    method_name?: string;
    args?: string;
    deposit?: string;
    gas?: string;
    amount?: string;
    num_approvals?: number;
    active_proposals_limit?: number;
    key?: string;
    value?: string;
  };
}
```

## API Implementation

Create a data source to handle API calls:

```typescript
// LogicApiDataSource.ts
export class LogicApiDataSource implements ClientApi {
  async createProposal(
    request: CreateProposalRequest,
  ): ApiResponse {
    const params: RpcQueryParams = {
      contextId: getContextId(),
      method: ClientMethod.CREATE_PROPOSAL,
      argsJson: { request },
      executorPublicKey: jwtObject.executor_public_key,
    };

    return await getJsonRpcClient().execute(params, config);
  }

  async approveProposal(
    request: ApproveProposalRequest,
  ): ApiResponse {
    // Implementation
  }
}
```

## Creating Proposals

Here are examples of creating different types of proposals:

### 1. External Function Call

```typescript
const request: CreateProposalRequest = {
  action_type: 'ExternalFunctionCall',
  params: {
    receiver_id: 'contract.near',
    method_name: 'transfer',
    args: JSON.stringify({ amount: '100' }),
    deposit: '1000000000000000000000', // 1 NEAR
    gas: '30000000000000', // 30 TGas
  },
};
```

### 2. Token Transfer

```typescript
const request: CreateProposalRequest = {
  action_type: 'Transfer',
  params: {
    receiver_id: 'recipient.near',
    amount: '1000000000000000000000', // 1 NEAR
  },
};
```

### 3. Set Context Value

```typescript
const request: CreateProposalRequest = {
  action_type: 'SetContextValue',
  params: {
    key: 'my_key',
    value: 'my_value',
  },
};
```

### 4. Set Number of Approvals

```typescript
const request: CreateProposalRequest = {
  action_type: 'SetNumApprovals',
  params: {
    num_approvals: 3,
  },
};
```

### 5. Set Active Proposals Limit

```typescript
const request: CreateProposalRequest = {
  action_type: 'SetActiveProposalsLimit',
  params: {
    active_proposals_limit: 10,
  },
};
```

## Approving Proposals

To approve a proposal:

```typescript
const approvalRequest: ApproveProposalRequest = {
  proposal_id: 'proposal-id-here',
};

await logicApiDataSource.approveProposal(approvalRequest);
```

## Error Handling

The implementation includes comprehensive error handling:

```typescript
try {
  const result = await logicApiDataSource.createProposal(request);
  if (result?.error) {
    console.error('Error:', result.error);
    // Handle error appropriately
  }
} catch (error) {
  console.error('Unexpected error:', error);
  // Handle unexpected errors
}
```

## Best Practices

1. **Input Validation**

   - Validate all parameters before sending
   - Use appropriate types for amounts (strings for large numbers)
   - Format JSON strings properly

2. **Error Handling**

   - Implement proper error handling
   - Log important operations
   - Handle all possible error cases

3. **Gas Management**
   - Use appropriate gas limits
   - Default to 30 TGas for NEAR
   - Monitor gas usage

Need help? Join our [Discord](https://discord.gg/calimero) or check our
[GitHub](https://github.com/calimero-network/docs).

---

## The Data Sovereignty Manifesto

## Vision & Mission

We envision a digital world where users decide how and when their data is
stored, processed, and accessed. In such a future, individuals will be
compensated with a share of the profit, if they provide consent for their data
to be utilized by a specific entity for a specific context. Our framework will
ensure that data sharing is consensual, secure, and transparent, allowing users
to reclaim their privacy and digital autonomy.

In the digital age, the concept of privacy has evolved significantly.
Traditional notions of privacy, often centred around the control of personal
information, have been challenged by the pervasive nature of digital
technologies. In a world where your data flows freely across the internet, and
is processed by centralized servers, the control over your personal information
is often lost. A future dominated by AI, where your digital personalities can be
replicated and exploited, calls for urgent safeguarding of contextual integrity
and data privacy. We aim to empower individuals to take charge of their digital
identities.

Contextual integrity is a theory developed by Helen Nissenbaum, that suggests
privacy is preserved when information flows appropriately according to social
norms within specific contexts. Rather than focusing solely on the individual's
control over their data, contextual integrity considers the context-specific
norms that govern information sharing and usage. Different social settings or
spheres (e.g., healthcare, financial records, personal relationships and
similar), different actors, attributes and conditions under which information is
shared, each have their own expectations for information flow. By examining
these parameters, contextual integrity provides a nuanced understanding of
privacy that is sensitive to the specific social contexts in which information
is used.

The digital environment involves numerous actors, including users, service
providers, third-party advertisers, and data brokers. This complexity increases
the difficulty of tracking and managing information flows. Bad actors exploit
data streams, leading to breaches of privacy and trust. We believe that every
individual should have the power to control their personal data. Our mission is
to build a peer-to-peer ecosystem that enables users to dictate who they share
their data with and how data access is managed.

Digital platforms often merge multiple contexts, making it difficult to
distinguish appropriate information flows. For example, social media combines
personal, professional and public spheres, challenging traditional privacy
norms. Digital technologies enable the collection and analysis of vast amounts
of diverse data, often beyond what individuals explicitly share. This includes
metadata, behavioral data, and similar, which complicates consent and control
and often gives away much more about the user than the user actually understands
or wants to share. The principles governing data transmission in the digital
world are often non-transparent and dynamic. Terms of service and privacy
policies frequently change, and the mechanisms of data sharing and processing
are not always transparent to users.

## Rationale and Addressing the Problem

◦ Legal frameworks should consider the specific contexts in which data is used.
This means creating sector-specific privacy regulations that account for the
unique norms and expectations of each context.

◦ Digital platforms must be transparent about their data practices and
accountable for maintaining appropriate information flows. This includes clear
communication about how data is collected, used, and shared, as well as
mechanisms for users to hold platforms accountable.

◦ Empowering users with tools to manage their privacy in context-specific ways
is crucial. This can involve granular privacy settings, consent mechanisms that
reflect contextual norms, and educational initiatives to inform users about
their privacy rights and risks.

◦ Designers and developers of digital technologies should incorporate contextual
integrity principles into the design of systems and services. This means
considering the social contexts in which their technologies will be used and
ensuring that information flows align with context-specific norms.

◦ Regulators have tried to address this issue by implementing data protection
laws. However, in practice, there are no effective tools to solve the problem
easily, and the regulations are prone to human error. This results in
unnecessary bureaucracy, without solving the problem at its core.

## Core Values and Beliefs

**Privacy**

We believe that privacy is a fundamental human right.

**Ownership & Control**

Data should be owned and managed by the user whose data it is, not by large
corporations, big tech, or the government. Individuals should have complete
control over their digital footprint.

**Transparency & Security**

Data management processes must be transparent and understandable. Personal data
should be protected against unauthorized access and misuse.

## Goals and Objectives

The need for data sovereignty is urgent. Daily data breaches compromise medical
records, putting lives at risk, financial records are disclosed, leading to
theft, and personal secrets can be exposed without consent. In a world where
data is a valuable asset, it is essential to create a fair and secure
environment. Contextual integrity, which addresses data privacy in the digital
age, must be upheld to protect individual rights and foster trust in digital
interactions. Our goals include:

◦ Creating a robust, secure, and user-friendly peer-to-peer protocol for data
access control.

◦ Providing tools and resources to enable builders to develop Self Sovereign
Apps, where users can manage their data independently.

◦ Target developers to raise awareness, join the movement, and build products
within this new framework.

◦ Educating the public about the importance of data sovereignty and how to
protect their digital identity.

◦ Developing user economy models, for the users to be compensated when their
data is used by profit-making entities.

## Join the Movement

The future of our digital world depends on the actions we take today. By
reclaiming control over our personal data, we can ensure privacy, security, and
fairness for all. We call on developers to build innovative solutions that
prioritize user-controlled data management. We urge individuals to take greater
care of their digital identity and privacy, advocating for a future where
personal data is respected and protected. Join us in creating a fair and secure
digital world. Let us rise to the challenge and create a digital environment
where data sovereignty is the norm, not the exception. Because it is YOUR data,
and YOU should control what happens to it!

---

## ELI5

## Explain Like I'm Five

![ELI5](/eli5withtrademark.png)

---

## _02 Changelog



---

## _03 Versioning



---

## General

This section offers guidance on resolving common issues with Calimero Network
features. As the platform evolves, additional troubleshooting topics will be
added to help address various challenges. For further assistance, consult our
community forums or reach out through official support channels.

---

## SSL/TLS

### SSL/TLS Support

To be able to access the the node from external source on the same network you
will need to install the generated self-signed certificate.

> **_NOTE:_** Installing the SSL certificate is only necessary if you plan to
> access the node from an external source on the same network. If you are
> running the application locally, you do not need to install the certificate.

### Steps to Add the Certificate to Your Device

1. **Locate the Certificate**:

   - Download the certificate from
     `http://localhost:/admin-api/certificate`.
   - The `` is the port number used as an argument in the
     `--server-port` flag in the section
     [Initialize and start your node (separate terminal)](../getting-started/setup).
   - For example: `bash http://localhost:2428/admin-api/certificate`

2. **Add the Certificate to Trusted Certificates**:

   - **For Windows**:

     1. Open the `Run` dialog (Win + R) and type `mmc` to open the Microsoft
        Management Console.
     2. Go to `File` -> `Add/Remove Snap-in...`.
     3. Select `Certificates` and click `Add`.
     4. Choose `Computer account`, then `Next` and `Finish`.
     5. Expand `Certificates (Local Computer)` ->
        `Trusted Root Certification Authorities`.
     6. Right-click `Certificates`, then `All Tasks` -> `Import...`.
     7. Follow the prompts to import the certificate file.

   - **For macOS**:

     1. Double-click the certificate file.
     2. This will open the `Keychain Access` application.
     3. Choose `System` from the list of keychains.
     4. Drag and drop the certificate into the `System` keychain.
     5. Authenticate with your administrator password if prompted.
     6. Right-click the certificate and select `Get Info`.
     7. Expand the `Trust` section and select `Always Trust` from the
        `When using this certificate` dropdown.

   - **For Linux**:
     1. Copy the certificate to `/usr/local/share/ca-certificates/` (or
        `/etc/pki/ca-trust/source/anchors/` depending on your distribution).
     2. Run `sudo update-ca-certificates` (or `sudo update-ca-trust extract` for
        Red Hat-based distributions).

3. **Restart Your Browser**:
   - Close and reopen your web browser to ensure it recognizes the newly added
     certificate.

### Rules for Generating SSL Certificates

- If a certificate doesn't exist, a new one will be generated based on your
  current local IP address.
- If a certificate exists for the current IP address, it will be used.
- If a certificate exists but is not configured for the current IP address, a
  new certificate will be created.

> **_NOTE:_** Every time a new certificate is generated (e.g., on the first
> start of the server or when the IP address changes), you will need to add it
> to your device's trusted certificates.

---

## Limitations



---

## GitHub

All work on Calimero happens directly on GitHub. Both core team members and
external contributors send pull requests which go through the same review
process.

## How to Contribute

We appreciate your interest in contributing to our project! To get started with
contributing, please follow the instructions outlined in our
[CONTRIBUTING](https://github.com/calimero-network/core/blob/master/CONTRIBUTING.md)
file.

## Additional Ways to Contribute

- **Show Your Support:** If you find this project helpful, please star it on
  GitHub. Your stars help the project grow and reach more developers like you.
- **Spread the Word:** Share the project with your friends and colleagues who
  might be interested in contributing or using it.
- **Join Discussions:** Participate in discussions on GitHub
  [Issues](https://github.com/calimero-network/core/issues) or
  [Discussions](https://github.com/orgs/calimero-network/discussions) to share
  your ideas and provide feedback.
- **Write Tutorials or Blog Posts:** Create tutorials or blog posts about how to
  use the project or your experience contributing to it.

---

## Hackathons

# Hackathons

At Calimero, we love innovation and collaboration, which is why we plan to
regularly organize hackathons that include our product. We have exciting events
planned for the future. Stay tuned by following us on our social media channels
to get the latest updates.

## What is a Hackathon?

A hackathon is an event where developers, designers, and other tech enthusiasts
come together to create innovative solutions in a short amount of time.
Participants work in teams to build projects, often centered around a specific
theme or technology. Hackathons are a great opportunity to:

- **Learn New Skills:** Whether you’re a beginner or an expert, hackathons
  provide a platform to learn new technologies and tools.
- **Collaborate:** Work with other passionate individuals, share ideas, and
  collaborate on projects.
- **Showcase Your Talent:** Present your project to a panel of judges and other
  participants, winning prizes and recognition.
- **Network:** Meet like-minded individuals, industry experts, and potential
  employers or collaborators.

## How to Get Involved

When we announce a new hackathon, here’s how you can participate:

1. **Register for the Event:** Sign up through the event link provided in our
   announcements.
2. **Form a Team:** Join with friends or team up with other participants.
3. **Build Your Project:** Use our product and other tools to create something
   amazing.
4. **Submit Your Work:** Present your project at the end of the hackathon for a
   chance to win prizes and gain recognition.

### Stay Updated

Follow us on social media to be the first to know about our upcoming hackathons
and other events. We’ll share all the details, including how to register and
participate.

Thank you for your interest in contributing to our project through hackathons.
We look forward to seeing your innovative ideas and solutions!

---

## Bounty Program

# Bounty Program

We're excited to announce that Calimero will soon be launching a bounty program!
This program is designed to reward contributors who help us tackle various
issues and enhance our project.

## What is a Bounty Program?

A bounty program is an initiative where contributors can earn rewards for
completing specific tasks or resolving issues. These tasks can range from fixing
bugs to adding new features, improving documentation, or optimizing performance.
The rewards can vary and may include monetary compensation, swag, exclusive
access to new features, or public recognition.

## How it Works

While we are still in the process of finalizing the details of our bounty
program, here’s an overview of how it will function:

1. **Identify Bounty Issues:** We will mark specific
   [issues](https://github.com/calimero-network/core/issues) in our repository
   with a "bounty" label. These issues will be eligible for rewards.
2. **Contribute:** Choose a bounty-labeled issue that interests you, solve it,
   and submit a pull request.
3. **Review:** Our team will review your contribution. If your solution meets
   the requirements and quality standards, it will be merged.
4. **Reward:** Once the issue is resolved and your contribution is accepted, you
   will receive a reward. The exact nature of the reward will be specified in
   the issue description.

### Exceptional Contributions

While not all issues may be marked with a bounty label, we recognize that
exceptional solutions deserve recognition. If you provide a particularly
outstanding solution to an issue not marked as a bounty, we may still decide to
reward your contribution.

## Stay Tuned

We are currently refining the details of our bounty program, including the
reward system. Follow us on social media and keep an eye on our announcements to
be the first to know when the bounty program goes live.

Thank you for your patience and continued support. We look forward to
collaborating with you and rewarding your valuable contributions!

---

## Community and Support

# Community and Support

We value our community and are here to support you. Here are the best ways to
get in touch and find help:

## GitHub

- **Issues:** For development-related queries, bug reports, and feature
  requests, please use our
  [GitHub Issues](https://github.com/calimero-network/core/issues).
- **Discussions:** For more extensive discussions on various topics, join our
  [GitHub Discussions](https://github.com/orgs/calimero-network/discussions).

## Discord

For news, casual conversations, and random questions, join our
[Discord Server](https://discord.gg/jxAeJd2E). It’s a great place to connect
with other contributors, share ideas, and stay informed about the latest
updates.

## Social Media

Stay connected and get the latest news and updates by following us on social
media:

- **LinkedIn:** Follow us on
  [LinkedIn](https://www.linkedin.com/company/calimero-network/) for
  professional updates and networking opportunities.
- **Twitter:** Stay up-to-date with our latest tweets by following us on
  [Twitter](https://twitter.com/CalimeroNetwork).

Thank you for being a part of the Calimero community. Your contributions and
engagement help us grow and improve!

---

## Learning

# Learning

Expand your knowledge and stay informed by exploring the following resources:

## Learn More

- **Website:** Visit our [website](https://www.calimero.network/) for
  comprehensive information about the project, including features and
  documentation.
- **Blog:** Check out our
  [articles on X](https://x.com/CalimeroNetwork/articles) for insightful
  articles, tutorials, and the latest news about our project.

We provide a variety of resources to help you learn more about our project and
stay up-to-date with the latest developments. Dive into our documentation, read
our blog, and explore our website to get the most out of our project.

---

## Context Create Admin Dashboard

## Create a context using the Admin Dashboard

1. Navigate to the "Contexts" tab and click the "Start New Context" button.
2. Use the "Browse" button to select an application from the list.
3. Choose application.
4. Press "Start" to initiate the context creation process with the selected
   application.

Visit [Admin Dashboard Page](../../developer-tools/apps/admin-dashboard) to view
detailed instructions with images.

After the context is created, you will be redirected to the context dashboard.
Keep this page open as you will need the Context ID later.

---

## Context Create Binary

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

```bash title="Terminal"
meroctl --node node1 context create --watch  --protocol near
```

```bash title="Terminal"
meroctl --node node1 context create --watch  --protocol starknet
```

```bash title="Terminal"
meroctl --node node1 context create --watch  --protocol icp
```

```bash title="Terminal"
meroctl --node node1 context create --watch  --protocol stellar
```

```bash title="Terminal"
meroctl --node node1 context create --watch  --protocol ethereum
```

:::tip

- `--watch` flag enables watching for changes of wasm files and updating context
  with the new version
- `--protocol` flag specifies the protocol to use for the context
- `--as` flag creates an alias for your identity in your context, you can use it
  instead of the PublicKey

:::

---

## Context Create Interactive Cli

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

### Install the Application

Run the following command to install the application:

```bash title="Node Terminal"
application install url {url} {metadata}
```

:::note

metadata example:

```bash
'{"contractAppId": ""}'
```

:::

### Create a New Context

```bash title="Node Terminal"
context create {applicationId} --protocol near
```

```bash title="Node Terminal"
context create {applicationId} --protocol starknet
```

```bash title="Node Terminal"
context create {applicationId} --protocol icp
```

```bash title="Node Terminal"
context create {applicationId} --protocol stellar
```

```bash title="Node Terminal"
context create {applicationId} --protocol ethereum
```

:::tip

`--protocol` flag specifies the protocol to use for the context.

:::

```bash title="Output"
2024-10-07T11:55:36.658396Z  INFO calimero_context: Subscribed to context context_id=567C5Gg4mxHMPKy2wLJ4uvb3DHsbcpVDYUsuAWgTPgXn
Created context 567C5Gg4mxHMPKy2wLJ4uvb3DHsbcpVDYUsuAWgTPgXn with
identity DaSkad6DK7f6fUhjz1CvNW7L4TkWZmWqAcwysZHG3Xs5
```

![Create context](/cli/2-create-context.png)

---

## Install Cargo Mero

You can choose to install `cargo-mero` via cargo or from source.

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

If you use have [Rust](https://www.rust-lang.org/tools/install) installed, you can install `cargo-mero` directly with the following
steps:

1. Install the cli via cargo:

   ```bash
   cargo install cargo-mero --git https://github.com/calimero-network/core.git
   ```

2. Verify the installation:
   ```bash
   cargo mero --version
   ```

If the version number appears, the installation was successful.

#### Steps

1. Open your terminal and run:

   ```bash
   git clone https://github.com/calimero-network/core.git
   cd core
   cargo install --path crates/cargo-mero
   ```

2. Verify the installation:
   ```bash
   cargo mero --version
   ```

If the version number appears, the installation was successful.

---

## Install Meroctl

You can choose to install `meroctl` using either the installation script or
Homebrew.

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

If you use Homebrew, you can install `meroctl` directly with the following
steps:

#### Steps

1. Add the Calimero Homebrew tap:

   ```bash
   brew tap calimero-network/homebrew-tap
   ```

2. Install `merod`:

   ```bash
   brew install meroctl
   ```

3. Verify the installation:
   ```bash
   meroctl --version
   ```

If the version number appears, the installation was successful.

The installation script supports multiple terminal environments and will
automatically configure your PATH based on your shell.

#### Steps

1. Open your terminal and run:

   ```bash
   curl -sSf https://raw.githubusercontent.com/calimero-network/install-sh/master/install-meroctl.sh | bash
   ```

2. Source the updated PATH:

   ```bash
   source 
   ```

   Replace `` with `.bashrc`, `.zshrc`, or the relevant
   configuration file for your shell.

3. Verify the installation:
   ```bash
   meroctl --version
   ```

If the version number appears, the installation was successful.

#### Notes for Shell Environments

The script automatically updates your PATH based on your shell configuration:

- **Bash**: Updates `.bashrc`.
- **Zsh**: Updates `.zshrc`.
- **Fish**: Modifies `~/.config/fish/config.fish`.
- **Csh/Tcsh**: Updates `.cshrc`.

To apply the changes immediately, use the `source` command as described in step
2 above.

---

## Install Merod

You can choose to install `merod` using either the installation script or
Homebrew.

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

If you use Homebrew, you can install `merod` directly with the following
steps:

#### Steps

1. Add the Calimero Homebrew tap:

   ```bash
   brew tap calimero-network/homebrew-tap
   ```

2. Install `merod`:

   ```bash
   brew install merod
   ```

3. Verify the installation:
   ```bash
   merod --version
   ```

If the version number appears, the installation was successful.

The installation script supports multiple terminal environments and will
automatically configure your PATH based on your shell.

#### Steps

1. Open your terminal and run:

   ```bash
   curl -sSf https://raw.githubusercontent.com/calimero-network/install-sh/master/install-merod.sh | bash
   ```

2. Source the updated PATH:

   ```bash
   source 
   ```

   Replace `` with `.bashrc`, `.zshrc`, or the relevant
   configuration file for your shell.

3. Verify the installation:
   ```bash
   merod --version
   ```

If the version number appears, the installation was successful.

#### Notes for Shell Environments

The script automatically updates your PATH based on your shell configuration:

- **Bash**: Updates `.bashrc`.
- **Zsh**: Updates `.zshrc`.
- **Fish**: Modifies `~/.config/fish/config.fish`.
- **Csh/Tcsh**: Updates `.cshrc`.

To apply the changes immediately, use the `source` command as described in step
2 above.

---

## Node Init Binary

```bash title="Terminal"
merod --node-name node1 init --server-port 2428 --swarm-port 2528
```

Node configuration file contains protocol defined metada and is located at
`~/.calimero/your_node_name/config.toml`.

---

## Node Init Source

```bash title="Terminal"
cargo run -p merod -- --node-name node1 init --server-port 2428 --swarm-port 2528
```

Node configuration file contains protocol defined metada and is located at
`~/.calimero/your_node_name/config.toml`.

---

## Node Run Binary

```bash title="Terminal"
merod --node-name node1 run
```

Wait for a few moments and node logs should appear.

---

## Node Run Source

```bash title="Terminal"
cargo run -p merod -- --node-name node1 run
```

Wait for a few moments and node logs should appear.
