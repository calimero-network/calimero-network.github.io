"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[5716],{51825:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"developer-tools/SDK/protocol-sdk/calimero-collections","title":"Calimero Collections Reference","description":"This comprehensive reference covers all available collections in the Calimero","source":"@site/docs/05-developer-tools/02-SDK/03-protocol-sdk/04-calimero-collections.mdx","sourceDirName":"05-developer-tools/02-SDK/03-protocol-sdk","slug":"/developer-tools/SDK/protocol-sdk/calimero-collections","permalink":"/developer-tools/SDK/protocol-sdk/calimero-collections","draft":false,"unlisted":false,"editUrl":"https://github.com/calimero-network/calimero-network.github.io/edit/master/docs/05-developer-tools/02-SDK/03-protocol-sdk/04-calimero-collections.mdx","tags":[],"version":"current","lastUpdatedAt":1759330694000,"sidebarPosition":4,"frontMatter":{"id":"calimero-collections","title":"Calimero Collections Reference"},"sidebar":"tutorialSidebar","previous":{"title":"Rust SDK Deep Dive","permalink":"/developer-tools/SDK/protocol-sdk/rust-sdk-deep-dive"},"next":{"title":"External Functions and Proposals","permalink":"/developer-tools/SDK/protocol-sdk/external-functions-and-proposals"}}');var l=r(86070),t=r(83545);const i={id:"calimero-collections",title:"Calimero Collections Reference"},o="Calimero Collections Reference",a={},c=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Overview",id:"overview",level:2},{value:"Core Collections",id:"core-collections",level:2},{value:"UnorderedMap",id:"unorderedmap",level:3},{value:"Basic Usage",id:"basic-usage",level:4},{value:"Advanced Operations",id:"advanced-operations",level:4},{value:"UnorderedSet",id:"unorderedset",level:3},{value:"Vector",id:"vector",level:3},{value:"Specialized Collections",id:"specialized-collections",level:2},{value:"LookupMap",id:"lookupmap",level:3},{value:"TreeMap",id:"treemap",level:3},{value:"When to Use Each Collection",id:"when-to-use-each-collection",level:3},{value:"Use UnorderedMap when:",id:"use-unorderedmap-when",level:4},{value:"Use UnorderedSet when:",id:"use-unorderedset-when",level:4},{value:"Use Vector when:",id:"use-vector-when",level:4},{value:"Use LookupMap when:",id:"use-lookupmap-when",level:4},{value:"Use TreeMap when:",id:"use-treemap-when",level:4},{value:"Performance Characteristics",id:"performance-characteristics",level:2},{value:"Operation Complexity",id:"operation-complexity",level:3},{value:"Memory Usage",id:"memory-usage",level:3},{value:"Collection Patterns",id:"collection-patterns",level:2},{value:"Entry API for Conditional Operations",id:"entry-api-for-conditional-operations",level:3},{value:"Batch Operations",id:"batch-operations",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Error Handling",id:"error-handling",level:3},{value:"Memory Management",id:"memory-management",level:3},{value:"Transaction Safety",id:"transaction-safety",level:3},{value:"Migration from Standard Collections",id:"migration-from-standard-collections",level:2},{value:"Key Differences",id:"key-differences",level:3},{value:"Migration Example",id:"migration-example",level:3},{value:"Common Pitfalls",id:"common-pitfalls",level:2},{value:"Forgetting Error Handling",id:"forgetting-error-handling",level:3},{value:"Assuming Standard Collection Methods",id:"assuming-standard-collection-methods",level:3},{value:"Ignoring Storage Errors",id:"ignoring-storage-errors",level:3},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const n={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.header,{children:(0,l.jsx)(n.h1,{id:"calimero-collections-reference",children:"Calimero Collections Reference"})}),"\n",(0,l.jsx)(n.p,{children:"This comprehensive reference covers all available collections in the Calimero\nSDK, their performance characteristics, and best practices for using them\neffectively."}),"\n",(0,l.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#overview",children:"Overview"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#core-collections",children:"Core Collections"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#specialized-collections",children:"Specialized Collections"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#performance-characteristics",children:"Performance Characteristics"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#collection-patterns",children:"Collection Patterns"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#best-practices",children:"Best Practices"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"#migration-from-standard-collections",children:"Migration from Standard Collections"})}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,l.jsx)(n.p,{children:"Calimero collections are specifically designed for WebAssembly and decentralized\napplications. They provide:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Wasm Optimization"}),": Designed for efficient serialization and memory usage"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Persistent Storage"}),": Automatic integration with Calimero's storage system"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Type Safety"}),": Full Rust type safety with compile-time guarantees"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Performance"}),": Optimized for common operations in decentralized apps"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Error Handling"}),": All operations return ",(0,l.jsx)(n.code,{children:"Result<T, StoreError>"})," for robust\nerror handling"]}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"core-collections",children:"Core Collections"}),"\n",(0,l.jsx)(n.h3,{id:"unorderedmap",children:"UnorderedMap"}),"\n",(0,l.jsxs)(n.p,{children:["A hash map implementation optimized for Wasm with O(1) average case operations.\nAll operations return ",(0,l.jsx)(n.code,{children:"Result<T, StoreError>"}),"."]}),"\n",(0,l.jsx)(n.h4,{id:"basic-usage",children:"Basic Usage"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:'use calimero_storage::collections::UnorderedMap;\n\n#[app::state]\n#[derive(Default, BorshSerialize, BorshDeserialize)]\n#[borsh(crate = "calimero_sdk::borsh")]\nstruct UserRegistry {\n    users: UnorderedMap<String, UserProfile>,\n    user_count: u32,\n}\n\n#[app::logic]\nimpl UserRegistry {\n    pub fn add_user(&mut self, username: String, profile: UserProfile) -> app::Result<()> {\n        if self.users.contains_key(&username)? {\n            return app::bail!("User already exists");\n        }\n\n        self.users.insert(username, profile)?;\n        self.user_count += 1;\n        Ok(())\n    }\n\n    pub fn get_user(&self, username: &str) -> app::Result<Option<UserProfile>> {\n        self.users.get(username).map_err(Into::into)\n    }\n\n    pub fn update_user(&mut self, username: String, profile: UserProfile) -> app::Result<()> {\n        if !self.users.contains_key(&username)? {\n            return app::bail!("User not found");\n        }\n\n        self.users.insert(username, profile)?;\n        Ok(())\n    }\n\n    pub fn remove_user(&mut self, username: &str) -> app::Result<Option<UserProfile>> {\n        let user = self.users.remove(username)?;\n        if user.is_some() {\n            self.user_count -= 1;\n        }\n        Ok(user)\n    }\n}\n'})}),"\n",(0,l.jsx)(n.h4,{id:"advanced-operations",children:"Advanced Operations"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:'#[app::logic]\nimpl UserRegistry {\n    // Batch operations\n    pub fn add_multiple_users(&mut self, users: Vec<(String, UserProfile)>) -> app::Result<()> {\n        for (username, profile) in users {\n            if self.users.contains_key(&username)? {\n                return app::bail!("User {} already exists", username);\n            }\n            self.users.insert(username, profile)?;\n            self.user_count += 1;\n        }\n        Ok(())\n    }\n\n    // Iteration\n    pub fn get_all_users(&self) -> app::Result<Vec<UserProfile>> {\n        self.users.entries()?.collect()\n    }\n\n    // Search\n    pub fn search_users(&self, query: &str) -> app::Result<Vec<UserProfile>> {\n        Ok(self.users\n            .entries()?\n            .filter(|(username, _)| username.contains(query))\n            .map(|(_, profile)| profile)\n            .collect())\n    }\n\n    // Statistics\n    pub fn get_user_count(&self) -> app::Result<usize> {\n        self.users.len()\n    }\n}\n'})}),"\n",(0,l.jsx)(n.h3,{id:"unorderedset",children:"UnorderedSet"}),"\n",(0,l.jsx)(n.p,{children:"A hash set for unique elements with similar performance characteristics to\nUnorderedMap."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:'use calimero_storage::collections::UnorderedSet;\n\n#[app::state]\n#[derive(Default, BorshSerialize, BorshDeserialize)]\n#[borsh(crate = "calimero_sdk::borsh")]\nstruct AccessControl {\n    admins: UnorderedSet<String>,\n    moderators: UnorderedSet<String>,\n}\n\n#[app::logic]\nimpl AccessControl {\n    pub fn add_admin(&mut self, username: String) -> app::Result<()> {\n        self.admins.insert(username)?;\n        Ok(())\n    }\n\n    pub fn is_admin(&self, username: &str) -> app::Result<bool> {\n        self.admins.contains(username)\n    }\n\n    pub fn remove_admin(&mut self, username: &str) -> app::Result<bool> {\n        self.admins.remove(username)\n    }\n\n    pub fn get_admin_count(&self) -> app::Result<usize> {\n        self.admins.len()\n    }\n\n    pub fn get_all_admins(&self) -> app::Result<Vec<String>> {\n        self.admins.entries()?.collect()\n    }\n}\n'})}),"\n",(0,l.jsx)(n.h3,{id:"vector",children:"Vector"}),"\n",(0,l.jsx)(n.p,{children:"A dynamic array implementation optimized for sequential access."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:'use calimero_storage::collections::Vector;\n\n#[app::state]\n#[derive(Default, BorshSerialize, BorshDeserialize)]\n#[borsh(crate = "calimero_sdk::borsh")]\nstruct TaskManager {\n    tasks: Vector<Task>,\n    completed_tasks: Vector<Task>,\n}\n\n#[app::logic]\nimpl TaskManager {\n    pub fn add_task(&mut self, task: Task) -> app::Result<()> {\n        self.tasks.insert(None, task)?;\n        Ok(())\n    }\n\n    pub fn complete_task(&mut self, index: u32) -> app::Result<()> {\n        if index >= self.tasks.len()? {\n            return app::bail!("Invalid task index");\n        }\n\n        let task = self.tasks.remove(index as usize)?;\n        self.completed_tasks.insert(None, task)?;\n        Ok(())\n    }\n\n    pub fn get_task(&self, index: u32) -> app::Result<Option<Task>> {\n        if index >= self.tasks.len()? {\n            return Ok(None);\n        }\n        self.tasks.get(index as usize)\n    }\n\n    pub fn get_all_tasks(&self) -> app::Result<Vec<Task>> {\n        self.tasks.entries()?.collect()\n    }\n}\n'})}),"\n",(0,l.jsx)(n.h2,{id:"specialized-collections",children:"Specialized Collections"}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Note"}),": Some of these specialized collections may be planned for future\nreleases or available in different versions of the SDK. Check the latest SDK\ndocumentation for current availability."]}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"lookupmap",children:"LookupMap"}),"\n",(0,l.jsx)(n.p,{children:"A map optimized for cases where you need to iterate over keys or values\nfrequently. This collection provides better iteration performance at the cost of\nslightly higher memory usage."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:'use calimero_storage::collections::LookupMap;\n\n#[app::state]\n#[derive(Default, BorshSerialize, BorshDeserialize)]\n#[borsh(crate = "calimero_sdk::borsh")]\nstruct Analytics {\n    // User -> Page views\n    page_views: LookupMap<String, u32>,\n    // Page -> Total views\n    total_views: LookupMap<String, u64>,\n}\n\n#[app::logic]\nimpl Analytics {\n    pub fn record_page_view(&mut self, user: String, page: String) -> app::Result<()> {\n        // Increment user\'s page views\n        let user_views = self.page_views.get(&user)?.unwrap_or(0);\n        self.page_views.insert(user, user_views + 1)?;\n\n        // Increment total page views\n        let total = self.total_views.get(&page)?.unwrap_or(0);\n        self.total_views.insert(page, total + 1)?;\n\n        Ok(())\n    }\n\n    pub fn get_user_stats(&self, user: &str) -> app::Result<u32> {\n        Ok(self.page_views.get(user)?.unwrap_or(0))\n    }\n\n    pub fn get_page_stats(&self, page: &str) -> app::Result<u64> {\n        Ok(self.total_views.get(page)?.unwrap_or(0))\n    }\n\n    pub fn get_top_pages(&self, limit: usize) -> app::Result<Vec<(String, u64)>> {\n        let mut pages: Vec<(String, u64)> = self.total_views\n            .entries()?\n            .map(|(page, views)| (page, views))\n            .collect();\n\n        pages.sort_by(|a, b| b.1.cmp(&a.1));\n        pages.truncate(limit);\n        Ok(pages)\n    }\n}\n'})}),"\n",(0,l.jsx)(n.h3,{id:"treemap",children:"TreeMap"}),"\n",(0,l.jsx)(n.p,{children:"A sorted map implementation for cases where you need ordered keys. This\ncollection maintains keys in sorted order, enabling efficient range queries and\nordered iteration."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:'use calimero_storage::collections::TreeMap;\n\n#[app::state]\n#[derive(Default, BorshSerialize, BorshDeserialize)]\n#[borsh(crate = "calimero_sdk::borsh")]\nstruct Leaderboard {\n    // Score -> List of users with that score\n    score_rankings: TreeMap<u32, UnorderedSet<String>>,\n    // User -> Current score\n    user_scores: UnorderedMap<String, u32>,\n}\n\n#[app::logic]\nimpl Leaderboard {\n    pub fn update_score(&mut self, user: String, new_score: u32) -> app::Result<()> {\n        // Remove user from old score ranking\n        if let Some(old_score) = self.user_scores.get(&user)? {\n            if let Some(users_at_score) = self.score_rankings.get(&old_score)? {\n                let mut updated_users = users_at_score.clone();\n                updated_users.remove(&user)?;\n\n                if updated_users.is_empty() {\n                    self.score_rankings.remove(&old_score)?;\n                } else {\n                    self.score_rankings.insert(old_score, updated_users)?;\n                }\n            }\n        }\n\n        // Add user to new score ranking\n        let mut users_at_score = self.score_rankings\n            .get(&new_score)?\n            .unwrap_or_else(|| UnorderedSet::new());\n        users_at_score.insert(user.clone())?;\n        self.score_rankings.insert(new_score, users_at_score)?;\n\n        // Update user\'s score\n        self.user_scores.insert(user, new_score)?;\n\n        Ok(())\n    }\n\n    pub fn get_top_players(&self, limit: usize) -> app::Result<Vec<(String, u32)>> {\n        let mut top_players = Vec::new();\n\n        // Iterate in reverse order (highest scores first)\n        for (score, users) in self.score_rankings.entries()?.rev() {\n            for user in users.entries()? {\n                top_players.push((user, score));\n                if top_players.len() >= limit {\n                    break;\n                }\n            }\n            if top_players.len() >= limit {\n                break;\n            }\n        }\n\n        Ok(top_players)\n    }\n\n    pub fn get_user_rank(&self, user: &str) -> app::Result<Option<u32>> {\n        let user_score = match self.user_scores.get(user)? {\n            Some(score) => score,\n            None => return Ok(None),\n        };\n\n        let mut rank = 1;\n\n        // Count users with higher scores\n        for (score, users) in self.score_rankings.entries()?.rev() {\n            if score > user_score {\n                rank += users.len()? as u32;\n            } else {\n                break;\n            }\n        }\n\n        Ok(Some(rank))\n    }\n}\n'})}),"\n",(0,l.jsx)(n.h3,{id:"when-to-use-each-collection",children:"When to Use Each Collection"}),"\n",(0,l.jsx)(n.h4,{id:"use-unorderedmap-when",children:"Use UnorderedMap when:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"You need fast key-value lookups"}),"\n",(0,l.jsx)(n.li,{children:"Order doesn't matter"}),"\n",(0,l.jsx)(n.li,{children:"Memory efficiency is important"}),"\n"]}),"\n",(0,l.jsx)(n.h4,{id:"use-unorderedset-when",children:"Use UnorderedSet when:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"You need to track unique elements"}),"\n",(0,l.jsx)(n.li,{children:"Fast membership testing is required"}),"\n",(0,l.jsx)(n.li,{children:"Order doesn't matter"}),"\n"]}),"\n",(0,l.jsx)(n.h4,{id:"use-vector-when",children:"Use Vector when:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"You need ordered elements"}),"\n",(0,l.jsx)(n.li,{children:"Sequential access is common"}),"\n",(0,l.jsx)(n.li,{children:"You frequently add/remove from the end"}),"\n"]}),"\n",(0,l.jsx)(n.h4,{id:"use-lookupmap-when",children:"Use LookupMap when:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"You frequently iterate over keys or values"}),"\n",(0,l.jsx)(n.li,{children:"Memory overhead is acceptable"}),"\n",(0,l.jsx)(n.li,{children:"You need both map and iteration performance"}),"\n"]}),"\n",(0,l.jsx)(n.h4,{id:"use-treemap-when",children:"Use TreeMap when:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"You need sorted keys"}),"\n",(0,l.jsx)(n.li,{children:"Range queries are common"}),"\n",(0,l.jsx)(n.li,{children:"Order matters for your use case"}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"performance-characteristics",children:"Performance Characteristics"}),"\n",(0,l.jsx)(n.h3,{id:"operation-complexity",children:"Operation Complexity"}),"\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"Operation"}),(0,l.jsx)(n.th,{children:"UnorderedMap"}),(0,l.jsx)(n.th,{children:"UnorderedSet"}),(0,l.jsx)(n.th,{children:"Vector"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"Insert"}),(0,l.jsx)(n.td,{children:"O(1) avg"}),(0,l.jsx)(n.td,{children:"O(1) avg"}),(0,l.jsx)(n.td,{children:"O(1)"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"Get"}),(0,l.jsx)(n.td,{children:"O(1) avg"}),(0,l.jsx)(n.td,{children:"O(1) avg"}),(0,l.jsx)(n.td,{children:"O(1)"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"Remove"}),(0,l.jsx)(n.td,{children:"O(1) avg"}),(0,l.jsx)(n.td,{children:"O(1) avg"}),(0,l.jsx)(n.td,{children:"O(n)"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"Iterate"}),(0,l.jsx)(n.td,{children:"O(n)"}),(0,l.jsx)(n.td,{children:"O(n)"}),(0,l.jsx)(n.td,{children:"O(n)"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"Contains"}),(0,l.jsx)(n.td,{children:"O(1) avg"}),(0,l.jsx)(n.td,{children:"O(1) avg"}),(0,l.jsx)(n.td,{children:"O(n)"})]})]})]}),"\n",(0,l.jsx)(n.h3,{id:"memory-usage",children:"Memory Usage"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"UnorderedMap/UnorderedSet"}),": Hash table overhead + key-value storage"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Vector"}),": Dynamic array with growth factor"]}),"\n",(0,l.jsx)(n.li,{children:"All collections automatically handle serialization/deserialization"}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"collection-patterns",children:"Collection Patterns"}),"\n",(0,l.jsx)(n.h3,{id:"entry-api-for-conditional-operations",children:"Entry API for Conditional Operations"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:"#[app::logic]\nimpl UserRegistry {\n    pub fn get_or_create_user(&mut self, username: String) -> app::Result<&mut UserProfile> {\n        // This pattern doesn't work with current API - collections return Result\n        // Use conditional logic instead\n        if !self.users.contains_key(&username)? {\n            let default_profile = UserProfile::default();\n            self.users.insert(username.clone(), default_profile)?;\n        }\n\n        // Note: We can't return &mut due to Result wrapper\n        // Consider returning the value or using a different pattern\n        Ok(())\n    }\n}\n"})}),"\n",(0,l.jsx)(n.h3,{id:"batch-operations",children:"Batch Operations"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:"#[app::logic]\nimpl UserRegistry {\n    pub fn bulk_update_users(&mut self, updates: Vec<(String, UserProfile)>) -> app::Result<()> {\n        for (username, profile) in updates {\n            self.users.insert(username, profile)?;\n        }\n        Ok(())\n    }\n\n    pub fn bulk_remove_users(&mut self, usernames: Vec<String>) -> app::Result<usize> {\n        let mut removed_count = 0;\n        for username in usernames {\n            if self.users.remove(&username)?.is_some() {\n                removed_count += 1;\n            }\n        }\n        Ok(removed_count)\n    }\n}\n"})}),"\n",(0,l.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,l.jsx)(n.h3,{id:"error-handling",children:"Error Handling"}),"\n",(0,l.jsxs)(n.p,{children:["Always handle the ",(0,l.jsx)(n.code,{children:"Result"})," returned by collection operations:"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:'// \u274c Bad - ignoring errors\nlet value = self.users.get(&key).unwrap();\n\n// \u2705 Good - proper error handling\nlet value = match self.users.get(&key)? {\n    Some(v) => v,\n    None => return app::bail!("User not found"),\n};\n'})}),"\n",(0,l.jsx)(n.h3,{id:"memory-management",children:"Memory Management"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:"// \u274c Bad - creating unnecessary clones\nlet all_users: Vec<String> = self.users.entries()?\n    .map(|(k, _)| k.clone())\n    .collect();\n\n// \u2705 Good - avoid unnecessary cloning\nlet all_users: Vec<&String> = self.users.entries()?\n    .map(|(k, _)| k)\n    .collect();\n"})}),"\n",(0,l.jsx)(n.h3,{id:"transaction-safety",children:"Transaction Safety"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:'#[app::logic]\nimpl UserRegistry {\n    pub fn transfer_user(&mut self, from: String, to: String) -> app::Result<()> {\n        // All operations are atomic - if any fail, all changes are rolled back\n        let profile = self.users.remove(&from)?\n            .ok_or_else(|| app::err!("Source user not found"))?;\n\n        self.users.insert(to, profile)?;\n        Ok(())\n    }\n}\n'})}),"\n",(0,l.jsx)(n.h2,{id:"migration-from-standard-collections",children:"Migration from Standard Collections"}),"\n",(0,l.jsx)(n.h3,{id:"key-differences",children:"Key Differences"}),"\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"Standard Collection"}),(0,l.jsx)(n.th,{children:"Calimero Collection"}),(0,l.jsx)(n.th,{children:"Key Changes"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:(0,l.jsx)(n.code,{children:"HashMap<K, V>"})}),(0,l.jsx)(n.td,{children:(0,l.jsx)(n.code,{children:"UnorderedMap<K, V>"})}),(0,l.jsxs)(n.td,{children:["Returns ",(0,l.jsx)(n.code,{children:"Result<T, StoreError>"})]})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:(0,l.jsx)(n.code,{children:"HashSet<T>"})}),(0,l.jsx)(n.td,{children:(0,l.jsx)(n.code,{children:"UnorderedSet<T>"})}),(0,l.jsxs)(n.td,{children:["Returns ",(0,l.jsx)(n.code,{children:"Result<T, StoreError>"})]})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:(0,l.jsx)(n.code,{children:"Vec<T>"})}),(0,l.jsx)(n.td,{children:(0,l.jsx)(n.code,{children:"Vector<T>"})}),(0,l.jsxs)(n.td,{children:["Returns ",(0,l.jsx)(n.code,{children:"Result<T, StoreError>"})]})]})]})]}),"\n",(0,l.jsx)(n.h3,{id:"migration-example",children:"Migration Example"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:'// Before (standard collections)\nuse std::collections::HashMap;\n\nstruct OldApp {\n    users: HashMap<String, UserProfile>,\n}\n\nimpl OldApp {\n    pub fn add_user(&mut self, username: String, profile: UserProfile) {\n        self.users.insert(username, profile);\n    }\n}\n\n// After (Calimero collections)\nuse calimero_storage::collections::UnorderedMap;\n\n#[app::state]\n#[derive(Default, BorshSerialize, BorshDeserialize)]\n#[borsh(crate = "calimero_sdk::borsh")]\nstruct NewApp {\n    users: UnorderedMap<String, UserProfile>,\n}\n\n#[app::logic]\nimpl NewApp {\n    pub fn add_user(&mut self, username: String, profile: UserProfile) -> app::Result<()> {\n        self.users.insert(username, profile)?;\n        Ok(())\n    }\n}\n'})}),"\n",(0,l.jsx)(n.h2,{id:"common-pitfalls",children:"Common Pitfalls"}),"\n",(0,l.jsx)(n.h3,{id:"forgetting-error-handling",children:"Forgetting Error Handling"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:"// \u274c This will not compile\nlet user = self.users.get(&username).unwrap();\n\n// \u2705 Handle the Result\nlet user = self.users.get(&username)?;\n"})}),"\n",(0,l.jsx)(n.h3,{id:"assuming-standard-collection-methods",children:"Assuming Standard Collection Methods"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:"// \u274c Standard collections don't have these methods\nlet count = self.users.len(); // Standard collections return usize directly\n\n// \u2705 Calimero collections return Result\nlet count = self.users.len()?; // Returns Result<usize, StoreError>\n"})}),"\n",(0,l.jsx)(n.h3,{id:"ignoring-storage-errors",children:"Ignoring Storage Errors"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:"// \u274c Bad - storage errors can indicate serious issues\nif let Ok(user) = self.users.get(&username) {\n    // Handle user\n}\n\n// \u2705 Good - propagate errors up\nlet user = self.users.get(&username)?;\n"})}),"\n",(0,l.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["Learn about ",(0,l.jsx)(n.a,{href:"./protocol-rs-sdk",children:"Rust SDK Macros"})," for application structure"]}),"\n",(0,l.jsxs)(n.li,{children:["See ",(0,l.jsx)(n.a,{href:"./rust-sdk-deep-dive",children:"Rust SDK Deep Dive"})," for advanced patterns"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(d,{...e})}):d(e)}},83545:(e,n,r)=>{r.d(n,{R:()=>i,x:()=>o});var s=r(30758);const l={},t=s.createContext(l);function i(e){const n=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:i(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);