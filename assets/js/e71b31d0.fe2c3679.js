"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[4878],{8162:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>c,frontMatter:()=>a,metadata:()=>r,toc:()=>p});const r=JSON.parse('{"id":"developer-tools/SDK/protocol-sdk/rust-sdk-deep-dive","title":"Rust SDK Deep Dive","description":"This comprehensive guide covers advanced usage of the Calimero Rust SDK,","source":"@site/docs/05-developer-tools/02-SDK/03-protocol-sdk/03-rust-sdk-deep-dive.mdx","sourceDirName":"05-developer-tools/02-SDK/03-protocol-sdk","slug":"/developer-tools/SDK/protocol-sdk/rust-sdk-deep-dive","permalink":"/developer-tools/SDK/protocol-sdk/rust-sdk-deep-dive","draft":false,"unlisted":false,"editUrl":"https://github.com/calimero-network/calimero-network.github.io/edit/master/docs/05-developer-tools/02-SDK/03-protocol-sdk/03-rust-sdk-deep-dive.mdx","tags":[],"version":"current","lastUpdatedAt":1757931844000,"sidebarPosition":3,"frontMatter":{"id":"rust-sdk-deep-dive","title":"Rust SDK Deep Dive"},"sidebar":"tutorialSidebar","previous":{"title":"Rust Protocol SDK","permalink":"/developer-tools/SDK/protocol-sdk/protocol-rs-sdk"},"next":{"title":"Calimero Collections Reference","permalink":"/developer-tools/SDK/protocol-sdk/calimero-collections"}}');var t=s(86070),i=s(48854);const a={id:"rust-sdk-deep-dive",title:"Rust SDK Deep Dive"},o="Rust SDK Deep Dive",l={},p=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Collections",id:"collections",level:2},{value:"Core Collections",id:"core-collections",level:3},{value:"UnorderedMap",id:"unorderedmap",level:4},{value:"UnorderedSet",id:"unorderedset",level:4},{value:"Vector",id:"vector",level:4},{value:"Advanced Collection Patterns",id:"advanced-collection-patterns",level:3},{value:"Nested Collections",id:"nested-collections",level:4},{value:"Collection Iterators",id:"collection-iterators",level:4},{value:"Events and Event Handling",id:"events-and-event-handling",level:2},{value:"Event Definition",id:"event-definition",level:3},{value:"Event Emission",id:"event-emission",level:3},{value:"Event Patterns",id:"event-patterns",level:3},{value:"Batch Events",id:"batch-events",level:4},{value:"Conditional Events",id:"conditional-events",level:4},{value:"Advanced Macros",id:"advanced-macros",level:2},{value:"Macro Composition",id:"macro-composition",level:3},{value:"Custom Error Types",id:"custom-error-types",level:3},{value:"Advanced Macro Features",id:"advanced-macro-features",level:3},{value:"Custom State Configuration",id:"custom-state-configuration",level:4},{value:"Access Control Patterns",id:"access-control-patterns",level:4},{value:"Conditional Logic and State Management",id:"conditional-logic-and-state-management",level:4},{value:"State Management Patterns",id:"state-management-patterns",level:2},{value:"Immutable State Access",id:"immutable-state-access",level:3},{value:"Mutable State with Validation",id:"mutable-state-with-validation",level:3},{value:"State Initialization Patterns",id:"state-initialization-patterns",level:3},{value:"Performance Optimization",id:"performance-optimization",level:2},{value:"Efficient Iteration",id:"efficient-iteration",level:3},{value:"Batch Operations",id:"batch-operations",level:3},{value:"Memory Management",id:"memory-management",level:3},{value:"Testing and Debugging",id:"testing-and-debugging",level:2},{value:"Logging Best Practices",id:"logging-best-practices",level:3},{value:"Error Context",id:"error-context",level:3},{value:"Unit Testing",id:"unit-testing",level:3},{value:"Debug Logging and State Inspection",id:"debug-logging-and-state-inspection",level:3},{value:"Performance Monitoring",id:"performance-monitoring",level:3},{value:"Common Patterns and Anti-patterns",id:"common-patterns-and-anti-patterns",level:2},{value:"\u2705 Good Patterns",id:"-good-patterns",level:3},{value:"Atomic Operations",id:"atomic-operations",level:4},{value:"Proper Error Handling",id:"proper-error-handling",level:4},{value:"\u274c Anti-patterns",id:"-anti-patterns",level:3},{value:"Ignoring Errors",id:"ignoring-errors",level:4},{value:"Unnecessary Cloning",id:"unnecessary-cloning",level:4},{value:"Complex Nested Operations",id:"complex-nested-operations",level:4},{value:"Next Steps",id:"next-steps",level:2}];function u(e){const n={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"rust-sdk-deep-dive",children:"Rust SDK Deep Dive"})}),"\n",(0,t.jsx)(n.p,{children:"This comprehensive guide covers advanced usage of the Calimero Rust SDK,\nincluding collections, events, macros, and best practices for building\nproduction applications."}),"\n",(0,t.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#collections",children:"Collections"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#events-and-event-handling",children:"Events and Event Handling"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#advanced-macros",children:"Advanced Macros"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#state-management-patterns",children:"State Management Patterns"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#performance-optimization",children:"Performance Optimization"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#testing-and-debugging",children:"Testing and Debugging"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#common-patterns-and-anti-patterns",children:"Common Patterns and Anti-patterns"})}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"collections",children:"Collections"}),"\n",(0,t.jsxs)(n.p,{children:["Calimero provides a rich set of collections optimized for WebAssembly and\ndecentralized applications. These collections are designed to work efficiently\nwith the Calimero storage system and return ",(0,t.jsx)(n.code,{children:"Result<T, StoreError>"})," for robust\nerror handling."]}),"\n",(0,t.jsx)(n.h3,{id:"core-collections",children:"Core Collections"}),"\n",(0,t.jsx)(n.h4,{id:"unorderedmap",children:"UnorderedMap"}),"\n",(0,t.jsx)(n.p,{children:"A hash map implementation optimized for Wasm with O(1) average case operations:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'use calimero_storage::collections::UnorderedMap;\n\n#[app::state]\n#[derive(Default, BorshSerialize, BorshDeserialize)]\n#[borsh(crate = "calimero_sdk::borsh")]\nstruct MyApp {\n    users: UnorderedMap<String, UserProfile>,\n    settings: UnorderedMap<String, String>,\n}\n\n#[app::logic]\nimpl MyApp {\n    pub fn add_user(&mut self, username: String, profile: UserProfile) -> app::Result<()> {\n        if self.users.contains_key(&username)? {\n            return app::bail!("User already exists");\n        }\n\n        self.users.insert(username, profile)?;\n        Ok(())\n    }\n\n    pub fn get_user(&self, username: &str) -> app::Result<Option<UserProfile>> {\n        self.users.get(username).map_err(Into::into)\n    }\n\n    pub fn remove_user(&mut self, username: &str) -> app::Result<Option<UserProfile>> {\n        self.users.remove(username)\n    }\n\n    pub fn get_user_count(&self) -> app::Result<usize> {\n        self.users.len()\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h4,{id:"unorderedset",children:"UnorderedSet"}),"\n",(0,t.jsx)(n.p,{children:"A hash set for unique elements:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'use calimero_storage::collections::UnorderedSet;\n\n#[app::state]\n#[derive(Default, BorshSerialize, BorshDeserialize)]\n#[borsh(crate = "calimero_sdk::borsh")]\nstruct AccessControl {\n    admins: UnorderedSet<String>,\n    moderators: UnorderedSet<String>,\n}\n\n#[app::logic]\nimpl AccessControl {\n    pub fn add_admin(&mut self, username: String) -> app::Result<()> {\n        self.admins.insert(username)?;\n        Ok(())\n    }\n\n    pub fn is_admin(&self, username: &str) -> app::Result<bool> {\n        self.admins.contains(username)\n    }\n\n    pub fn remove_admin(&mut self, username: &str) -> app::Result<bool> {\n        self.admins.remove(username)\n    }\n\n    pub fn get_admin_count(&self) -> app::Result<usize> {\n        self.admins.len()\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h4,{id:"vector",children:"Vector"}),"\n",(0,t.jsx)(n.p,{children:"A dynamic array implementation:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'use calimero_storage::collections::Vector;\n\n#[app::state]\n#[derive(Default, BorshSerialize, BorshDeserialize)]\n#[borsh(crate = "calimero_sdk::borsh")]\nstruct TaskManager {\n    tasks: Vector<Task>,\n    completed_tasks: Vector<Task>,\n}\n\n#[app::logic]\nimpl TaskManager {\n    pub fn add_task(&mut self, task: Task) -> app::Result<()> {\n        self.tasks.insert(None, task)?;\n        Ok(())\n    }\n\n    pub fn complete_task(&mut self, index: u32) -> app::Result<()> {\n        if index >= self.tasks.len()? {\n            return app::bail!("Invalid task index");\n        }\n\n        let task = self.tasks.remove(index as usize)?;\n        self.completed_tasks.insert(None, task)?;\n        Ok(())\n    }\n\n    pub fn get_task(&self, index: u32) -> app::Result<Option<Task>> {\n        if index >= self.tasks.len()? {\n            return Ok(None);\n        }\n        self.tasks.get(index as usize)\n    }\n\n    pub fn get_all_tasks(&self) -> app::Result<Vec<Task>> {\n        self.tasks.entries()?.collect()\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"advanced-collection-patterns",children:"Advanced Collection Patterns"}),"\n",(0,t.jsx)(n.h4,{id:"nested-collections",children:"Nested Collections"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'#[app::state]\n#[derive(Default, BorshSerialize, BorshDeserialize)]\n#[borsh(crate = "calimero_sdk::borsh")]\nstruct SocialNetwork {\n    // User -> List of friends\n    friendships: UnorderedMap<String, UnorderedSet<String>>,\n    // User -> List of posts\n    user_posts: UnorderedMap<String, Vector<Post>>,\n    // Post -> List of likes\n    post_likes: UnorderedMap<u64, UnorderedSet<String>>,\n}\n\n#[app::logic]\nimpl SocialNetwork {\n    pub fn add_friend(&mut self, user: String, friend: String) -> app::Result<()> {\n        // Add bidirectional friendship\n        self.friendships\n            .entry(user.clone())\n            .or_insert_with(|| UnorderedSet::new())\n            .insert(friend.clone())?;\n\n        self.friendships\n            .entry(friend)\n            .or_insert_with(|| UnorderedSet::new())\n            .insert(user)?;\n\n        Ok(())\n    }\n\n    pub fn get_friends(&self, user: &str) -> app::Result<Vec<String>> {\n        Ok(self.friendships\n            .get(user)?\n            .map(|friends| friends.entries()?.collect())\n            .unwrap_or_default())\n    }\n\n    pub fn add_post(&mut self, user: String, post: Post) -> app::Result<()> {\n        self.user_posts\n            .entry(user.clone())\n            .or_insert_with(|| Vector::new())\n            .insert(None, post)?;\n        Ok(())\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h4,{id:"collection-iterators",children:"Collection Iterators"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"#[app::logic]\nimpl MyApp {\n    pub fn get_all_users(&self) -> app::Result<Vec<UserProfile>> {\n        self.users.entries()?.collect()\n    }\n\n    pub fn search_users(&self, query: &str) -> app::Result<Vec<UserProfile>> {\n        Ok(self.users\n            .entries()?\n            .filter(|(username, _)| username.contains(query))\n            .map(|(_, profile)| profile)\n            .collect())\n    }\n\n    pub fn get_active_users(&self) -> app::Result<Vec<UserProfile>> {\n        Ok(self.users\n            .entries()?\n            .filter(|(_, profile)| profile.is_active)\n            .map(|(_, profile)| profile)\n            .collect())\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"events-and-event-handling",children:"Events and Event Handling"}),"\n",(0,t.jsx)(n.h3,{id:"event-definition",children:"Event Definition"}),"\n",(0,t.jsx)(n.p,{children:"Events in Calimero use lifetime parameters for efficient string handling:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"#[app::event]\npub enum AppEvent<'a> {\n    UserCreated { username: &'a str, timestamp: u64 },\n    UserUpdated { username: &'a str, field: &'a str },\n    UserDeleted { username: &'a str },\n    SettingsChanged { key: &'a str, old_value: &'a str, new_value: &'a str },\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"event-emission",children:"Event Emission"}),"\n",(0,t.jsxs)(n.p,{children:["Events are emitted using the ",(0,t.jsx)(n.code,{children:"app::emit!"})," macro and are only recorded if the\ntransaction succeeds:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'#[app::logic]\nimpl MyApp {\n    pub fn create_user(&mut self, username: String, profile: UserProfile) -> app::Result<()> {\n        app::log!("Creating user: {}", username);\n\n        if self.users.contains_key(&username)? {\n            return app::bail!("User already exists");\n        }\n\n        self.users.insert(username.clone(), profile)?;\n\n        app::emit!(AppEvent::UserCreated {\n            username: &username,\n            timestamp: env::block_timestamp(),\n        });\n\n        Ok(())\n    }\n\n    pub fn update_user(&mut self, username: String, new_profile: UserProfile) -> app::Result<()> {\n        app::log!("Updating user: {}", username);\n\n        let old_profile = self.users.get(&username)?\n            .ok_or_else(|| app::err!("User not found"))?;\n\n        self.users.insert(username.clone(), new_profile)?;\n\n        app::emit!(AppEvent::UserUpdated {\n            username: &username,\n            field: "profile",\n        });\n\n        Ok(())\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"event-patterns",children:"Event Patterns"}),"\n",(0,t.jsx)(n.h4,{id:"batch-events",children:"Batch Events"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'#[app::logic]\nimpl MyApp {\n    pub fn bulk_create_users(&mut self, users: Vec<(String, UserProfile)>) -> app::Result<()> {\n        let mut created_count = 0;\n\n        for (username, profile) in users {\n            if !self.users.contains_key(&username)? {\n                self.users.insert(username.clone(), profile)?;\n                created_count += 1;\n\n                app::emit!(AppEvent::UserCreated {\n                    username: &username,\n                    timestamp: env::block_timestamp(),\n                });\n            }\n        }\n\n        app::log!("Created {} new users", created_count);\n        Ok(())\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h4,{id:"conditional-events",children:"Conditional Events"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'#[app::logic]\nimpl MyApp {\n    pub fn update_user_if_changed(&mut self, username: String, new_profile: UserProfile) -> app::Result<bool> {\n        let old_profile = match self.users.get(&username)? {\n            Some(profile) => profile,\n            None => return Ok(false),\n        };\n\n        if old_profile == new_profile {\n            return Ok(false); // No change, no event\n        }\n\n        self.users.insert(username.clone(), new_profile)?;\n\n        app::emit!(AppEvent::UserUpdated {\n            username: &username,\n            field: "profile",\n        });\n\n        Ok(true) // Changed\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"advanced-macros",children:"Advanced Macros"}),"\n",(0,t.jsx)(n.h3,{id:"macro-composition",children:"Macro Composition"}),"\n",(0,t.jsx)(n.p,{children:"Macros can be combined for complex functionality:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"#[app::state(emits = for<'a> AppEvent<'a>)]\n#[derive(Default, BorshSerialize, BorshDeserialize)]\n#[borsh(crate = \"calimero_sdk::borsh\")]\nstruct AdvancedApp {\n    users: UnorderedMap<String, UserProfile>,\n    audit_log: Vector<AuditEntry>,\n}\n\n#[app::logic]\nimpl AdvancedApp {\n    #[app::init]\n    pub fn init() -> Self {\n        Self {\n            users: UnorderedMap::new(),\n            audit_log: Vector::new(),\n        }\n    }\n\n    pub fn perform_action(&mut self, action: Action) -> app::Result<()> {\n        // Log the action\n        let entry = AuditEntry {\n            action: action.clone(),\n            timestamp: env::block_timestamp(),\n            user: env::predecessor_account_id().to_string(),\n        };\n        self.audit_log.insert(None, entry)?;\n\n        // Perform the action\n        match action {\n            Action::CreateUser { username, profile } => {\n                self.create_user(username, profile)?;\n            }\n            Action::UpdateUser { username, profile } => {\n                self.update_user(username, profile)?;\n            }\n            Action::DeleteUser { username } => {\n                self.delete_user(username)?;\n            }\n        }\n\n        Ok(())\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"custom-error-types",children:"Custom Error Types"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'#[derive(Debug, thiserror::Error)]\npub enum AppError {\n    #[error("User not found: {0}")]\n    UserNotFound(String),\n    #[error("Invalid operation: {0}")]\n    InvalidOperation(String),\n    #[error("Insufficient permissions")]\n    InsufficientPermissions,\n}\n\nimpl From<AppError> for calimero_sdk::types::Error {\n    fn from(err: AppError) -> Self {\n        calimero_sdk::types::Error::msg(err.to_string())\n    }\n}\n\n#[app::logic]\nimpl MyApp {\n    pub fn admin_only_operation(&mut self, username: String) -> app::Result<()> {\n        if !self.is_admin(&env::predecessor_account_id().to_string())? {\n            return Err(AppError::InsufficientPermissions.into());\n        }\n\n        // Perform admin operation\n        Ok(())\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"advanced-macro-features",children:"Advanced Macro Features"}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Note"}),": Some of these advanced macro features may be planned for future\nreleases or available in different versions of the SDK. Check the latest SDK\ndocumentation for current availability."]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"custom-state-configuration",children:"Custom State Configuration"}),"\n",(0,t.jsx)(n.p,{children:"Advanced state configuration with metadata and versioning:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'#[app::state(\n    emits = for<\'a> AppEvent<\'a>,\n    version = "1.0.0",\n    name = "UserManagementApp"\n)]\n#[derive(Default, BorshSerialize, BorshDeserialize)]\n#[borsh(crate = "calimero_sdk::borsh")]\nstruct UserManagementApp {\n    users: UnorderedMap<String, UserProfile>,\n    settings: AppSettings,\n}\n\n#[derive(BorshSerialize, BorshDeserialize, Default)]\nstruct AppSettings {\n    max_users: u32,\n    allow_public_profiles: bool,\n    maintenance_mode: bool,\n}\n\n#[app::logic]\nimpl UserManagementApp {\n    pub fn create_user(&mut self, username: String, profile: UserProfile) -> app::Result<()> {\n        // Check maintenance mode\n        if self.settings.maintenance_mode {\n            return app::bail!("Application is in maintenance mode");\n        }\n\n        // Check user limit\n        if self.users.len()? >= self.settings.max_users {\n            return app::bail!("Maximum user limit reached");\n        }\n\n        if self.users.contains_key(&username)? {\n            return app::bail!("User already exists");\n        }\n\n        self.users.insert(username.clone(), profile)?;\n\n        app::emit!(AppEvent::UserCreated {\n            username: &username,\n            timestamp: env::block_timestamp(),\n        });\n\n        Ok(())\n    }\n\n    pub fn update_settings(&mut self, new_settings: AppSettings) -> app::Result<()> {\n        // Validate settings\n        if new_settings.max_users < self.users.len()? as u32 {\n            return app::bail!("Cannot reduce max users below current user count");\n        }\n\n        self.settings = new_settings;\n        Ok(())\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h4,{id:"access-control-patterns",children:"Access Control Patterns"}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Note"}),": While these specific macros may not be implemented, the patterns\nshown here demonstrate how to implement access control using the available SDK\nfeatures."]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'#[app::logic]\nimpl UserManagementApp {\n    // Admin-only operations\n    pub fn admin_only_operation(&mut self, username: String) -> app::Result<()> {\n        if !self.is_admin(&env::predecessor_account_id().to_string())? {\n            return app::bail!("Admin access required");\n        }\n\n        // Perform admin operation\n        Ok(())\n    }\n\n    // Moderator or admin operations\n    pub fn moderator_or_admin_operation(&mut self, username: String) -> app::Result<()> {\n        let caller = env::predecessor_account_id().to_string();\n\n        if !self.is_admin(&caller)? && !self.is_moderator(&caller)? {\n            return app::bail!("Moderator or admin access required");\n        }\n\n        // Perform operation\n        Ok(())\n    }\n\n    // Role-based access control\n    pub fn role_based_operation(&mut self, username: String, required_role: UserRole) -> app::Result<()> {\n        let caller = env::predecessor_account_id().to_string();\n        let caller_role = self.get_user_role(&caller)?;\n\n        if !self.has_permission(caller_role, required_role)? {\n            return app::bail!("Insufficient permissions for this operation");\n        }\n\n        // Perform operation\n        Ok(())\n    }\n\n    fn has_permission(&self, user_role: UserRole, required_role: UserRole) -> app::Result<bool> {\n        match (user_role, required_role) {\n            (UserRole::Admin, _) => Ok(true), // Admin can do everything\n            (UserRole::Moderator, UserRole::Moderator | UserRole::User) => Ok(true),\n            (UserRole::User, UserRole::User) => Ok(true),\n            _ => Ok(false),\n        }\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h4,{id:"conditional-logic-and-state-management",children:"Conditional Logic and State Management"}),"\n",(0,t.jsx)(n.p,{children:"Advanced patterns for conditional operations and state transitions:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'#[app::logic]\nimpl UserManagementApp {\n    pub fn conditional_user_operation(&mut self, username: String, operation: UserOperation) -> app::Result<()> {\n        // Check application state\n        if self.settings.maintenance_mode {\n            return app::bail!("Application is in maintenance mode");\n        }\n\n        // Check user state\n        let user = self.users.get(&username)?\n            .ok_or_else(|| app::err!("User not found"))?;\n\n        if !user.is_active {\n            return app::bail!("User account is not active");\n        }\n\n        // Perform operation based on user role\n        match operation {\n            UserOperation::UpdateProfile(profile) => {\n                if !self.can_update_profile(&username, &profile)? {\n                    return app::bail!("Cannot update profile with current permissions");\n                }\n                self.users.insert(username, profile)?;\n            }\n            UserOperation::ChangeRole(new_role) => {\n                if !self.can_change_role(&username, new_role)? {\n                    return app::bail!("Cannot change role with current permissions");\n                }\n                let mut updated_user = user.clone();\n                updated_user.role = new_role;\n                self.users.insert(username, updated_user)?;\n            }\n            UserOperation::Suspend(reason) => {\n                if !self.can_suspend_user(&username)? {\n                    return app::bail!("Cannot suspend user with current permissions");\n                }\n                let mut updated_user = user.clone();\n                updated_user.status = UserStatus::Suspended(reason);\n                self.users.insert(username, updated_user)?;\n            }\n        }\n\n        Ok(())\n    }\n\n    fn can_update_profile(&self, username: &str, profile: &UserProfile) -> app::Result<bool> {\n        let caller = env::predecessor_account_id().to_string();\n\n        // Users can update their own profile\n        if caller == *username {\n            return Ok(true);\n        }\n\n        // Admins can update any profile\n        if self.is_admin(&caller)? {\n            return Ok(true);\n        }\n\n        // Check if profile is public and caller has permission\n        if profile.is_public && self.settings.allow_public_profiles {\n            return Ok(true);\n        }\n\n        Ok(false)\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"state-management-patterns",children:"State Management Patterns"}),"\n",(0,t.jsx)(n.h3,{id:"immutable-state-access",children:"Immutable State Access"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"#[app::logic]\nimpl MyApp {\n    pub fn get_user_stats(&self) -> app::Result<UserStats> {\n        let mut stats = UserStats::default();\n\n        for (_, profile) in self.users.entries()? {\n            stats.total_users += 1;\n            if profile.is_active {\n                stats.active_users += 1;\n            }\n            if profile.is_premium {\n                stats.premium_users += 1;\n            }\n        }\n\n        Ok(stats)\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"mutable-state-with-validation",children:"Mutable State with Validation"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'#[app::logic]\nimpl MyApp {\n    pub fn transfer_user(&mut self, from: String, to: String) -> app::Result<()> {\n        // Validate input\n        if from == to {\n            return app::bail!("Cannot transfer user to same account");\n        }\n\n        // Check source user exists\n        let profile = self.users.get(&from)?\n            .ok_or_else(|| app::err!("Source user not found"))?;\n\n        // Check destination doesn\'t exist\n        if self.users.contains_key(&to)? {\n            return app::bail!("Destination user already exists");\n        }\n\n        // Perform transfer atomically\n        self.users.remove(&from)?;\n        self.users.insert(to, profile)?;\n\n        app::emit!(AppEvent::UserTransferred {\n            from: &from,\n            to: &to,\n        });\n\n        Ok(())\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"state-initialization-patterns",children:"State Initialization Patterns"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'#[app::logic]\nimpl MyApp {\n    #[app::init]\n    pub fn init() -> Self {\n        Self {\n            users: UnorderedMap::new(),\n            settings: UnorderedMap::new(),\n            metadata: AppMetadata {\n                version: "1.0.0".to_string(),\n                created_at: env::block_timestamp(),\n            },\n        }\n    }\n\n    #[app::init]\n    pub fn init_with_config(config: AppConfig) -> Self {\n        let mut app = Self::init();\n\n        // Apply configuration\n        for (key, value) in config.default_settings {\n            app.settings.insert(key, value).expect("Failed to set default");\n        }\n\n        app\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,t.jsx)(n.h3,{id:"efficient-iteration",children:"Efficient Iteration"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"#[app::logic]\nimpl MyApp {\n    // \u2705 Good: Use references to avoid cloning\n    pub fn get_active_users(&self) -> app::Result<Vec<&UserProfile>> {\n        Ok(self.users\n            .entries()?\n            .filter(|(_, profile)| profile.is_active)\n            .map(|(_, profile)| profile)\n            .collect())\n    }\n\n    // \u274c Bad: Unnecessary cloning\n    pub fn get_active_users_bad(&self) -> app::Result<Vec<UserProfile>> {\n        Ok(self.users\n            .entries()?\n            .filter(|(_, profile)| profile.is_active)\n            .map(|(_, profile)| profile.clone()) // Unnecessary clone\n            .collect())\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"batch-operations",children:"Batch Operations"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"#[app::logic]\nimpl MyApp {\n    pub fn bulk_update_users(&mut self, updates: Vec<(String, UserProfile)>) -> app::Result<()> {\n        for (username, profile) in updates {\n            self.users.insert(username, profile)?;\n        }\n        Ok(())\n    }\n\n    pub fn bulk_remove_users(&mut self, usernames: Vec<String>) -> app::Result<usize> {\n        let mut removed_count = 0;\n        for username in usernames {\n            if self.users.remove(&username)?.is_some() {\n                removed_count += 1;\n            }\n        }\n        Ok(removed_count)\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"memory-management",children:"Memory Management"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'#[app::logic]\nimpl MyApp {\n    pub fn cleanup_old_data(&mut self, cutoff_timestamp: u64) -> app::Result<usize> {\n        let mut to_remove = Vec::new();\n\n        // Collect items to remove\n        for (key, profile) in self.users.entries()? {\n            if profile.last_activity < cutoff_timestamp {\n                to_remove.push(key);\n            }\n        }\n\n        // Remove old items\n        let mut removed_count = 0;\n        for key in to_remove {\n            if self.users.remove(&key)?.is_some() {\n                removed_count += 1;\n            }\n        }\n\n        app::log!("Cleaned up {} old user profiles", removed_count);\n        Ok(removed_count)\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"testing-and-debugging",children:"Testing and Debugging"}),"\n",(0,t.jsx)(n.h3,{id:"logging-best-practices",children:"Logging Best Practices"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'#[app::logic]\nimpl MyApp {\n    pub fn complex_operation(&mut self, input: ComplexInput) -> app::Result<ComplexOutput> {\n        app::log!("Starting complex operation with input: {:?}", input);\n\n        // Step 1: Validation\n        app::log!("Step 1: Validating input");\n        self.validate_input(&input)?;\n\n        // Step 2: Processing\n        app::log!("Step 2: Processing input");\n        let intermediate = self.process_input(input)?;\n\n        // Step 3: Finalization\n        app::log!("Step 3: Finalizing operation");\n        let result = self.finalize_operation(intermediate)?;\n\n        app::log!("Complex operation completed successfully");\n        Ok(result)\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"error-context",children:"Error Context"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'#[app::logic]\nimpl MyApp {\n    pub fn get_user_with_context(&self, username: &str) -> app::Result<UserProfile> {\n        self.users.get(username)\n            .map_err(|e| {\n                app::log!("Failed to get user \'{}\': {:?}", username, e);\n                e\n            })?\n            .ok_or_else(|| {\n                app::log!("User \'{}\' not found", username);\n                app::err!("User not found: {}", username)\n            })\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"unit-testing",children:"Unit Testing"}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Note"}),": While the Calimero SDK doesn't provide built-in testing macros, you\ncan use standard Rust testing approaches. Here are examples of how to\nstructure tests for your Calimero applications."]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'#[cfg(test)]\nmod tests {\n    use super::*;\n    use calimero_storage::collections::UnorderedMap;\n\n    // Mock storage for testing\n    struct MockStorage;\n\n    impl StorageAdaptor for MockStorage {\n        // Implement mock storage methods for testing\n    }\n\n    #[test]\n    fn test_user_creation() {\n        let mut app = UserManagementApp::default();\n        let profile = UserProfile::default();\n\n        let result = app.create_user("test_user".to_string(), profile);\n        assert!(result.is_ok());\n        assert!(app.users.contains_key("test_user").unwrap());\n    }\n\n    #[test]\n    fn test_duplicate_user_creation() {\n        let mut app = UserManagementApp::default();\n        let profile = UserProfile::default();\n\n        app.create_user("test_user".to_string(), profile.clone()).unwrap();\n        let result = app.create_user("test_user".to_string(), profile);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_user_update() {\n        let mut app = UserManagementApp::default();\n        let profile = UserProfile::default();\n        let updated_profile = UserProfile {\n            name: "Updated Name".to_string(),\n            ..profile.clone()\n        };\n\n        app.create_user("test_user".to_string(), profile).unwrap();\n        let result = app.update_user("test_user".to_string(), updated_profile);\n        assert!(result.is_ok());\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"debug-logging-and-state-inspection",children:"Debug Logging and State Inspection"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'#[app::logic]\nimpl MyApp {\n    pub fn debug_state(&self) -> app::Result<String> {\n        let user_count = self.users.len()?;\n        let active_users = self.users.entries()?\n            .filter(|(_, profile)| profile.is_active)\n            .count();\n\n        let debug_info = format!(\n            "Users: {}, Active: {}, Settings: {:?}",\n            user_count,\n            active_users,\n            self.settings\n        );\n\n        app::log!("Debug state: {}", debug_info);\n        Ok(debug_info)\n    }\n\n    pub fn validate_integrity(&self) -> app::Result<Vec<String>> {\n        let mut issues = Vec::new();\n\n        // Check for orphaned references\n        for (username, profile) in self.users.entries()? {\n            if let Some(referenced_user) = &profile.referenced_by {\n                if !self.users.contains_key(referenced_user)? {\n                    issues.push(format!("User \'{}\' references non-existent user \'{}\'", username, referenced_user));\n                }\n            }\n        }\n\n        // Check for circular references\n        // ... implementation details ...\n\n        if !issues.is_empty() {\n            app::log!("Integrity check found {} issues: {:?}", issues.len(), issues);\n        }\n\n        Ok(issues)\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"performance-monitoring",children:"Performance Monitoring"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'#[app::logic]\nimpl MyApp {\n    pub fn performance_metrics(&self) -> app::Result<PerformanceMetrics> {\n        let start_time = std::time::Instant::now();\n\n        let user_count = self.users.len()?;\n        let storage_size = self.estimate_storage_size()?;\n        let operation_count = self.get_operation_count()?;\n\n        let metrics = PerformanceMetrics {\n            user_count,\n            storage_size,\n            operation_count,\n            response_time: start_time.elapsed().as_millis() as u64,\n        };\n\n        app::log!("Performance metrics: {:?}", metrics);\n        Ok(metrics)\n    }\n\n    fn estimate_storage_size(&self) -> app::Result<usize> {\n        // Estimate storage size based on collection contents\n        let mut total_size = 0;\n\n        for (_, profile) in self.users.entries()? {\n            total_size += std::mem::size_of_val(&profile);\n        }\n\n        Ok(total_size)\n    }\n}\n\n#[derive(Debug)]\nstruct PerformanceMetrics {\n    user_count: usize,\n    storage_size: usize,\n    operation_count: u64,\n    response_time: u64,\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"common-patterns-and-anti-patterns",children:"Common Patterns and Anti-patterns"}),"\n",(0,t.jsx)(n.h3,{id:"-good-patterns",children:"\u2705 Good Patterns"}),"\n",(0,t.jsx)(n.h4,{id:"atomic-operations",children:"Atomic Operations"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'#[app::logic]\nimpl MyApp {\n    pub fn atomic_user_update(&mut self, username: String, updates: UserUpdates) -> app::Result<()> {\n        // All operations are atomic - if any fail, all changes are rolled back\n        let mut profile = self.users.get(&username)?\n            .ok_or_else(|| app::err!("User not found"))?;\n\n        // Apply updates\n        if let Some(name) = updates.name {\n            profile.name = name;\n        }\n        if let Some(email) = updates.email {\n            profile.email = email;\n        }\n\n        // Save updated profile\n        self.users.insert(username, profile)?;\n\n        app::emit!(AppEvent::UserUpdated {\n            username: &username,\n            field: "profile",\n        });\n\n        Ok(())\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h4,{id:"proper-error-handling",children:"Proper Error Handling"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'#[app::logic]\nimpl MyApp {\n    pub fn safe_user_operation(&mut self, username: &str) -> app::Result<()> {\n        // Handle all possible error cases\n        match self.users.get(username)? {\n            Some(profile) => {\n                if profile.is_active {\n                    // Perform operation\n                    Ok(())\n                } else {\n                    app::bail!("User is not active")\n                }\n            }\n            None => app::bail!("User not found"),\n        }\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"-anti-patterns",children:"\u274c Anti-patterns"}),"\n",(0,t.jsx)(n.h4,{id:"ignoring-errors",children:"Ignoring Errors"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"// \u274c Bad: Ignoring collection operation results\npub fn bad_user_operation(&mut self, username: String) {\n    self.users.insert(username, UserProfile::default()); // Ignoring Result\n}\n\n// \u2705 Good: Handle errors properly\npub fn good_user_operation(&mut self, username: String) -> app::Result<()> {\n    self.users.insert(username, UserProfile::default())?;\n    Ok(())\n}\n"})}),"\n",(0,t.jsx)(n.h4,{id:"unnecessary-cloning",children:"Unnecessary Cloning"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"// \u274c Bad: Cloning when references would suffice\npub fn bad_get_users(&self) -> app::Result<Vec<String>> {\n    Ok(self.users.entries()?\n        .map(|(k, _)| k.clone()) // Unnecessary clone\n        .collect())\n}\n\n// \u2705 Good: Use references\npub fn good_get_users(&self) -> app::Result<Vec<&String>> {\n    Ok(self.users.entries()?\n        .map(|(k, _)| k) // No clone needed\n        .collect())\n}\n"})}),"\n",(0,t.jsx)(n.h4,{id:"complex-nested-operations",children:"Complex Nested Operations"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'// \u274c Bad: Deep nesting makes error handling complex\npub fn bad_nested_operation(&mut self, user_id: &str) -> app::Result<()> {\n    if let Some(user) = self.users.get(user_id)? {\n        if let Some(profile) = user.profile {\n            if let Some(settings) = profile.settings {\n                // Deep nesting makes this hard to read and maintain\n                settings.update()?;\n            }\n        }\n    }\n    Ok(())\n}\n\n// \u2705 Good: Early returns for cleaner code\npub fn good_nested_operation(&mut self, user_id: &str) -> app::Result<()> {\n    let user = self.users.get(user_id)?\n        .ok_or_else(|| app::err!("User not found"))?;\n\n    let profile = user.profile\n        .ok_or_else(|| app::err!("User profile not found"))?;\n\n    let settings = profile.settings\n        .ok_or_else(|| app::err!("User settings not found"))?;\n\n    settings.update()?;\n    Ok(())\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Learn about ",(0,t.jsx)(n.a,{href:"./calimero-collections",children:"Calimero Collections"})," for data storage"]}),"\n",(0,t.jsxs)(n.li,{children:["See ",(0,t.jsx)(n.a,{href:"./protocol-rs-sdk",children:"Rust Protocol SDK"})," for basic macro usage"]}),"\n"]})]})}function c(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(u,{...e})}):u(e)}},48854:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>o});var r=s(30758);const t={},i=r.createContext(t);function a(e){const n=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);