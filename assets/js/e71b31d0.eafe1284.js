"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[4878],{23630:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>c,frontMatter:()=>l,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"developer-tools/SDK/protocol-sdk/rust-sdk-deep-dive","title":"Rust SDK Deep Dive","description":"This comprehensive guide covers advanced usage of the Calimero Rust SDK,","source":"@site/docs/05-developer-tools/02-SDK/03-protocol-sdk/03-rust-sdk-deep-dive.mdx","sourceDirName":"05-developer-tools/02-SDK/03-protocol-sdk","slug":"/developer-tools/SDK/protocol-sdk/rust-sdk-deep-dive","permalink":"/developer-tools/SDK/protocol-sdk/rust-sdk-deep-dive","draft":false,"unlisted":false,"editUrl":"https://github.com/calimero-network/calimero-network.github.io/edit/master/docs/05-developer-tools/02-SDK/03-protocol-sdk/03-rust-sdk-deep-dive.mdx","tags":[],"version":"current","lastUpdatedAt":1755423442000,"sidebarPosition":3,"frontMatter":{"id":"rust-sdk-deep-dive","title":"Rust SDK Deep Dive"},"sidebar":"tutorialSidebar","previous":{"title":"Rust Protocol SDK","permalink":"/developer-tools/SDK/protocol-sdk/protocol-rs-sdk"},"next":{"title":"Calimero Collections Reference","permalink":"/developer-tools/SDK/protocol-sdk/calimero-collections"}}');var t=s(86070),i=s(74450);const l={id:"rust-sdk-deep-dive",title:"Rust SDK Deep Dive"},a="Rust SDK Deep Dive",o={},d=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Collections",id:"collections",level:2},{value:"Core Collections",id:"core-collections",level:3},{value:"UnorderedMap",id:"unorderedmap",level:4},{value:"UnorderedSet",id:"unorderedset",level:4},{value:"Vector",id:"vector",level:4},{value:"Advanced Collection Patterns",id:"advanced-collection-patterns",level:3},{value:"Nested Collections",id:"nested-collections",level:4},{value:"Collection Iterators",id:"collection-iterators",level:4},{value:"Events and Event Handling",id:"events-and-event-handling",level:2},{value:"Event Definition",id:"event-definition",level:3},{value:"Event Emission",id:"event-emission",level:3},{value:"Event Handling Patterns",id:"event-handling-patterns",level:3},{value:"Conditional Event Emission",id:"conditional-event-emission",level:4},{value:"Batch Event Emission",id:"batch-event-emission",level:4},{value:"Advanced Macros",id:"advanced-macros",level:2},{value:"Custom State Configuration",id:"custom-state-configuration",level:3},{value:"Conditional Logic",id:"conditional-logic",level:3},{value:"Access Control Macros",id:"access-control-macros",level:3},{value:"State Management Patterns",id:"state-management-patterns",level:2},{value:"Immutable State Access",id:"immutable-state-access",level:3},{value:"Mutable State with Validation",id:"mutable-state-with-validation",level:3},{value:"Performance Optimization",id:"performance-optimization",level:2},{value:"Efficient Collection Usage",id:"efficient-collection-usage",level:3},{value:"Memory Management",id:"memory-management",level:3},{value:"Testing and Debugging",id:"testing-and-debugging",level:2},{value:"Unit Testing",id:"unit-testing",level:3},{value:"Debug Logging",id:"debug-logging",level:3},{value:"Common Patterns and Anti-patterns",id:"common-patterns-and-anti-patterns",level:2},{value:"Good Patterns",id:"good-patterns",level:3},{value:"Anti-patterns to Avoid",id:"anti-patterns-to-avoid",level:3}];function u(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"rust-sdk-deep-dive",children:"Rust SDK Deep Dive"})}),"\n",(0,t.jsx)(n.p,{children:"This comprehensive guide covers advanced usage of the Calimero Rust SDK,\nincluding collections, events, macros, and best practices for building\nproduction applications."}),"\n",(0,t.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#collections",children:"Collections"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#events-and-event-handling",children:"Events and Event Handling"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#advanced-macros",children:"Advanced Macros"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#state-management-patterns",children:"State Management Patterns"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#performance-optimization",children:"Performance Optimization"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#testing-and-debugging",children:"Testing and Debugging"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#common-patterns-and-anti-patterns",children:"Common Patterns and Anti-patterns"})}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"collections",children:"Collections"}),"\n",(0,t.jsx)(n.p,{children:"Calimero provides a rich set of collections optimized for WebAssembly and\ndecentralized applications. These collections are designed to work efficiently\nwith the Calimero storage system."}),"\n",(0,t.jsx)(n.h3,{id:"core-collections",children:"Core Collections"}),"\n",(0,t.jsx)(n.h4,{id:"unorderedmap",children:"UnorderedMap"}),"\n",(0,t.jsx)(n.p,{children:"A hash map implementation optimized for Wasm:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'use calimero_storage::collections::UnorderedMap;\n\n#[app::state]\n#[derive(Default, BorshSerialize, BorshDeserialize)]\n#[borsh(crate = "calimero_sdk::borsh")]\nstruct MyApp {\n    users: UnorderedMap<String, UserProfile>,\n    settings: UnorderedMap<String, String>,\n}\n\n#[app::logic]\nimpl MyApp {\n    pub fn add_user(&mut self, username: String, profile: UserProfile) -> Result<(), String> {\n        if self.users.contains_key(&username) {\n            return Err("User already exists".to_string());\n        }\n\n        self.users.insert(username, profile);\n        Ok(())\n    }\n\n    pub fn get_user(&self, username: &str) -> Option<&UserProfile> {\n        self.users.get(username)\n    }\n\n    pub fn remove_user(&mut self, username: &str) -> Option<UserProfile> {\n        self.users.remove(username)\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h4,{id:"unorderedset",children:"UnorderedSet"}),"\n",(0,t.jsx)(n.p,{children:"A hash set for unique elements:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'use calimero_storage::collections::UnorderedSet;\n\n#[app::state]\n#[derive(Default, BorshSerialize, BorshDeserialize)]\n#[borsh(crate = "calimero_sdk::borsh")]\nstruct AccessControl {\n    admins: UnorderedSet<String>,\n    moderators: UnorderedSet<String>,\n}\n\n#[app::logic]\nimpl AccessControl {\n    pub fn add_admin(&mut self, username: String) {\n        self.admins.insert(username);\n    }\n\n    pub fn is_admin(&self, username: &str) -> bool {\n        self.admins.contains(username)\n    }\n\n    pub fn remove_admin(&mut self, username: &str) -> bool {\n        self.admins.remove(username)\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h4,{id:"vector",children:"Vector"}),"\n",(0,t.jsx)(n.p,{children:"A dynamic array implementation:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'use calimero_storage::collections::Vector;\n\n#[app::state]\n#[derive(Default, BorshSerialize, BorshDeserialize)]\n#[borsh(crate = "calimero_sdk::borsh")]\nstruct TaskManager {\n    tasks: Vector<Task>,\n    completed_tasks: Vector<Task>,\n}\n\n#[app::logic]\nimpl TaskManager {\n    pub fn add_task(&mut self, task: Task) {\n        self.tasks.push(task);\n    }\n\n    pub fn complete_task(&mut self, index: u32) -> Result<(), String> {\n        if index >= self.tasks.len() {\n            return Err("Invalid task index".to_string());\n        }\n\n        let task = self.tasks.remove(index as usize);\n        self.completed_tasks.push(task);\n        Ok(())\n    }\n\n    pub fn get_task(&self, index: u32) -> Option<&Task> {\n        self.tasks.get(index as usize)\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"advanced-collection-patterns",children:"Advanced Collection Patterns"}),"\n",(0,t.jsx)(n.h4,{id:"nested-collections",children:"Nested Collections"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'#[app::state]\n#[derive(Default, BorshSerialize, BorshDeserialize)]\n#[borsh(crate = "calimero_sdk::borsh")]\nstruct SocialNetwork {\n    // User -> List of friends\n    friendships: UnorderedMap<String, UnorderedSet<String>>,\n    // User -> List of posts\n    user_posts: UnorderedMap<String, Vector<Post>>,\n    // Post -> List of likes\n    post_likes: UnorderedMap<u64, UnorderedSet<String>>,\n}\n\n#[app::logic]\nimpl SocialNetwork {\n    pub fn add_friend(&mut self, user: String, friend: String) {\n        // Add bidirectional friendship\n        self.friendships\n            .entry(user.clone())\n            .or_insert_with(UnorderedSet::new)\n            .insert(friend.clone());\n\n        self.friendships\n            .entry(friend)\n            .or_insert_with(UnorderedSet::new)\n            .insert(user);\n    }\n\n    pub fn get_friends(&self, user: &str) -> Vec<&String> {\n        self.friendships\n            .get(user)\n            .map(|friends| friends.iter().collect())\n            .unwrap_or_default()\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h4,{id:"collection-iterators",children:"Collection Iterators"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"#[app::logic]\nimpl MyApp {\n    pub fn get_all_users(&self) -> Vec<&UserProfile> {\n        self.users.values().collect()\n    }\n\n    pub fn search_users(&self, query: &str) -> Vec<&UserProfile> {\n        self.users\n            .iter()\n            .filter(|(username, _)| username.contains(query))\n            .map(|(_, profile)| profile)\n            .collect()\n    }\n\n    pub fn get_active_users(&self) -> Vec<&UserProfile> {\n        self.users\n            .iter()\n            .filter(|(_, profile)| profile.is_active)\n            .map(|(_, profile)| profile)\n            .collect()\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"events-and-event-handling",children:"Events and Event Handling"}),"\n",(0,t.jsx)(n.p,{children:"Events are a powerful way to communicate state changes and enable reactive\napplications."}),"\n",(0,t.jsx)(n.h3,{id:"event-definition",children:"Event Definition"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"#[app::event]\npub enum UserEvent<'a> {\n    UserCreated {\n        username: &'a str,\n        timestamp: u64,\n    },\n    UserUpdated {\n        username: &'a str,\n        field: &'a str,\n        old_value: &'a str,\n        new_value: &'a str,\n    },\n    UserDeleted {\n        username: &'a str,\n        reason: &'a str,\n    },\n    FriendshipRequested {\n        from: &'a str,\n        to: &'a str,\n    },\n    FriendshipAccepted {\n        user1: &'a str,\n        user2: &'a str,\n    },\n}\n\n#[app::event]\npub enum SystemEvent<'a> {\n    MaintenanceMode { enabled: bool, reason: &'a str },\n    PerformanceAlert { metric: &'a str, value: f64 },\n    ErrorOccurred { error: &'a str, context: &'a str },\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"event-emission",children:"Event Emission"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'#[app::logic]\nimpl MyApp {\n    pub fn create_user(&mut self, username: String, profile: UserProfile) -> Result<(), String> {\n        if self.users.contains_key(&username) {\n            return Err("User already exists".to_string());\n        }\n\n        self.users.insert(username.clone(), profile);\n\n        // Emit event\n        app::emit!(UserEvent::UserCreated {\n            username: &username,\n            timestamp: env::block_timestamp(),\n        });\n\n        Ok(())\n    }\n\n    pub fn update_user_profile(&mut self, username: String, new_profile: UserProfile) -> Result<(), String> {\n        let old_profile = self.users.get(&username)\n            .ok_or("User not found")?;\n\n        // Emit event before update\n        app::emit!(UserEvent::UserUpdated {\n            username: &username,\n            field: "profile",\n            old_value: &old_profile.to_string(),\n            new_value: &new_profile.to_string(),\n        });\n\n        self.users.insert(username, new_profile);\n        Ok(())\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"event-handling-patterns",children:"Event Handling Patterns"}),"\n",(0,t.jsx)(n.h4,{id:"conditional-event-emission",children:"Conditional Event Emission"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'#[app::logic]\nimpl MyApp {\n    pub fn process_friendship_request(&mut self, from: String, to: String) -> Result<(), String> {\n        // Check if users exist\n        if !self.users.contains_key(&from) || !self.users.contains_key(&to) {\n            return Err("One or both users do not exist".to_string());\n        }\n\n        // Check if already friends\n        if self.are_friends(&from, &to) {\n            return Err("Users are already friends".to_string());\n        }\n\n        // Emit event\n        app::emit!(UserEvent::FriendshipRequested {\n            from: &from,\n            to: &to,\n        });\n\n        // Add to pending requests\n        self.pending_requests.insert((from, to));\n        Ok(())\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h4,{id:"batch-event-emission",children:"Batch Event Emission"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'#[app::logic]\nimpl MyApp {\n    pub fn bulk_update_users(&mut self, updates: Vec<(String, UserProfile)>) -> Result<(), String> {\n        for (username, new_profile) in updates {\n            let old_profile = self.users.get(&username)\n                .ok_or(format!("User {} not found", username))?;\n\n            // Emit individual update events\n            app::emit!(UserEvent::UserUpdated {\n                username: &username,\n                field: "profile",\n                old_value: &old_profile.to_string(),\n                new_value: &new_profile.to_string(),\n            });\n\n            self.users.insert(username, new_profile);\n        }\n\n        Ok(())\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"advanced-macros",children:"Advanced Macros"}),"\n",(0,t.jsx)(n.h3,{id:"custom-state-configuration",children:"Custom State Configuration"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'#[app::state(\n    emits = for<\'a> UserEvent<\'a>,\n    version = "1.0.0",\n    name = "UserManagementApp"\n)]\n#[derive(Default, BorshSerialize, BorshDeserialize)]\n#[borsh(crate = "calimero_sdk::borsh")]\nstruct UserManagementApp {\n    users: UnorderedMap<String, UserProfile>,\n    settings: AppSettings,\n}\n\n#[derive(BorshSerialize, BorshDeserialize, Default)]\nstruct AppSettings {\n    max_users: u32,\n    allow_public_profiles: bool,\n    maintenance_mode: bool,\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"conditional-logic",children:"Conditional Logic"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'#[app::logic]\nimpl UserManagementApp {\n    pub fn create_user(&mut self, username: String, profile: UserProfile) -> Result<(), String> {\n        // Check maintenance mode\n        if self.settings.maintenance_mode {\n            return Err("Application is in maintenance mode".to_string());\n        }\n\n        // Check user limit\n        if self.users.len() >= self.settings.max_users {\n            return Err("Maximum user limit reached".to_string());\n        }\n\n        if self.users.contains_key(&username) {\n            return Err("User already exists".to_string());\n        }\n\n        self.users.insert(username.clone(), profile);\n\n        app::emit!(UserEvent::UserCreated {\n            username: &username,\n            timestamp: env::block_timestamp(),\n        });\n\n        Ok(())\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"access-control-macros",children:"Access Control Macros"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"#[app::logic]\nimpl UserManagementApp {\n    #[app::admin_only]\n    pub fn update_settings(&mut self, new_settings: AppSettings) {\n        self.settings = new_settings;\n    }\n\n    #[app::moderator_or_admin]\n    pub fn suspend_user(&mut self, username: String, reason: String) -> Result<(), String> {\n        // Implementation\n        Ok(())\n    }\n\n    pub fn get_public_profile(&self, username: &str) -> Option<&UserProfile> {\n        if !self.settings.allow_public_profiles {\n            return None;\n        }\n\n        self.users.get(username).filter(|profile| profile.is_public)\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"state-management-patterns",children:"State Management Patterns"}),"\n",(0,t.jsx)(n.h3,{id:"immutable-state-access",children:"Immutable State Access"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"#[app::logic]\nimpl UserManagementApp {\n    pub fn get_user_stats(&self) -> UserStats {\n        let total_users = self.users.len();\n        let active_users = self.users.values()\n            .filter(|profile| profile.is_active)\n            .count();\n        let premium_users = self.users.values()\n            .filter(|profile| profile.is_premium)\n            .count();\n\n        UserStats {\n            total: total_users as u32,\n            active: active_users as u32,\n            premium: premium_users as u32,\n        }\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"mutable-state-with-validation",children:"Mutable State with Validation"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'#[app::logic]\nimpl UserManagementApp {\n    pub fn update_user_role(&mut self, username: String, new_role: UserRole) -> Result<(), String> {\n        let user = self.users.get_mut(&username)\n            .ok_or("User not found")?;\n\n        // Validate role transition\n        if !self.is_valid_role_transition(&user.role, &new_role) {\n            return Err("Invalid role transition".to_string());\n        }\n\n        let old_role = user.role.clone();\n        user.role = new_role;\n\n        app::emit!(UserEvent::UserUpdated {\n            username: &username,\n            field: "role",\n            old_value: &old_role.to_string(),\n            new_value: &user.role.to_string(),\n        });\n\n        Ok(())\n    }\n\n    fn is_valid_role_transition(&self, from: &UserRole, to: &UserRole) -> bool {\n        match (from, to) {\n            (UserRole::User, UserRole::Moderator) => true,\n            (UserRole::Moderator, UserRole::Admin) => true,\n            (UserRole::User, UserRole::Admin) => false, // Must go through moderator\n            _ => false,\n        }\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,t.jsx)(n.h3,{id:"efficient-collection-usage",children:"Efficient Collection Usage"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'#[app::logic]\nimpl UserManagementApp {\n    // Use references to avoid cloning\n    pub fn get_users_by_role(&self, role: &UserRole) -> Vec<&UserProfile> {\n        self.users\n            .iter()\n            .filter(|(_, profile)| &profile.role == role)\n            .map(|(_, profile)| profile)\n            .collect()\n    }\n\n    // Batch operations for better performance\n    pub fn bulk_delete_users(&mut self, usernames: Vec<String>) -> Result<(), String> {\n        for username in usernames {\n            if let Some(profile) = self.users.remove(&username) {\n                app::emit!(UserEvent::UserDeleted {\n                    username: &username,\n                    reason: "Bulk deletion",\n                });\n            }\n        }\n        Ok(())\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"memory-management",children:"Memory Management"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"#[app::logic]\nimpl UserManagementApp {\n    // Clean up old data periodically\n    pub fn cleanup_old_data(&mut self, cutoff_timestamp: u64) {\n        let mut to_remove = Vec::new();\n\n        for (username, profile) in self.users.iter() {\n            if profile.last_seen < cutoff_timestamp {\n                to_remove.push(username.clone());\n            }\n        }\n\n        for username in to_remove {\n            self.users.remove(&username);\n        }\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"testing-and-debugging",children:"Testing and Debugging"}),"\n",(0,t.jsx)(n.h3,{id:"unit-testing",children:"Unit Testing"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_user_creation() {\n        let mut app = UserManagementApp::default();\n        let profile = UserProfile::default();\n\n        let result = app.create_user("test_user".to_string(), profile);\n        assert!(result.is_ok());\n        assert!(app.users.contains_key("test_user"));\n    }\n\n    #[test]\n    fn test_duplicate_user_creation() {\n        let mut app = UserManagementApp::default();\n        let profile = UserProfile::default();\n\n        app.create_user("test_user".to_string(), profile.clone()).unwrap();\n        let result = app.create_user("test_user".to_string(), profile);\n        assert!(result.is_err());\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"debug-logging",children:"Debug Logging"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'#[app::logic]\nimpl UserManagementApp {\n    pub fn debug_state(&self) -> String {\n        format!(\n            "Users: {}, Settings: {:?}, Maintenance: {}",\n            self.users.len(),\n            self.settings,\n            self.settings.maintenance_mode\n        )\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"common-patterns-and-anti-patterns",children:"Common Patterns and Anti-patterns"}),"\n",(0,t.jsx)(n.h3,{id:"good-patterns",children:"Good Patterns"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'// \u2705 Use events for important state changes\npub fn promote_user(&mut self, username: String) -> Result<(), String> {\n    let user = self.users.get_mut(&username)\n        .ok_or("User not found")?;\n\n    let old_role = user.role.clone();\n    user.role = UserRole::Moderator;\n\n    app::emit!(UserEvent::UserUpdated {\n        username: &username,\n        field: "role",\n        old_value: &old_role.to_string(),\n        new_value: &user.role.to_string(),\n    });\n\n    Ok(())\n}\n\n// \u2705 Validate input before processing\npub fn update_user_email(&mut self, username: String, email: String) -> Result<(), String> {\n    if !self.is_valid_email(&email) {\n        return Err("Invalid email format".to_string());\n    }\n\n    // Process update...\n    Ok(())\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"anti-patterns-to-avoid",children:"Anti-patterns to Avoid"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"// \u274c Don't emit events for every small change\npub fn update_user_last_seen(&mut self, username: String, timestamp: u64) {\n    if let Some(user) = self.users.get_mut(&username) {\n        user.last_seen = timestamp;\n        // Don't emit event for frequent updates like this\n    }\n}\n\n// \u274c Don't ignore errors\npub fn unsafe_user_creation(&mut self, username: String, profile: UserProfile) {\n    self.users.insert(username, profile); // What if username is empty?\n}\n"})})]})}function c(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(u,{...e})}):u(e)}},74450:(e,n,s)=>{s.d(n,{R:()=>l,x:()=>a});var r=s(30758);const t={},i=r.createContext(t);function l(e){const n=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);