"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[9285],{11882:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>i,contentTitle:()=>t,default:()=>d,frontMatter:()=>l,metadata:()=>o,toc:()=>p});const o=JSON.parse('{"id":"developer-tools/SDK/protocol-sdk/external-functions-and-proposals","title":"External Functions and Proposals","description":"This guide covers how to use Calimero\'s external proposal system to interact","source":"@site/docs/05-developer-tools/02-SDK/03-protocol-sdk/05-external-functions-and-proposals.mdx","sourceDirName":"05-developer-tools/02-SDK/03-protocol-sdk","slug":"/developer-tools/SDK/protocol-sdk/external-functions-and-proposals","permalink":"/developer-tools/SDK/protocol-sdk/external-functions-and-proposals","draft":false,"unlisted":false,"editUrl":"https://github.com/calimero-network/calimero-network.github.io/edit/master/docs/05-developer-tools/02-SDK/03-protocol-sdk/05-external-functions-and-proposals.mdx","tags":[],"version":"current","lastUpdatedAt":1759836146000,"sidebarPosition":5,"frontMatter":{"id":"external-functions-and-proposals","title":"External Functions and Proposals"},"sidebar":"tutorialSidebar","previous":{"title":"Calimero Collections Reference","permalink":"/developer-tools/SDK/protocol-sdk/calimero-collections"},"next":{"title":"Admin Dashboard","permalink":"/developer-tools/apps/admin-dashboard"}}');var a=r(86070),s=r(68820);const l={id:"external-functions-and-proposals",title:"External Functions and Proposals"},t="External Functions and Proposals",i={},p=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Overview",id:"overview",level:2},{value:"External Proposal System",id:"external-proposal-system",level:2},{value:"Core Components",id:"core-components",level:3},{value:"System Functions",id:"system-functions",level:3},{value:"Two Ways to Access External Functions",id:"two-ways-to-access-external-functions",level:2},{value:"1. Via <code>Self::external()</code> (Macro-Generated)",id:"1-via-selfexternal-macro-generated",level:3},{value:"2. Via Direct <code>External</code> Usage",id:"2-via-direct-external-usage",level:3},{value:"3. Both Approaches Are Equivalent",id:"3-both-approaches-are-equivalent",level:3},{value:"Proposal Actions",id:"proposal-actions",level:2},{value:"1. External Function Call",id:"1-external-function-call",level:3},{value:"2. Transfer",id:"2-transfer",level:3},{value:"3. Context Configuration",id:"3-context-configuration",level:3},{value:"4. Proposal Management",id:"4-proposal-management",level:3},{value:"Creating Proposals",id:"creating-proposals",level:2},{value:"Using DraftProposal Builder",id:"using-draftproposal-builder",level:3},{value:"Advanced Proposal Creation with Multiple Actions",id:"advanced-proposal-creation-with-multiple-actions",level:3},{value:"Manual Proposal Creation",id:"manual-proposal-creation",level:3},{value:"Approving Proposals",id:"approving-proposals",level:2},{value:"Basic Approval",id:"basic-approval",level:3},{value:"Approval with Validation",id:"approval-with-validation",level:3},{value:"Complete Examples",id:"complete-examples",level:2},{value:"Governance DAO Example",id:"governance-dao-example",level:3},{value:"Cross-Chain Bridge Example",id:"cross-chain-bridge-example",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Always Validate Proposals",id:"1-always-validate-proposals",level:3},{value:"2. Use Events for Tracking",id:"2-use-events-for-tracking",level:3},{value:"3. Implement Proper Error Handling",id:"3-implement-proper-error-handling",level:3},{value:"4. Use Batch Operations for Efficiency",id:"4-use-batch-operations-for-efficiency",level:3},{value:"Important Notes",id:"important-notes",level:2},{value:"\u2705 <strong>Both APIs Are Valid and Equivalent</strong>",id:"-both-apis-are-valid-and-equivalent",level:3},{value:"\ud83d\udd04 <strong>How It Actually Works</strong>",id:"-how-it-actually-works",level:3},{value:"\ud83d\udcda <strong>Next Steps</strong>",id:"-next-steps",level:3}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"external-functions-and-proposals",children:"External Functions and Proposals"})}),"\n",(0,a.jsx)(n.p,{children:"This guide covers how to use Calimero's external proposal system to interact\nwith external smart contracts, create proposals, and manage the governance\nsystem in Calimero applications."}),"\n",(0,a.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#overview",children:"Overview"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#external-proposal-system",children:"External Proposal System"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#two-ways-to-access-external-functions",children:"Two Ways to Access External Functions"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#proposal-actions",children:"Proposal Actions"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#creating-proposals",children:"Creating Proposals"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#approving-proposals",children:"Approving Proposals"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#complete-examples",children:"Complete Examples"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#best-practices",children:"Best Practices"})}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,a.jsx)(n.p,{children:"Calimero provides an external proposal system that allows your application to:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Create proposals"})," for external blockchain actions"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Approve proposals"})," through governance"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Execute external function calls"})," to other contracts"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Manage transfers"})," and ",(0,a.jsx)(n.a,{href:"/core-concepts/contexts",children:"context modifications"}),"\n(context refers to Calimero Application Networks)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Implement governance systems"})," with approval workflows"]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["The system is built around the ",(0,a.jsx)(n.code,{children:"External"})," struct and ",(0,a.jsx)(n.code,{children:"DraftProposal"})," builder\npattern, accessible through two different approaches."]}),"\n",(0,a.jsx)(n.h2,{id:"external-proposal-system",children:"External Proposal System"}),"\n",(0,a.jsx)(n.h3,{id:"core-components",children:"Core Components"}),"\n",(0,a.jsx)(n.p,{children:"The external proposal system consists of several key components:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'use calimero_sdk::env::ext::{External, DraftProposal, ProposalAction, ProposalId};\n\n// External interface for proposal management\nlet external = External;\n\n// Create a draft proposal\nlet draft = external.propose();\n\n// Build and send the proposal\nlet proposal_id = draft\n    .external_function_call("contract.near", "increment", "{}", 0)\n    .send();\n'})}),"\n",(0,a.jsx)(n.h3,{id:"system-functions",children:"System Functions"}),"\n",(0,a.jsx)(n.p,{children:"The system provides low-level WASM functions for proposal management:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"use calimero_sdk::sys;\n\n// Send a proposal (returns proposal ID)\nlet proposal_id = unsafe { sys::send_proposal(actions_buffer, result_buffer) };\n\n// Approve a proposal\nunsafe { sys::approve_proposal(proposal_id_buffer) };\n"})}),"\n",(0,a.jsx)(n.h2,{id:"two-ways-to-access-external-functions",children:"Two Ways to Access External Functions"}),"\n",(0,a.jsxs)(n.p,{children:["Calimero provides ",(0,a.jsx)(n.strong,{children:"two equivalent ways"})," to access external functionality:"]}),"\n",(0,a.jsxs)(n.h3,{id:"1-via-selfexternal-macro-generated",children:["1. Via ",(0,a.jsx)(n.code,{children:"Self::external()"})," (Macro-Generated)"]}),"\n",(0,a.jsxs)(n.p,{children:["When you use ",(0,a.jsx)(n.code,{children:"#[app::state]"})," on your struct, the macro system automatically\ngenerates a ",(0,a.jsx)(n.code,{children:"Self::external()"})," method:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'#[app::state]\n#[derive(Default, BorshSerialize, BorshDeserialize)]\n#[borsh(crate = "calimero_sdk::borsh")]\nstruct MyApp {\n    // ... your app state\n}\n\n#[app::logic]\nimpl MyApp {\n    pub fn create_proposal(&mut self) -> ProposalId {\n        // \u2705 Self::external() is automatically generated by #[app::state] macro\n        Self::external()\n            .propose()\n            .external_function_call("contract.near", "increment", "{}", 0)\n            .send()\n    }\n\n    pub fn approve_proposal(&mut self, proposal_id: ProposalId) {\n        // \u2705 Self::external() works for approval too\n        Self::external().approve(proposal_id);\n    }\n}\n'})}),"\n",(0,a.jsxs)(n.h3,{id:"2-via-direct-external-usage",children:["2. Via Direct ",(0,a.jsx)(n.code,{children:"External"})," Usage"]}),"\n",(0,a.jsxs)(n.p,{children:["You can also use the ",(0,a.jsx)(n.code,{children:"External"})," struct directly:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'use calimero_sdk::env::ext::External;\n\n#[app::logic]\nimpl MyApp {\n    pub fn create_proposal(&mut self) -> ProposalId {\n        // \u2705 Direct External usage\n        External\n            .propose()\n            .external_function_call("contract.near", "increment", "{}", 0)\n            .send()\n    }\n\n    pub fn approve_proposal(&mut self, proposal_id: ProposalId) {\n        // \u2705 Direct External usage\n        External::approve(proposal_id);\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"3-both-approaches-are-equivalent",children:"3. Both Approaches Are Equivalent"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"// These two lines do exactly the same thing:\nSelf::external().approve(proposal_id);\nExternal::approve(proposal_id);\n\n// The macro generates this implementation:\nimpl MyApp {\n    fn external() -> ::calimero_sdk::env::ext::External {\n        ::calimero_sdk::env::ext::External {}\n    }\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Real-world example"}),": The\n",(0,a.jsx)(n.a,{href:"https://github.com/calimero-network/demo-blockchain-integrations",children:"demo-blockchain-integrations"}),"\nrepository uses ",(0,a.jsx)(n.code,{children:"Self::external()"})," extensively:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"// From demo-blockchain-integrations/logic/src/lib.rs\nSelf::external()\n    .propose()\n    .external_function_call(\n        receiver_id.to_string(),\n        method_name.to_string(),\n        args.to_string(),\n        deposit,\n    )\n    .send()\n"})}),"\n",(0,a.jsx)(n.h2,{id:"proposal-actions",children:"Proposal Actions"}),"\n",(0,a.jsx)(n.p,{children:"Calimero supports several types of proposal actions:"}),"\n",(0,a.jsx)(n.h3,{id:"1-external-function-call",children:"1. External Function Call"}),"\n",(0,a.jsx)(n.p,{children:"Execute a function on an external contract:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'use calimero_sdk::env::ext::{ProposalAction, AccountId};\n\nlet action = ProposalAction::ExternalFunctionCall {\n    receiver_id: AccountId("contract.near".to_string()),\n    method_name: "increment".to_string(),\n    args: "{}".to_string(),\n    deposit: 0,\n};\n'})}),"\n",(0,a.jsx)(n.h3,{id:"2-transfer",children:"2. Transfer"}),"\n",(0,a.jsx)(n.p,{children:"Transfer tokens to an account:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'let action = ProposalAction::Transfer {\n    receiver_id: AccountId("user.near".to_string()),\n    amount: 1_000_000_000_000_000_000_000_000, // 1 NEAR\n};\n'})}),"\n",(0,a.jsx)(n.h3,{id:"3-context-configuration",children:"3. Context Configuration"}),"\n",(0,a.jsx)(n.p,{children:"Modify application context settings:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'// Set number of required approvals\nlet action = ProposalAction::SetNumApprovals {\n    num_approvals: 3,\n};\n\n// Set active proposals limit\nlet action = ProposalAction::SetActiveProposalsLimit {\n    active_proposals_limit: 10,\n};\n\n// Set context value\nlet action = ProposalAction::SetContextValue {\n    key: b"config_key".to_vec().into_boxed_slice(),\n    value: b"config_value".to_vec().into_boxed_slice(),\n};\n'})}),"\n",(0,a.jsx)(n.h3,{id:"4-proposal-management",children:"4. Proposal Management"}),"\n",(0,a.jsx)(n.p,{children:"Delete existing proposals:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"let action = ProposalAction::DeleteProposal {\n    proposal_id: ProposalId([0u8; 32]),\n};\n"})}),"\n",(0,a.jsx)(n.h2,{id:"creating-proposals",children:"Creating Proposals"}),"\n",(0,a.jsx)(n.h3,{id:"using-draftproposal-builder",children:"Using DraftProposal Builder"}),"\n",(0,a.jsxs)(n.p,{children:["The recommended way to create proposals is using the ",(0,a.jsx)(n.code,{children:"DraftProposal"})," builder\npattern:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"use calimero_sdk::env::ext::{External, DraftProposal, AccountId};\n\n#[app::logic]\nimpl MyApp {\n    // Using Self::external() (macro-generated)\n    pub fn create_transfer_proposal_via_self(&mut self, receiver: String, amount: u128) -> ProposalId {\n        Self::external()\n            .propose()\n            .transfer(AccountId(receiver), amount)\n            .send()\n    }\n\n    // Using External directly\n    pub fn create_transfer_proposal_via_external(&mut self, receiver: String, amount: u128) -> ProposalId {\n        External\n            .propose()\n            .transfer(AccountId(receiver), amount)\n            .send()\n    }\n\n    pub fn create_function_call_proposal(\n        &mut self,\n        receiver_id: String,\n        method_name: String,\n        args: String,\n        deposit: u128,\n    ) -> ProposalId {\n        // Both approaches work identically\n        Self::external()\n            .propose()\n            .external_function_call(receiver_id, method_name, args, deposit)\n            .send()\n    }\n\n    pub fn create_context_modification_proposal(\n        &mut self,\n        key: Vec<u8>,\n        value: Vec<u8>,\n    ) -> ProposalId {\n        Self::external()\n            .propose()\n            .set_context_value(key.into_boxed_slice(), value.into_boxed_slice())\n            .send()\n    }\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"advanced-proposal-creation-with-multiple-actions",children:"Advanced Proposal Creation with Multiple Actions"}),"\n",(0,a.jsx)(n.p,{children:"Create complex proposals with multiple actions:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'#[app::logic]\nimpl MyApp {\n    pub fn create_complex_proposal(&mut self) -> ProposalId {\n        Self::external()\n            .propose()\n            .transfer(AccountId("treasury.near".to_string()), 1_000_000_000_000_000_000_000_000)\n            .external_function_call(\n                "governance.near".to_string(),\n                "propose_upgrade".to_string(),\n                r#"{"new_code_hash": "abc123"}"#.to_string(),\n                0,\n            )\n            .set_num_approvals(5)\n            .set_active_proposals_limit(20)\n            .send()\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"manual-proposal-creation",children:"Manual Proposal Creation"}),"\n",(0,a.jsx)(n.p,{children:"For advanced use cases, you can create proposals manually:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'use calimero_sdk::env::ext::{ProposalAction, ProposalId};\nuse calimero_sdk::sys;\n\n#[app::logic]\nimpl MyApp {\n    pub fn create_manual_proposal(&mut self, actions: Vec<ProposalAction>) -> ProposalId {\n        // Serialize actions to Borsh\n        let actions_data = borsh::to_vec(&actions)\n            .expect("Failed to serialize actions");\n\n        // Create buffer for result\n        let mut result_buffer = [0u8; 32];\n\n        // Send proposal using system function\n        unsafe {\n            sys::send_proposal(\n                calimero_sdk::sys::Buffer::from(&actions_data),\n                calimero_sdk::sys::BufferMut::new(&mut result_buffer)\n            )\n        }\n\n        ProposalId(result_buffer)\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"approving-proposals",children:"Approving Proposals"}),"\n",(0,a.jsx)(n.h3,{id:"basic-approval",children:"Basic Approval"}),"\n",(0,a.jsx)(n.p,{children:"Both approaches work identically:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"use calimero_sdk::env::ext::{External, ProposalId};\n\n#[app::logic]\nimpl MyApp {\n    // Using Self::external() (macro-generated)\n    pub fn approve_proposal_via_self(&mut self, proposal_id: ProposalId) {\n        Self::external().approve(proposal_id);\n    }\n\n    // Using External directly\n    pub fn approve_proposal_via_external(&mut self, proposal_id: ProposalId) {\n        External::approve(proposal_id);\n    }\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"approval-with-validation",children:"Approval with Validation"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'#[app::logic]\nimpl MyApp {\n    pub fn approve_proposal_with_validation(&mut self, proposal_id: ProposalId) -> Result<(), String> {\n        // Check if user can approve\n        if !self.can_approve_proposals(&env::predecessor_account_id()) {\n            return Err("Insufficient permissions to approve proposals".to_string());\n        }\n\n        // Check if proposal exists and is not already approved\n        if let Some(proposal) = self.proposals.get(&proposal_id) {\n            if proposal.approved {\n                return Err("Proposal already approved".to_string());\n            }\n\n            // Mark as approved locally\n            if let Some(mut proposal) = self.proposals.get_mut(&proposal_id) {\n                proposal.approved = true;\n                proposal.approver = Some(env::predecessor_account_id());\n            }\n\n            // Approve externally - both approaches work\n            Self::external().approve(proposal_id);\n            // OR: External::approve(proposal_id);\n\n            Ok(())\n        } else {\n            Err("Proposal not found".to_string())\n        }\n    }\n\n    fn can_approve_proposals(&self, user: &str) -> bool {\n        self.governance_members.contains(user)\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"complete-examples",children:"Complete Examples"}),"\n",(0,a.jsx)(n.h3,{id:"governance-dao-example",children:"Governance DAO Example"}),"\n",(0,a.jsxs)(n.p,{children:["This example implements a simple DAO where members can create treasury transfer\nproposals and approve them; proposal data is stored locally while\ncreation/approval is executed via the external proposal system\n(",(0,a.jsx)(n.code,{children:"Self::external()"})," / ",(0,a.jsx)(n.code,{children:"External"}),")."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'use calimero_sdk::{app, env, env::ext::{External, DraftProposal, ProposalAction, AccountId, ProposalId}};\nuse calimero_storage::collections::{UnorderedMap, UnorderedSet};\n\n#[app::state]\n#[derive(Default, BorshSerialize, BorshDeserialize)]\n#[borsh(crate = "calimero_sdk::borsh")]\nstruct DAO {\n    members: UnorderedSet<String>,\n    proposals: UnorderedMap<ProposalId, LocalProposal>,\n    treasury_balance: u128,\n}\n\n#[derive(BorshSerialize, BorshDeserialize)]\npub struct LocalProposal {\n    pub id: ProposalId,\n    pub creator: String,\n    pub actions: Vec<ProposalAction>,\n    pub approvals: UnorderedSet<String>,\n    pub executed: bool,\n    pub created_at: u64,\n}\n\n#[app::logic]\nimpl DAO {\n    #[app::init]\n    pub fn init(initial_members: Vec<String>) -> Self {\n        let mut members = UnorderedSet::new();\n        for member in initial_members {\n            members.insert(member);\n        }\n\n        Self {\n            members,\n            proposals: UnorderedMap::new(),\n            treasury_balance: 0,\n        }\n    }\n\n    pub fn create_treasury_transfer_proposal(\n        &mut self,\n        receiver_id: String,\n        amount: u128,\n    ) -> Result<ProposalId, String> {\n        if !self.members.contains(&env::predecessor_account_id()) {\n            return Err("Only members can create proposals".to_string());\n        }\n\n        if amount > self.treasury_balance {\n            return Err("Insufficient treasury balance".to_string());\n        }\n\n        // Create external proposal using Self::external() (macro-generated)\n        let proposal_id = Self::external()\n            .propose()\n            .transfer(AccountId(receiver_id.clone()), amount)\n            .send();\n\n        // Store proposal locally\n        let local_proposal = LocalProposal {\n            id: proposal_id,\n            creator: env::predecessor_account_id(),\n            actions: vec![ProposalAction::Transfer {\n                receiver_id: AccountId(receiver_id),\n                amount,\n            }],\n            approvals: UnorderedSet::new(),\n            executed: false,\n            created_at: env::block_timestamp(),\n        };\n\n        self.proposals.insert(proposal_id, local_proposal);\n\n        Ok(proposal_id)\n    }\n\n    pub fn approve_proposal(&mut self, proposal_id: ProposalId) -> Result<(), String> {\n        if !self.members.contains(&env::predecessor_account_id()) {\n            return Err("Only members can approve proposals".to_string());\n        }\n\n        let mut proposal = self.proposals.get_mut(&proposal_id)\n            .ok_or("Proposal not found")?;\n\n        if proposal.executed {\n            return Err("Proposal already executed".to_string());\n        }\n\n        let approver = env::predecessor_account_id();\n\n        if proposal.approvals.contains(&approver) {\n            return Err("Already approved this proposal".to_string());\n        }\n\n        // Add approval locally\n        proposal.approvals.insert(approver.clone());\n\n        // Approve externally - both approaches work identically\n        Self::external().approve(proposal_id);\n        // OR: External::approve(proposal_id);\n\n        Ok(())\n    }\n\n    pub fn get_proposal_status(&self, proposal_id: ProposalId) -> Option<ProposalStatus> {\n        self.proposals.get(&proposal_id).map(|proposal| {\n            if proposal.executed {\n                ProposalStatus::Executed\n            } else if proposal.approvals.len() >= 3 { // Assuming 3 approvals required\n                ProposalStatus::ReadyToExecute\n            } else {\n                ProposalStatus::PendingApproval {\n                    current_approvals: proposal.approvals.len() as u32,\n                    required: 3,\n                }\n            }\n        })\n    }\n}\n\n#[derive(BorshSerialize, BorshDeserialize)]\npub enum ProposalStatus {\n    PendingApproval { current_approvals: u32, required: u32 },\n    ReadyToExecute,\n    Executed,\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"cross-chain-bridge-example",children:"Cross-Chain Bridge Example"}),"\n",(0,a.jsx)(n.p,{children:"This example outlines a governance-controlled bridge flow: a local bridge\nproposal is created and persisted, while an external proposal triggers an\non-chain bridge contract (initiate_bridge); approvals are tracked locally, and\nin production you would map and approve the corresponding external ProposalId to\nexecute the bridge."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'use calimero_sdk::{app, env, env::ext::{External, DraftProposal, ProposalAction, AccountId}};\n\n#[app::state]\n#[derive(Default, BorshSerialize, BorshDeserialize)]\n#[borsh(crate = "calimero_sdk::borsh")]\nstruct CrossChainBridge {\n    bridge_operators: UnorderedSet<String>,\n    pending_bridges: UnorderedMap<u64, BridgeProposal>,\n    bridge_counter: u64,\n}\n\n#[derive(BorshSerialize, BorshDeserialize)]\npub struct BridgeProposal {\n    pub id: u64,\n    pub source_chain: String,\n    pub target_chain: String,\n    pub amount: u128,\n    pub recipient: String,\n    pub status: BridgeStatus,\n}\n\n#[derive(BorshSerialize, BorshDeserialize)]\npub enum BridgeStatus {\n    Pending,\n    Approved,\n    Executed,\n    Failed,\n}\n\n#[app::logic]\nimpl CrossChainBridge {\n    pub fn create_bridge_proposal(\n        &mut self,\n        source_chain: String,\n        target_chain: String,\n        amount: u128,\n        recipient: String,\n    ) -> Result<u64, String> {\n        let proposal_id = self.bridge_counter;\n        self.bridge_counter += 1;\n\n        let bridge_proposal = BridgeProposal {\n            id: proposal_id,\n            source_chain,\n            target_chain,\n            amount,\n            recipient,\n            status: BridgeStatus::Pending,\n        };\n\n        self.pending_bridges.insert(proposal_id, bridge_proposal);\n\n        // Create external proposal for the bridge operation\n        // Both approaches work identically\n        let _external_proposal_id = Self::external()\n            .propose()\n            .external_function_call(\n                "bridge.near".to_string(),\n                "initiate_bridge".to_string(),\n                serde_json::to_string(&bridge_proposal).unwrap(),\n                0,\n            )\n            .send();\n\n        Ok(proposal_id)\n    }\n\n    pub fn approve_bridge(&mut self, proposal_id: u64) -> Result<(), String> {\n        if !self.bridge_operators.contains(&env::predecessor_account_id()) {\n            return Err("Only bridge operators can approve bridges".to_string());\n        }\n\n        let mut bridge = self.pending_bridges.get_mut(&proposal_id)\n            .ok_or("Bridge proposal not found")?;\n\n        if bridge.status != BridgeStatus::Pending {\n            return Err("Bridge is not in pending status".to_string());\n        }\n\n        bridge.status = BridgeStatus::Approved;\n\n        // Note: In a real implementation, you would need to map the local proposal ID\n        // to the external proposal ID for approval\n        // For now, we\'ll just update the local status\n\n        Ok(())\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,a.jsx)(n.h3,{id:"1-always-validate-proposals",children:"1. Always Validate Proposals"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'pub fn create_proposal(&mut self, actions: Vec<ProposalAction>) -> Result<ProposalId, String> {\n    // Validate proposal parameters\n    self.validate_proposal_actions(&actions)?;\n\n    // Check permissions\n    if !self.can_create_proposals(&env::predecessor_account_id()) {\n        return Err("Insufficient permissions".to_string());\n    }\n\n    // Create proposal - both approaches work\n    let proposal_id = Self::external().propose();\n    // OR: let proposal_id = External::propose();\n\n    // Add actions one by one with validation\n    for action in actions {\n        proposal_id = self.add_validated_action(proposal_id, action)?;\n    }\n\n    Ok(proposal_id.send())\n}\n\nfn validate_proposal_actions(&self, actions: &[ProposalAction]) -> Result<(), String> {\n    for action in actions {\n        match action {\n            ProposalAction::ExternalFunctionCall { deposit, .. } => {\n                if *deposit > self.max_proposal_deposit {\n                    return Err("Deposit too high".to_string());\n                }\n            }\n            ProposalAction::Transfer { amount, .. } => {\n                if *amount > self.max_transfer_amount {\n                    return Err("Transfer amount too high".to_string());\n                }\n            }\n            _ => {}\n        }\n    }\n    Ok(())\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"2-use-events-for-tracking",children:"2. Use Events for Tracking"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"#[app::event]\npub enum GovernanceEvent<'a> {\n    ProposalCreated { id: &'a ProposalId, creator: &'a str },\n    ProposalApproved { id: &'a ProposalId, approver: &'a str },\n    ProposalExecuted { id: &'a ProposalId },\n}\n\n#[app::logic]\nimpl GovernanceApp {\n    pub fn approve_proposal(&mut self, proposal_id: ProposalId) -> Result<(), String> {\n        // ... approval logic ...\n\n        app::emit!(GovernanceEvent::ProposalApproved {\n            id: &proposal_id,\n            approver: &env::predecessor_account_id(),\n        });\n\n        Ok(())\n    }\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"3-implement-proper-error-handling",children:"3. Implement Proper Error Handling"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'pub fn approve_proposal(&mut self, proposal_id: ProposalId) -> Result<(), String> {\n    let proposal = self.proposals.get(&proposal_id)\n        .ok_or("Proposal not found")?;\n\n    if proposal.executed {\n        return Err("Proposal already executed".to_string());\n    }\n\n    if !self.can_approve_proposals(&env::predecessor_account_id()) {\n        return Err("Insufficient permissions".to_string());\n    }\n\n    // Approve with error handling - both approaches work\n    Self::external().approve(proposal_id);\n    // OR: External::approve(proposal_id);\n\n    // Update local state\n    if let Some(mut proposal) = self.proposals.get_mut(&proposal_id) {\n        proposal.approvals.insert(env::predecessor_account_id());\n    }\n\n    Ok(())\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"4-use-batch-operations-for-efficiency",children:"4. Use Batch Operations for Efficiency"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"pub fn approve_multiple_proposals(&mut self, proposal_ids: Vec<ProposalId>) -> Result<(), String> {\n    for proposal_id in proposal_ids {\n        self.approve_proposal(proposal_id)?;\n    }\n    Ok(())\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"important-notes",children:"Important Notes"}),"\n",(0,a.jsxs)(n.h3,{id:"-both-apis-are-valid-and-equivalent",children:["\u2705 ",(0,a.jsx)(n.strong,{children:"Both APIs Are Valid and Equivalent"})]}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.code,{children:"Self::external()"})})," - Generated automatically by ",(0,a.jsx)(n.code,{children:"#[app::state]"})," macro"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.code,{children:"External::"})})," - Direct usage of the External struct"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Both work identically"})," - Choose the style that fits your codebase"]}),"\n"]}),"\n",(0,a.jsxs)(n.h3,{id:"-how-it-actually-works",children:["\ud83d\udd04 ",(0,a.jsx)(n.strong,{children:"How It Actually Works"})]}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Macro Generation"}),": ",(0,a.jsx)(n.code,{children:"#[app::state]"})," automatically generates\n",(0,a.jsx)(n.code,{children:"Self::external()"})," method"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Proposal Creation"}),": Use either ",(0,a.jsx)(n.code,{children:"Self::external().propose()"})," or\n",(0,a.jsx)(n.code,{children:"External::propose()"})," (they are equivalent - ",(0,a.jsx)(n.code,{children:"Self::external()"})," returns an\n",(0,a.jsx)(n.code,{children:"External"})," instance)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Action Building"}),": Use the ",(0,a.jsx)(n.code,{children:"DraftProposal"})," builder methods to add actions"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Proposal Submission"}),": Call ",(0,a.jsx)(n.code,{children:".send()"})," to submit the proposal and get a\n",(0,a.jsx)(n.code,{children:"ProposalId"})]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Approval"}),": Use either ",(0,a.jsx)(n.code,{children:"Self::external().approve()"})," or\n",(0,a.jsx)(n.code,{children:"External::approve()"})]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"External Execution"}),": Proposals are executed by the external proxy contract\nsystem"]}),"\n"]}),"\n",(0,a.jsxs)(n.h3,{id:"-next-steps",children:["\ud83d\udcda ",(0,a.jsx)(n.strong,{children:"Next Steps"})]}),"\n",(0,a.jsx)(n.p,{children:"This guide covers the essential aspects of Calimero's external proposal system.\nFor more advanced topics, explore:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"./rust-sdk-deep-dive",children:"Building Complex Applications"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"./calimero-collections",children:"Calimero Collections Reference"})}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Remember to always test your governance systems thoroughly and implement proper\nsecurity measures for production deployments."})]})}function d(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},68820:(e,n,r)=>{r.d(n,{R:()=>l,x:()=>t});var o=r(30758);const a={},s=o.createContext(a);function l(e){const n=o.useContext(s);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:l(e.components),o.createElement(s.Provider,{value:n},e.children)}}}]);