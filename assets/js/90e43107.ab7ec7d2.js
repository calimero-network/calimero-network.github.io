"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[5716],{29174:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"developer-tools/SDK/protocol-sdk/calimero-collections","title":"Calimero Collections Reference","description":"This comprehensive reference covers all available collections in the Calimero","source":"@site/docs/05-developer-tools/02-SDK/03-protocol-sdk/04-calimero-collections.mdx","sourceDirName":"05-developer-tools/02-SDK/03-protocol-sdk","slug":"/developer-tools/SDK/protocol-sdk/calimero-collections","permalink":"/developer-tools/SDK/protocol-sdk/calimero-collections","draft":false,"unlisted":false,"editUrl":"https://github.com/calimero-network/calimero-network.github.io/edit/master/docs/05-developer-tools/02-SDK/03-protocol-sdk/04-calimero-collections.mdx","tags":[],"version":"current","lastUpdatedAt":1755423442000,"sidebarPosition":4,"frontMatter":{"id":"calimero-collections","title":"Calimero Collections Reference"},"sidebar":"tutorialSidebar","previous":{"title":"Rust SDK Deep Dive","permalink":"/developer-tools/SDK/protocol-sdk/rust-sdk-deep-dive"},"next":{"title":"TypeScript Client SDK","permalink":"/developer-tools/SDK/client-sdk/client-ts-sdk"}}');var t=r(86070),i=r(74450);const o={id:"calimero-collections",title:"Calimero Collections Reference"},l="Calimero Collections Reference",a={},c=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Overview",id:"overview",level:2},{value:"Core Collections",id:"core-collections",level:2},{value:"UnorderedMap",id:"unorderedmap",level:3},{value:"Basic Usage",id:"basic-usage",level:4},{value:"Advanced Operations",id:"advanced-operations",level:4},{value:"UnorderedSet",id:"unorderedset",level:3},{value:"Basic Usage",id:"basic-usage-1",level:4},{value:"Set Operations",id:"set-operations",level:4},{value:"Vector",id:"vector",level:3},{value:"Basic Usage",id:"basic-usage-2",level:4},{value:"Advanced Vector Operations",id:"advanced-vector-operations",level:4},{value:"Specialized Collections",id:"specialized-collections",level:2},{value:"LookupMap",id:"lookupmap",level:3},{value:"TreeMap",id:"treemap",level:3},{value:"Performance Characteristics",id:"performance-characteristics",level:2},{value:"Operation Complexity",id:"operation-complexity",level:3},{value:"Memory Usage",id:"memory-usage",level:3},{value:"When to Use Each Collection",id:"when-to-use-each-collection",level:3},{value:"Use UnorderedMap when:",id:"use-unorderedmap-when",level:4},{value:"Use UnorderedSet when:",id:"use-unorderedset-when",level:4},{value:"Use Vector when:",id:"use-vector-when",level:4},{value:"Use LookupMap when:",id:"use-lookupmap-when",level:4},{value:"Use TreeMap when:",id:"use-treemap-when",level:4},{value:"Collection Patterns",id:"collection-patterns",level:2},{value:"Composite Collections",id:"composite-collections",level:3},{value:"Indexed Collections",id:"indexed-collections",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Memory Management",id:"memory-management",level:3},{value:"Efficient Iteration",id:"efficient-iteration",level:3},{value:"Batch Operations",id:"batch-operations",level:3},{value:"Migration from Standard Collections",id:"migration-from-standard-collections",level:2},{value:"From std::collections::HashMap",id:"from-stdcollectionshashmap",level:3},{value:"From std::collections::HashSet",id:"from-stdcollectionshashset",level:3},{value:"From Vec",id:"from-vec",level:3}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"calimero-collections-reference",children:"Calimero Collections Reference"})}),"\n",(0,t.jsx)(n.p,{children:"This comprehensive reference covers all available collections in the Calimero\nSDK, their performance characteristics, and best practices for using them\neffectively."}),"\n",(0,t.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#overview",children:"Overview"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#core-collections",children:"Core Collections"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#specialized-collections",children:"Specialized Collections"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#performance-characteristics",children:"Performance Characteristics"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#collection-patterns",children:"Collection Patterns"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#best-practices",children:"Best Practices"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#migration-from-standard-collections",children:"Migration from Standard Collections"})}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,t.jsx)(n.p,{children:"Calimero collections are specifically designed for WebAssembly and decentralized\napplications. They provide:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Wasm Optimization"}),": Designed for efficient serialization and memory usage"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Persistent Storage"}),": Automatic integration with Calimero's storage system"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Type Safety"}),": Full Rust type safety with compile-time guarantees"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Performance"}),": Optimized for common operations in decentralized apps"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"core-collections",children:"Core Collections"}),"\n",(0,t.jsx)(n.h3,{id:"unorderedmap",children:"UnorderedMap"}),"\n",(0,t.jsx)(n.p,{children:"A hash map implementation optimized for Wasm with O(1) average case operations."}),"\n",(0,t.jsx)(n.h4,{id:"basic-usage",children:"Basic Usage"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'use calimero_storage::collections::UnorderedMap;\n\n#[app::state]\n#[derive(Default, BorshSerialize, BorshDeserialize)]\n#[borsh(crate = "calimero_sdk::borsh")]\nstruct UserRegistry {\n    users: UnorderedMap<String, UserProfile>,\n    user_count: u32,\n}\n\n#[app::logic]\nimpl UserRegistry {\n    pub fn add_user(&mut self, username: String, profile: UserProfile) -> Result<(), String> {\n        if self.users.contains_key(&username) {\n            return Err("User already exists".to_string());\n        }\n\n        self.users.insert(username, profile);\n        self.user_count += 1;\n        Ok(())\n    }\n\n    pub fn get_user(&self, username: &str) -> Option<&UserProfile> {\n        self.users.get(username)\n    }\n\n    pub fn update_user(&mut self, username: String, profile: UserProfile) -> Result<(), String> {\n        if !self.users.contains_key(&username) {\n            return Err("User not found".to_string());\n        }\n\n        self.users.insert(username, profile);\n        Ok(())\n    }\n\n    pub fn remove_user(&mut self, username: &str) -> Option<UserProfile> {\n        let user = self.users.remove(username);\n        if user.is_some() {\n            self.user_count -= 1;\n        }\n        user\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h4,{id:"advanced-operations",children:"Advanced Operations"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'#[app::logic]\nimpl UserRegistry {\n    // Batch operations\n    pub fn add_multiple_users(&mut self, users: Vec<(String, UserProfile)>) -> Result<(), String> {\n        for (username, profile) in users {\n            if self.users.contains_key(&username) {\n                return Err(format!("User {} already exists", username));\n            }\n            self.users.insert(username, profile);\n            self.user_count += 1;\n        }\n        Ok(())\n    }\n\n    // Filtering and searching\n    pub fn get_users_by_role(&self, role: UserRole) -> Vec<&UserProfile> {\n        self.users\n            .iter()\n            .filter(|(_, profile)| profile.role == role)\n            .map(|(_, profile)| profile)\n            .collect()\n    }\n\n    // Aggregation\n    pub fn get_user_stats(&self) -> UserStats {\n        let mut stats = UserStats::default();\n\n        for (_, profile) in self.users.iter() {\n            stats.total_users += 1;\n            if profile.is_active {\n                stats.active_users += 1;\n            }\n            if profile.is_premium {\n                stats.premium_users += 1;\n            }\n        }\n\n        stats\n    }\n\n    // Conditional updates\n    pub fn update_user_if_exists(&mut self, username: String, profile: UserProfile) -> bool {\n        if self.users.contains_key(&username) {\n            self.users.insert(username, profile);\n            true\n        } else {\n            false\n        }\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"unorderedset",children:"UnorderedSet"}),"\n",(0,t.jsx)(n.p,{children:"A hash set for unique elements with O(1) average case operations."}),"\n",(0,t.jsx)(n.h4,{id:"basic-usage-1",children:"Basic Usage"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'use calimero_storage::collections::UnorderedSet;\n\n#[app::state]\n#[derive(Default, BorshSerialize, BorshDeserialize)]\n#[borsh(crate = "calimero_sdk::borsh")]\nstruct AccessControl {\n    admins: UnorderedSet<String>,\n    moderators: UnorderedSet<String>,\n    banned_users: UnorderedSet<String>,\n}\n\n#[app::logic]\nimpl AccessControl {\n    pub fn add_admin(&mut self, username: String) -> bool {\n        self.admins.insert(username)\n    }\n\n    pub fn remove_admin(&mut self, username: &str) -> bool {\n        self.admins.remove(username)\n    }\n\n    pub fn is_admin(&self, username: &str) -> bool {\n        self.admins.contains(username)\n    }\n\n    pub fn promote_to_moderator(&mut self, username: String) -> Result<(), String> {\n        if !self.admins.contains(&username) {\n            return Err("Only admins can be promoted to moderator".to_string());\n        }\n\n        self.moderators.insert(username);\n        Ok(())\n    }\n\n    pub fn ban_user(&mut self, username: String) {\n        // Remove from all access levels\n        self.admins.remove(&username);\n        self.moderators.remove(&username);\n        self.banned_users.insert(username);\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h4,{id:"set-operations",children:"Set Operations"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"#[app::logic]\nimpl AccessControl {\n    // Union of two sets\n    pub fn get_all_staff(&self) -> Vec<&String> {\n        let mut all_staff: Vec<&String> = self.admins.iter().collect();\n        all_staff.extend(self.moderators.iter());\n        all_staff\n    }\n\n    // Check if user has any elevated privileges\n    pub fn has_privileges(&self, username: &str) -> bool {\n        self.admins.contains(username) || self.moderators.contains(username)\n    }\n\n    // Get users with specific role\n    pub fn get_users_by_role(&self, role: UserRole) -> Vec<&String> {\n        match role {\n            UserRole::Admin => self.admins.iter().collect(),\n            UserRole::Moderator => self.moderators.iter().collect(),\n            UserRole::User => vec![], // Regular users not stored in sets\n        }\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"vector",children:"Vector"}),"\n",(0,t.jsx)(n.p,{children:"A dynamic array implementation with O(1) amortized push and O(n) insert/remove\noperations."}),"\n",(0,t.jsx)(n.h4,{id:"basic-usage-2",children:"Basic Usage"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'use calimero_storage::collections::Vector;\n\n#[app::state]\n#[derive(Default, BorshSerialize, BorshDeserialize)]\n#[borsh(crate = "calimero_sdk::borsh")]\nstruct TaskManager {\n    pending_tasks: Vector<Task>,\n    completed_tasks: Vector<Task>,\n    task_counter: u64,\n}\n\n#[derive(BorshSerialize, BorshDeserialize, Clone)]\nstruct Task {\n    id: u64,\n    title: String,\n    description: String,\n    priority: TaskPriority,\n    created_at: u64,\n}\n\n#[app::logic]\nimpl TaskManager {\n    pub fn create_task(&mut self, title: String, description: String, priority: TaskPriority) -> u64 {\n        let task = Task {\n            id: self.task_counter,\n            title,\n            description,\n            priority,\n            created_at: env::block_timestamp(),\n        };\n\n        self.pending_tasks.push(task);\n        self.task_counter += 1;\n        self.task_counter - 1\n    }\n\n    pub fn get_task(&self, id: u64) -> Option<&Task> {\n        self.pending_tasks\n            .iter()\n            .chain(self.completed_tasks.iter())\n            .find(|task| task.id == id)\n    }\n\n    pub fn complete_task(&mut self, id: u64) -> Result<(), String> {\n        let index = self.pending_tasks\n            .iter()\n            .position(|task| task.id == id)\n            .ok_or("Task not found")?;\n\n        let task = self.pending_tasks.remove(index);\n        self.completed_tasks.push(task);\n        Ok(())\n    }\n\n    pub fn get_tasks_by_priority(&self, priority: TaskPriority) -> Vec<&Task> {\n        self.pending_tasks\n            .iter()\n            .filter(|task| task.priority == priority)\n            .collect()\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h4,{id:"advanced-vector-operations",children:"Advanced Vector Operations"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"#[app::logic]\nimpl TaskManager {\n    // Batch operations\n    pub fn create_multiple_tasks(&mut self, tasks: Vec<(String, String, TaskPriority)>) -> Vec<u64> {\n        let mut ids = Vec::new();\n\n        for (title, description, priority) in tasks {\n            let id = self.create_task(title, description, priority);\n            ids.push(id);\n        }\n\n        ids\n    }\n\n    // Sorting and filtering\n    pub fn get_high_priority_tasks(&self) -> Vec<&Task> {\n        let mut high_priority: Vec<&Task> = self.pending_tasks\n            .iter()\n            .filter(|task| task.priority == TaskPriority::High)\n            .collect();\n\n        // Sort by creation time (oldest first)\n        high_priority.sort_by(|a, b| a.created_at.cmp(&b.created_at));\n        high_priority\n    }\n\n    // Pagination\n    pub fn get_tasks_page(&self, page: u32, page_size: u32) -> Vec<&Task> {\n        let start = (page * page_size) as usize;\n        let end = start + page_size as usize;\n\n        self.pending_tasks\n            .iter()\n            .skip(start)\n            .take(page_size as usize)\n            .collect()\n    }\n\n    // Search functionality\n    pub fn search_tasks(&self, query: &str) -> Vec<&Task> {\n        self.pending_tasks\n            .iter()\n            .filter(|task| {\n                task.title.to_lowercase().contains(&query.to_lowercase()) ||\n                task.description.to_lowercase().contains(&query.to_lowercase())\n            })\n            .collect()\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"specialized-collections",children:"Specialized Collections"}),"\n",(0,t.jsx)(n.h3,{id:"lookupmap",children:"LookupMap"}),"\n",(0,t.jsx)(n.p,{children:"A map optimized for cases where you need to iterate over keys or values\nfrequently."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'use calimero_storage::collections::LookupMap;\n\n#[app::state]\n#[derive(Default, BorshSerialize, BorshDeserialize)]\n#[borsh(crate = "calimero_sdk::borsh")]\nstruct Analytics {\n    // User -> Page views\n    page_views: LookupMap<String, u32>,\n    // Page -> Total views\n    total_views: LookupMap<String, u64>,\n}\n\n#[app::logic]\nimpl Analytics {\n    pub fn record_page_view(&mut self, user: String, page: String) {\n        // Increment user\'s page views\n        let user_views = self.page_views.get(&user).unwrap_or(0);\n        self.page_views.insert(user, user_views + 1);\n\n        // Increment total page views\n        let total = self.total_views.get(&page).unwrap_or(0);\n        self.total_views.insert(page, total + 1);\n    }\n\n    pub fn get_user_stats(&self, user: &str) -> u32 {\n        self.page_views.get(user).unwrap_or(0)\n    }\n\n    pub fn get_page_stats(&self, page: &str) -> u64 {\n        self.total_views.get(page).unwrap_or(0)\n    }\n\n    pub fn get_top_pages(&self, limit: usize) -> Vec<(String, u64)> {\n        let mut pages: Vec<(String, u64)> = self.total_views\n            .iter()\n            .map(|(page, views)| (page.clone(), *views))\n            .collect();\n\n        pages.sort_by(|a, b| b.1.cmp(&a.1));\n        pages.truncate(limit);\n        pages\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"treemap",children:"TreeMap"}),"\n",(0,t.jsx)(n.p,{children:"A sorted map implementation for cases where you need ordered keys."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'use calimero_storage::collections::TreeMap;\n\n#[app::state]\n#[derive(Default, BorshSerialize, BorshDeserialize)]\n#[borsh(crate = "calimero_sdk::borsh")]\nstruct Leaderboard {\n    // Score -> List of users with that score\n    score_rankings: TreeMap<u32, UnorderedSet<String>>,\n    // User -> Current score\n    user_scores: UnorderedMap<String, u32>,\n}\n\n#[app::logic]\nimpl Leaderboard {\n    pub fn update_score(&mut self, user: String, new_score: u32) {\n        // Remove user from old score ranking\n        if let Some(old_score) = self.user_scores.get(&user) {\n            if let Some(users_at_score) = self.score_rankings.get_mut(old_score) {\n                users_at_score.remove(&user);\n\n                // Remove empty score entry\n                if users_at_score.is_empty() {\n                    self.score_rankings.remove(old_score);\n                }\n            }\n        }\n\n        // Add user to new score ranking\n        self.score_rankings\n            .entry(new_score)\n            .or_insert_with(UnorderedSet::new)\n            .insert(user.clone());\n\n        // Update user\'s score\n        self.user_scores.insert(user, new_score);\n    }\n\n    pub fn get_top_players(&self, limit: usize) -> Vec<(String, u32)> {\n        let mut top_players = Vec::new();\n\n        // Iterate in reverse order (highest scores first)\n        for (score, users) in self.score_rankings.iter().rev() {\n            for user in users.iter() {\n                top_players.push((user.clone(), *score));\n                if top_players.len() >= limit {\n                    break;\n                }\n            }\n            if top_players.len() >= limit {\n                break;\n            }\n        }\n\n        top_players\n    }\n\n    pub fn get_user_rank(&self, user: &str) -> Option<u32> {\n        let user_score = self.user_scores.get(user)?;\n        let mut rank = 1;\n\n        // Count users with higher scores\n        for (score, users) in self.score_rankings.iter().rev() {\n            if score > user_score {\n                rank += users.len() as u32;\n            } else {\n                break;\n            }\n        }\n\n        Some(rank)\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"performance-characteristics",children:"Performance Characteristics"}),"\n",(0,t.jsx)(n.h3,{id:"operation-complexity",children:"Operation Complexity"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Collection"}),(0,t.jsx)(n.th,{children:"Insert"}),(0,t.jsx)(n.th,{children:"Remove"}),(0,t.jsx)(n.th,{children:"Lookup"}),(0,t.jsx)(n.th,{children:"Iteration"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"UnorderedMap"}),(0,t.jsx)(n.td,{children:"O(1) avg"}),(0,t.jsx)(n.td,{children:"O(1) avg"}),(0,t.jsx)(n.td,{children:"O(1) avg"}),(0,t.jsx)(n.td,{children:"O(n)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"UnorderedSet"}),(0,t.jsx)(n.td,{children:"O(1) avg"}),(0,t.jsx)(n.td,{children:"O(1) avg"}),(0,t.jsx)(n.td,{children:"O(1) avg"}),(0,t.jsx)(n.td,{children:"O(n)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Vector"}),(0,t.jsx)(n.td,{children:"O(1) amortized"}),(0,t.jsx)(n.td,{children:"O(n)"}),(0,t.jsx)(n.td,{children:"O(1)"}),(0,t.jsx)(n.td,{children:"O(n)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"LookupMap"}),(0,t.jsx)(n.td,{children:"O(1) avg"}),(0,t.jsx)(n.td,{children:"O(1) avg"}),(0,t.jsx)(n.td,{children:"O(1) avg"}),(0,t.jsx)(n.td,{children:"O(n)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"TreeMap"}),(0,t.jsx)(n.td,{children:"O(log n)"}),(0,t.jsx)(n.td,{children:"O(log n)"}),(0,t.jsx)(n.td,{children:"O(log n)"}),(0,t.jsx)(n.td,{children:"O(n)"})]})]})]}),"\n",(0,t.jsx)(n.h3,{id:"memory-usage",children:"Memory Usage"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"UnorderedMap/Set"}),": Most memory efficient for large datasets"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Vector"}),": Good for sequential access, moderate memory overhead"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"LookupMap"}),": Optimized for iteration, slightly more memory than UnorderedMap"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"TreeMap"}),": Highest memory overhead due to tree structure"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"when-to-use-each-collection",children:"When to Use Each Collection"}),"\n",(0,t.jsx)(n.h4,{id:"use-unorderedmap-when",children:"Use UnorderedMap when:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"You need fast key-value lookups"}),"\n",(0,t.jsx)(n.li,{children:"Order doesn't matter"}),"\n",(0,t.jsx)(n.li,{children:"Memory efficiency is important"}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"use-unorderedset-when",children:"Use UnorderedSet when:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"You need to track unique elements"}),"\n",(0,t.jsx)(n.li,{children:"Fast membership testing is required"}),"\n",(0,t.jsx)(n.li,{children:"Order doesn't matter"}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"use-vector-when",children:"Use Vector when:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"You need ordered elements"}),"\n",(0,t.jsx)(n.li,{children:"Sequential access is common"}),"\n",(0,t.jsx)(n.li,{children:"You frequently add/remove from the end"}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"use-lookupmap-when",children:"Use LookupMap when:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"You frequently iterate over keys or values"}),"\n",(0,t.jsx)(n.li,{children:"Memory overhead is acceptable"}),"\n",(0,t.jsx)(n.li,{children:"You need both map and iteration performance"}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"use-treemap-when",children:"Use TreeMap when:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"You need sorted keys"}),"\n",(0,t.jsx)(n.li,{children:"Range queries are common"}),"\n",(0,t.jsx)(n.li,{children:"Order matters for your use case"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"collection-patterns",children:"Collection Patterns"}),"\n",(0,t.jsx)(n.h3,{id:"composite-collections",children:"Composite Collections"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'#[app::state]\n#[derive(Default, BorshSerialize, BorshDeserialize)]\n#[borsh(crate = "calimero_sdk::borsh")]\nstruct SocialNetwork {\n    // User -> Friends\n    friendships: UnorderedMap<String, UnorderedSet<String>>,\n    // User -> Posts\n    user_posts: UnorderedMap<String, Vector<Post>>,\n    // Post -> Reactions\n    post_reactions: UnorderedMap<u64, UnorderedMap<String, ReactionType>>,\n    // User -> Followers\n    followers: UnorderedMap<String, UnorderedSet<String>>,\n    // User -> Following\n    following: UnorderedMap<String, UnorderedSet<String>>,\n}\n\n#[app::logic]\nimpl SocialNetwork {\n    pub fn add_friend(&mut self, user: String, friend: String) {\n        // Add bidirectional friendship\n        self.friendships\n            .entry(user.clone())\n            .or_insert_with(UnorderedSet::new)\n            .insert(friend.clone());\n\n        self.friendships\n            .entry(friend)\n            .or_insert_with(UnorderedSet::new)\n            .insert(user);\n    }\n\n    pub fn create_post(&mut self, user: String, content: String) -> u64 {\n        let post = Post {\n            id: self.generate_post_id(),\n            content,\n            author: user.clone(),\n            created_at: env::block_timestamp(),\n        };\n\n        self.user_posts\n            .entry(user)\n            .or_insert_with(Vector::new)\n            .push(post.clone());\n\n        post.id\n    }\n\n    pub fn follow_user(&mut self, follower: String, following: String) {\n        if follower == following {\n            return; // Can\'t follow yourself\n        }\n\n        self.followers\n            .entry(following.clone())\n            .or_insert_with(UnorderedSet::new)\n            .insert(follower.clone());\n\n        self.following\n            .entry(follower)\n            .or_insert_with(UnorderedSet::new)\n            .insert(following);\n    }\n\n    pub fn get_feed(&self, user: &str) -> Vec<&Post> {\n        let mut feed = Vec::new();\n\n        // Get posts from followed users\n        if let Some(following) = self.following.get(user) {\n            for followed_user in following.iter() {\n                if let Some(posts) = self.user_posts.get(followed_user) {\n                    feed.extend(posts.iter());\n                }\n            }\n        }\n\n        // Sort by creation time (newest first)\n        feed.sort_by(|a, b| b.created_at.cmp(&a.created_at));\n        feed\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"indexed-collections",children:"Indexed Collections"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'#[app::state]\n#[derive(Default, BorshSerialize, BorshDeserialize)]\n#[borsh(crate = "calimero_sdk::borsh")]\nstruct ProductCatalog {\n    // Product ID -> Product details\n    products: UnorderedMap<u64, Product>,\n    // Category -> Product IDs\n    products_by_category: UnorderedMap<String, UnorderedSet<u64>>,\n    // Price range -> Product IDs\n    products_by_price: TreeMap<u32, UnorderedSet<u64>>,\n    // Search index: word -> Product IDs\n    search_index: UnorderedMap<String, UnorderedSet<u64>>,\n}\n\n#[app::logic]\nimpl ProductCatalog {\n    pub fn add_product(&mut self, product: Product) {\n        let product_id = product.id;\n\n        // Add to main products map\n        self.products.insert(product_id, product.clone());\n\n        // Add to category index\n        self.products_by_category\n            .entry(product.category.clone())\n            .or_insert_with(UnorderedSet::new)\n            .insert(product_id);\n\n        // Add to price index\n        self.products_by_price\n            .entry(product.price)\n            .or_insert_with(UnorderedSet::new)\n            .insert(product_id);\n\n        // Add to search index\n        for word in product.name.split_whitespace() {\n            let word = word.to_lowercase();\n            self.search_index\n                .entry(word)\n                .or_insert_with(UnorderedSet::new)\n                .insert(product_id);\n        }\n    }\n\n    pub fn search_products(&self, query: &str) -> Vec<&Product> {\n        let query_words: Vec<&str> = query.split_whitespace().collect();\n        let mut product_ids = UnorderedSet::new();\n\n        // Find products matching all query words\n        for word in query_words {\n            let word = word.to_lowercase();\n            if let Some(ids) = self.search_index.get(&word) {\n                if product_ids.is_empty() {\n                    product_ids = ids.clone();\n                } else {\n                    // Intersection of all word matches\n                    product_ids = product_ids.intersection(ids).cloned().collect();\n                }\n            }\n        }\n\n        // Convert IDs to products\n        product_ids\n            .iter()\n            .filter_map(|id| self.products.get(id))\n            .collect()\n    }\n\n    pub fn get_products_by_category(&self, category: &str) -> Vec<&Product> {\n        self.products_by_category\n            .get(category)\n            .map(|ids| {\n                ids.iter()\n                    .filter_map(|id| self.products.get(id))\n                    .collect()\n            })\n            .unwrap_or_default()\n    }\n\n    pub fn get_products_in_price_range(&self, min_price: u32, max_price: u32) -> Vec<&Product> {\n        let mut products = Vec::new();\n\n        for (price, ids) in self.products_by_price.range(min_price..=max_price) {\n            for id in ids.iter() {\n                if let Some(product) = self.products.get(id) {\n                    products.push(product);\n                }\n            }\n        }\n\n        products\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,t.jsx)(n.h3,{id:"memory-management",children:"Memory Management"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"// \u2705 Good: Clean up old data\npub fn cleanup_old_sessions(&mut self, cutoff_time: u64) {\n    let mut to_remove = Vec::new();\n\n    for (session_id, session) in self.active_sessions.iter() {\n        if session.last_activity < cutoff_time {\n            to_remove.push(session_id.clone());\n        }\n    }\n\n    for session_id in to_remove {\n        self.active_sessions.remove(&session_id);\n    }\n}\n\n// \u274c Bad: Never cleaning up\npub fn add_session(&mut self, session: Session) {\n    self.active_sessions.insert(session.id.clone(), session);\n    // No cleanup - memory will grow indefinitely\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"efficient-iteration",children:"Efficient Iteration"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"// \u2705 Good: Use references to avoid cloning\npub fn get_active_users(&self) -> Vec<&UserProfile> {\n    self.users\n        .iter()\n        .filter(|(_, profile)| profile.is_active)\n        .map(|(_, profile)| profile)\n        .collect()\n}\n\n// \u274c Bad: Unnecessary cloning\npub fn get_active_users_bad(&self) -> Vec<UserProfile> {\n    self.users\n        .iter()\n        .filter(|(_, profile)| profile.is_active)\n        .map(|(_, profile)| profile.clone()) // Unnecessary clone\n        .collect()\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"batch-operations",children:"Batch Operations"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'// \u2705 Good: Batch operations for better performance\npub fn bulk_update_users(&mut self, updates: Vec<(String, UserProfile)>) -> Result<(), String> {\n    for (username, profile) in updates {\n        if !self.users.contains_key(&username) {\n            return Err(format!("User {} not found", username));\n        }\n        self.users.insert(username, profile);\n    }\n    Ok(())\n}\n\n// \u274c Bad: Multiple individual operations\npub fn bulk_update_users_bad(&mut self, updates: Vec<(String, UserProfile)>) -> Result<(), String> {\n    for (username, profile) in updates {\n        self.update_user(username, profile)?; // Multiple function calls\n    }\n    Ok(())\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"migration-from-standard-collections",children:"Migration from Standard Collections"}),"\n",(0,t.jsx)(n.h3,{id:"from-stdcollectionshashmap",children:"From std::collections::HashMap"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'// Before (standard collections)\nuse std::collections::HashMap;\n\nstruct OldApp {\n    users: HashMap<String, UserProfile>,\n}\n\n// After (Calimero collections)\nuse calimero_storage::collections::UnorderedMap;\n\n#[app::state]\n#[derive(Default, BorshSerialize, BorshDeserialize)]\n#[borsh(crate = "calimero_sdk::borsh")]\nstruct NewApp {\n    users: UnorderedMap<String, UserProfile>,\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"from-stdcollectionshashset",children:"From std::collections::HashSet"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'// Before\nuse std::collections::HashSet;\n\nstruct OldApp {\n    admins: HashSet<String>,\n}\n\n// After\nuse calimero_storage::collections::UnorderedSet;\n\n#[app::state]\n#[derive(Default, BorshSerialize, BorshDeserialize)]\n#[borsh(crate = "calimero_sdk::borsh")]\nstruct NewApp {\n    admins: UnorderedSet<String>,\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"from-vec",children:"From Vec"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'// Before\nstruct OldApp {\n    tasks: Vec<Task>,\n}\n\n// After\nuse calimero_storage::collections::Vector;\n\n#[app::state]\n#[derive(Default, BorshSerialize, BorshDeserialize)]\n#[borsh(crate = "calimero_sdk::borsh")]\nstruct NewApp {\n    tasks: Vector<Task>,\n}\n'})})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},74450:(e,n,r)=>{r.d(n,{R:()=>o,x:()=>l});var s=r(30758);const t={},i=s.createContext(t);function o(e){const n=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);